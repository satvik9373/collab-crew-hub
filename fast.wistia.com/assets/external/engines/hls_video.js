var __webpack_modules__ = {
        27: (t, e) => {
            e.isBoolean = e.isFunction = e.isArray = e.isNonEmptyRecord = e.isRecord = e.isNumber = e.isEmptyString = e.isString = e.isNotNil = e.isNil = e.isUndefined = e.isNull = void 0;
            e.isNull = t => null === t;
            e.isUndefined = t => void 0 === t;
            e.isNil = t => (0, e.isNull)(t) || (0, e.isUndefined)(t);
            e.isNotNil = t => !(0, e.isNil)(t);
            e.isString = t => "string" == typeof t;
            e.isEmptyString = t => (0, e.isString)(t) && "" === t;
            e.isNumber = t => "number" == typeof t;
            e.isRecord = t => (0, e.isNotNil)(t) && "object" == typeof t && !(t instanceof Array);
            e.isNonEmptyRecord = t => (0, e.isRecord)(t) && Object.keys(t).length > 0;
            e.isArray = t => (0, e.isNotNil)(t) && "object" == typeof t && t instanceof Array;
            e.isFunction = t => (0, e.isNotNil)(t) && "function" == typeof t;
            e.isBoolean = t => (0, e.isNotNil)(t) && "boolean" == typeof t
        },
        35: (t, e, i) => {
            i.d(e, {
                getAllApiHandles: () => s
            });
            i(36), i(13);
            var r = i(37);
            var s = function() {
                return (void 0 === (0, r.wData)("video") ? [] : Object.values((0, r.wData)("video"))).concat(void 0 === (0, r.wData)("iframe_api") ? [] : Object.values((0, r.wData)("iframe_api")))
            }
        },
        36: (t, e, i) => {
            i.d(e, {
                getAllApiEmbedElements: () => r
            });
            var r = function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "wistia_embed",
                    e = document.querySelectorAll("div.".concat(t, ",span.").concat(t, ",iframe.").concat(t));
                return Array.from(e).map((function(t) {
                    var e;
                    return "WISTIA-PLAYER" === (null === (e = t.lastChild) || void 0 === e ? void 0 : e.nodeName) ? t.lastChild : t
                }))
            }
        },
        12: (t, e, i) => {
            i.d(e, {
                hasPerformanceMeasureSupport: () => r
            });
            var r = function() {
                var t = window.performance;
                return Boolean(t) && Boolean(t.measure)
            }
        },
        26: (t, e, i) => {
            i.d(e, {
                cacheMediaData: () => a,
                getMediaDataFromCache: () => n,
                uncacheMediaData: () => o
            });
            var r = i(27),
                s = i(28),
                n = function(t) {
                    var e = s.Wistia._remoteData.get("media_".concat(t));
                    return (0, r.isNil)(e) ? null : e
                },
                a = function(t, e) {
                    s.Wistia._remoteData.set("media_".concat(t), e)
                },
                o = function(t) {
                    s.Wistia._remoteData.delete("media_".concat(t))
                }
        },
        28: (t, e, i) => {
            i.d(e, {
                Wistia: () => s
            });
            var r = i(4);
            null == r.root.Wistia && (r.root.Wistia = {
                _destructors: {},
                _initializers: {},
                _mediaDataPromises: {},
                _remoteData: new Map,
                api: function() {
                    return console.error("Accessed Wistia.api() before it was initialized"), null
                },
                defineControl: function() {
                    return console.error("Accessed Wistia.defineControl() before it was initialized"), null
                },
                mixin: function(t, e) {
                    Object.keys(e).forEach((function(i) {
                        (function(t, e) {
                            if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                            return Object.prototype.hasOwnProperty.call(Object(t), e)
                        })(e, i) && (t[i] = e[i])
                    }))
                },
                PublicApi: null,
                uncacheMedia: function() {
                    return console.error("Accessed Wistia.uncacheMedia() before it was initialized"), null
                },
                VisitorKey: null,
                visitorKey: null,
                wistia: void 0
            });
            var s = r.root.Wistia
        },
        23: (t, e, i) => {
            i.d(e, {
                appHostname: () => r
            });
            var r = function() {
                return "".concat(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "app", ".").concat("wistia.com")
            }
        },
        579: (t, e, i) => {
            i.d(e, {
                default: () => s
            });
            var r = i(3);
            null == r.Wistia.engines && (r.Wistia.engines = {});
            const s = function(t, e) {
                r.Wistia.engines[t] = e
            }
        },
        557: (t, e, i) => {
            i.d(e, {
                setup: () => l,
                teardown: () => u
            });
            var r = i(556),
                s = i(558),
                n = i(91),
                a = (0, s.makeCacheable)("bandwidth_tracking"),
                o = (0, s.makeNamespace)("bandwidth_tracking"),
                l = function(t) {
                    var e = t.hls,
                        i = a(t, "persistBandwidthEstimate", (function() {
                            return function() {
                                var t = e.abrController.bwEstimator.getEstimate();
                                (0, n.setOrGet)("hls.bandwidth_estimate", t)
                            }
                        }));
                    e.off(r.default.Events.FRAG_LOADED, i), e.on(r.default.Events.FRAG_LOADED, i)
                },
                u = function(t) {
                    o(t).persistBandwidthEstimate && t.hls && t.hls.off(r.default.Events.FRAG_LOADED, o(t).persistBandwidthEstimate), (0, s.uncacheNamespace)("bandwidth_tracking", t)
                }
        },
        582: (t, e, i) => {
            i.d(e, {
                default: () => S
            });
            var r = i(556),
                s = i(30);

            function n(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var r = e[i];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, c(r.key), r)
                }
            }

            function a(t, e, i) {
                return e = g(e),
                    function(t, e) {
                        if (e && ("object" == typeof e || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                        return function(t) {
                            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return t
                        }(t)
                    }(t, o() ? Reflect.construct(e, i || [], g(t).constructor) : e.apply(t, i))
            }

            function o() {
                try {
                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})))
                } catch (t) {}
                return (o = function() {
                    return !!t
                })()
            }

            function l(t, e, i, r, s, n) {
                return function(t, e, i, r, s) {
                    if (!u(t, e, i, r || t) && s) throw new TypeError("failed to set property");
                    return i
                }(g(n ? t.prototype : t), e, i, r, s)
            }

            function u(t, e, i, r) {
                return u = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function(t, e, i, r) {
                    var s, n = f(t, e);
                    if (n) {
                        if ((s = Object.getOwnPropertyDescriptor(n, e)).set) return s.set.call(r, i), !0;
                        if (!s.writable) return !1
                    }
                    if (s = Object.getOwnPropertyDescriptor(r, e)) {
                        if (!s.writable) return !1;
                        s.value = i, Object.defineProperty(r, e, s)
                    } else ! function(t, e, i) {
                        (e = c(e)) in t ? Object.defineProperty(t, e, {
                            value: i,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : t[e] = i
                    }(r, e, i);
                    return !0
                }, u(t, e, i, r)
            }

            function c(t) {
                var e = function(t, e) {
                    if ("object" != typeof t || !t) return t;
                    var i = t[Symbol.toPrimitive];
                    if (void 0 !== i) {
                        var r = i.call(t, e || "default");
                        if ("object" != typeof r) return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === e ? String : Number)(t)
                }(t, "string");
                return "symbol" == typeof e ? e : e + ""
            }

            function h(t, e, i, r) {
                var s = d(g(1 & r ? t.prototype : t), e, i);
                return 2 & r ? function(t) {
                    return s.apply(i, t)
                } : s
            }

            function d() {
                return d = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t, e, i) {
                    var r = f(t, e);
                    if (r) {
                        var s = Object.getOwnPropertyDescriptor(r, e);
                        return s.get ? s.get.call(arguments.length < 3 ? t : i) : s.value
                    }
                }, d.apply(null, arguments)
            }

            function f(t, e) {
                for (; !{}.hasOwnProperty.call(t, e) && null !== (t = g(t)););
                return t
            }

            function g(t) {
                return g = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                }, g(t)
            }

            function m(t, e) {
                return m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                    return t.__proto__ = e, t
                }, m(t, e)
            }

            function p(t, e) {
                if (e.has(t)) throw new TypeError("Cannot initialize the same private elements twice on an object")
            }

            function v(t, e, i) {
                if ("function" == typeof t ? t === e : t.has(e)) return arguments.length < 3 ? e : i;
                throw new TypeError("Private element is not present on this object")
            }
            var y = r.default.DefaultConfig.abrController,
                T = new WeakMap,
                E = new WeakSet,
                S = function(t) {
                    function e(t) {
                        var i, r, s;
                        return function(t, e) {
                                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                            }(this, e), i = a(this, e, [t]), p(r = i, s = E), s.add(r),
                            function(t, e, i) {
                                p(t, e), e.set(t, i)
                            }(i, T, void 0), i.hls = t, i
                    }
                    return function(t, e) {
                        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                        t.prototype = Object.create(e && e.prototype, {
                            constructor: {
                                value: t,
                                writable: !0,
                                configurable: !0
                            }
                        }), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), e && m(t, e)
                    }(e, t), i = e, (r = [{
                        key: "autoLevelCapping",
                        get: function() {
                            return v(E, this, b).call(this, (e = this, (t = T).get(v(t, e))));
                            var t, e
                        },
                        set: function(t) {
                            var e, i, r;
                            i = this, r = t, (e = T).set(v(e, i), r)
                        }
                    }, {
                        key: "nextAutoLevel",
                        get: function() {
                            return v(E, this, b).call(this, h(e, "nextAutoLevel", this, 1))
                        },
                        set: function(t) {
                            l(e, "nextAutoLevel", t, this, 1, 1)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            h(e, "destroy", this, 3)([])
                        }
                    }]) && n(i.prototype, r), s && n(i, s), Object.defineProperty(i, "prototype", {
                        writable: !1
                    }), i;
                    var i, r, s
                }(y);

            function b(t) {
                if (!this.hls.levels || 0 === this.hls.levels.length) return t;
                var e = this.hls.config.qualityMin || 0,
                    i = this.hls.config.qualityMax || 5e3,
                    r = (0, s.findClosestAssetByQuality)(this.hls.levels, e),
                    n = this.hls.levels.indexOf(r),
                    a = (0, s.findClosestAssetByQuality)(this.hls.levels, i),
                    o = this.hls.levels.indexOf(a);
                return t > o ? o : t < n ? n : t
            }
        },
        583: (t, e, i) => {
            i.d(e, {
                default: () => E
            });
            var r = i(556),
                s = i(30);

            function n(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var r = e[i];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, c(r.key), r)
                }
            }

            function a(t, e, i) {
                return e = g(e),
                    function(t, e) {
                        if (e && ("object" == typeof e || "function" == typeof e)) return e;
                        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                        return function(t) {
                            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return t
                        }(t)
                    }(t, o() ? Reflect.construct(e, i || [], g(t).constructor) : e.apply(t, i))
            }

            function o() {
                try {
                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})))
                } catch (t) {}
                return (o = function() {
                    return !!t
                })()
            }

            function l(t, e, i, r, s, n) {
                return function(t, e, i, r, s) {
                    if (!u(t, e, i, r || t) && s) throw new TypeError("failed to set property");
                    return i
                }(g(n ? t.prototype : t), e, i, r, s)
            }

            function u(t, e, i, r) {
                return u = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function(t, e, i, r) {
                    var s, n = f(t, e);
                    if (n) {
                        if ((s = Object.getOwnPropertyDescriptor(n, e)).set) return s.set.call(r, i), !0;
                        if (!s.writable) return !1
                    }
                    if (s = Object.getOwnPropertyDescriptor(r, e)) {
                        if (!s.writable) return !1;
                        s.value = i, Object.defineProperty(r, e, s)
                    } else ! function(t, e, i) {
                        (e = c(e)) in t ? Object.defineProperty(t, e, {
                            value: i,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : t[e] = i
                    }(r, e, i);
                    return !0
                }, u(t, e, i, r)
            }

            function c(t) {
                var e = function(t, e) {
                    if ("object" != typeof t || !t) return t;
                    var i = t[Symbol.toPrimitive];
                    if (void 0 !== i) {
                        var r = i.call(t, e || "default");
                        if ("object" != typeof r) return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === e ? String : Number)(t)
                }(t, "string");
                return "symbol" == typeof e ? e : e + ""
            }

            function h(t, e, i, r) {
                var s = d(g(1 & r ? t.prototype : t), e, i);
                return 2 & r ? function(t) {
                    return s.apply(i, t)
                } : s
            }

            function d() {
                return d = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t, e, i) {
                    var r = f(t, e);
                    if (r) {
                        var s = Object.getOwnPropertyDescriptor(r, e);
                        return s.get ? s.get.call(arguments.length < 3 ? t : i) : s.value
                    }
                }, d.apply(null, arguments)
            }

            function f(t, e) {
                for (; !{}.hasOwnProperty.call(t, e) && null !== (t = g(t)););
                return t
            }

            function g(t) {
                return g = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                }, g(t)
            }

            function m(t, e) {
                return m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                    return t.__proto__ = e, t
                }, m(t, e)
            }

            function p(t, e) {
                (function(t, e) {
                    if (e.has(t)) throw new TypeError("Cannot initialize the same private elements twice on an object")
                })(t, e), e.add(t)
            }

            function v(t, e, i) {
                if ("function" == typeof t ? t === e : t.has(e)) return arguments.length < 3 ? e : i;
                throw new TypeError("Private element is not present on this object")
            }
            var y = r.default.DefaultConfig.capLevelController,
                T = new WeakSet,
                E = function(t) {
                    function e(t) {
                        var i;
                        return function(t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), p(i = a(this, e, [t]), T), i.hls = t, i
                    }
                    return function(t, e) {
                        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                        t.prototype = Object.create(e && e.prototype, {
                            constructor: {
                                value: t,
                                writable: !0,
                                configurable: !0
                            }
                        }), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), e && m(t, e)
                    }(e, t), i = e, (r = [{
                        key: "autoLevelCapping",
                        get: function() {
                            return h(e, "autoLevelCapping", this, 1)
                        },
                        set: function(t) {
                            l(e, "autoLevelCapping", Infinity !== t && void 0 !== t ? v(T, this, S).call(this, t) : t, this, 1, 1)
                        }
                    }, {
                        key: "detectPlayerSize",
                        value: function() {
                            if (this.clientRect = null, h(e, "detectPlayerSize", this, 3)([]), this.hls && this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
                                var t = v(T, this, S).call(this, this.hls.autoLevelCapping);
                                t !== this.hls.autoLevelCapping && (this.hls.autoLevelCapping = t)
                            }
                        }
                    }]) && n(i.prototype, r), s && n(i, s), Object.defineProperty(i, "prototype", {
                        writable: !1
                    }), i;
                    var i, r, s
                }(y);

            function S(t) {
                if (!this.hls.levels || 0 === this.hls.levels.length) return t;
                var e = this.hls.config.qualityMin || 0,
                    i = this.hls.config.qualityMax || 5e3,
                    r = (0, s.findClosestAssetByQuality)(this.hls.levels, e),
                    n = this.hls.levels.indexOf(r),
                    a = (0, s.findClosestAssetByQuality)(this.hls.levels, i),
                    o = this.hls.levels.indexOf(a);
                return t > o ? o : t >= 0 && t < n ? n : t
            }
        },
        559: (t, e, i) => {
            i.d(e, {
                setup: () => u,
                teardown: () => h
            });
            var r = i(556),
                s = i(13),
                n = i(558),
                a = s.wlog.getPrefixedFunctions("hls_video"),
                o = (0, n.makeCacheable)("dynamic_max_max_buffer"),
                l = (0, n.makeNamespace)("dynamic_max_max_buffer"),
                u = function(t) {
                    var e = t.hls,
                        i = o(t, "onFragLoaded", (function() {
                            return function() {
                                c(t)
                            }
                        }));
                    e.off(r.default.Events.FRAG_LOADED, i), e.on(r.default.Events.FRAG_LOADED, i)
                },
                c = function(t) {
                    var e = t.hls;
                    t.attributes.maxMaxBufferLength && (e.config.maxMaxBufferLength = t.attributes.maxMaxBufferLength);
                    var i = e.levels[e.currentLevel];
                    i && e.abrController.bwEstimator.getEstimate() * e.config.abrBandWidthFactor < i.attrs.BANDWIDTH && (e.manualLevel >= 0 || 0 === e.currentLevel ? (a.info("set maxMaxBufferLength", t.getDuration()), e.config.maxMaxBufferLength = t.getDuration()) : (a.info("set maxMaxBufferLength", 60), e.config.maxMaxBufferLength = 60))
                },
                h = function(t) {
                    l(t).onFragLoaded && t.hls && t.hls.off(r.default.Events.FRAG_LOADED, l(t).onFragLoaded), (0, n.uncacheNamespace)("dynamic_max_max_buffer", t)
                }
        },
        560: (t, e, i) => {
            i.d(e, {
                setup: () => f,
                teardown: () => k
            });
            var r = i(556),
                s = i(67),
                n = i(6),
                a = i(13),
                o = i(90),
                l = i(558),
                u = (0, l.makeCacheable)("error_handling"),
                c = (0, l.makeNamespace)("error_handling"),
                h = a.wlog.getPrefixedFunctions("hls error_handling"),
                d = 0,
                f = function(t) {
                    var e = u(t, "onError", (function() {
                        return function(e, i) {
                            g(t, e, i)
                        }
                    }));
                    t.hls.on(r.default.Events.ERROR, e);
                    var i = u(t, "onEmergencyAbortLoad", (function() {
                        return function() {
                            y(t)
                        }
                    }));
                    t.hls.on(r.default.Events.FRAG_LOAD_EMERGENCY_ABORTED, i)
                },
                g = function(t, e, i) {
                    i.fatal ? m(t, e, i) : p(t, e, i), t.attributes.liveMedia && E(t, "live_stream/play/hls/errors")
                },
                m = function(t, e, i) {
                    var n, o, l = t.hls,
                        u = t.attributes;
                    if (d += 1, i.type === r.default.ErrorTypes.MEDIA_ERROR) a.wlog.info("hlsjsplugin - Fatal media error encountered, try to recover"), c(t).countedRecoverMediaError || (c(t).countedRecoverMediaError = !0, T(t, "player/hls/recover_media_error")), t.isChangingVideo() || i.details === r.default.ErrorDetails.BUFFER_STALLED_ERROR && l.startLoad(), h.error("trying to recover from media error..."), n = t.getCurrentTime(), 3 === d ? ((0, s.clearTimeouts)("".concat(t.uuid, ".nudge_if_not_playing")), l.destroy(), t.trigger("fatalerrorrebuild")) : (l.recoverMediaError(), o = null != u.bufferStallRecoveryTimeout ? u.bufferStallRecoveryTimeout : 1e3, (0, s.doTimeout)("".concat(t.uuid, ".nudge_if_not_playing"), (function() {
                        "playing" !== t.getPlaybackMode() ? (h.error("trying to nudge 0.5 seconds..."), t.seek(t.getCurrentTime() + .5).then((function() {
                            t.play()
                        }))) : t.getCurrentTime() !== n && h.error("video is playing; recoverMediaError() succeeded")
                    }), o));
                    else T(t, "player/playback-error"), t.attributes.liveMedia && E(t, "live_stream/player/hls/fatal", {
                        errorType: i.type,
                        errorDetails: i.details,
                        errorInfo: i
                    }), T(t, "player/hls/fatal", {
                        errorType: i.type,
                        errorDetails: i.details,
                        errorInfo: i
                    }), a.wlog.info("hlsjsplugin - Fatal error - cannot recover", e, i), l.destroy()
                },
                p = function(t, e, i) {
                    a.wlog.info("hlsjsplugin - Non fatal error encountered - ".concat(i.details), i), i.details === r.default.ErrorDetails.BUFFER_SEEK_OVER_HOLE ? E(t, "player/hls/buffer_seek_over_hole", {
                        hole: i.hole
                    }) : i.details === r.default.ErrorDetails.BUFFER_STALLED_ERROR ? t.getCurrentTime() > 0 && E(t, "player/hls/buffer_stalled") : i.details === r.default.ErrorDetails.INTERNAL_EXCEPTION ? E(t, "player/hls/non-fatal/".concat(i.details), {
                        errorDetails: i
                    }) : E(t, "player/hls/non-fatal/".concat(i.details))
                },
                v = [100, 500, 1500, 3e3, 6e3],
                y = function(t) {
                    for (var e = function() {
                            var e = t.hls;
                            e && e.startLoad()
                        }, i = 0; i < v.length; i++) {
                        var r = v[i];
                        (0, s.doTimeout)("".concat(t.uuid, ".hls.start_load_on_stall_").concat(r), e, r)
                    }
                },
                T = function(t, e, i) {
                    i = L(t, (0, n.merge)({
                        at: t.getCurrentTime()
                    }, i)), o.count(e, 1, i), b(t, e)
                },
                E = function(t, e, i) {
                    S(t, e) || T(t, e, i)
                },
                S = function(t, e) {
                    return A(t), !0 === c(t).metricsCounted[e]
                },
                b = function(t, e) {
                    A(t), c(t).metricsCounted[e] = !0
                },
                A = function(t) {
                    null == c(t).metricsCounted && (c(t).metricsCounted = {})
                },
                L = function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        i = {
                            hlsVideo: t.diagnosticData()
                        };
                    return i.locationHref = location.href, top !== self && (i.referrer = document.referrer, i.inIframe = !0), (0, n.merge)(i, e)
                },
                k = function(t) {
                    c(t).onError && t.hls && t.hls.off(r.default.Events.ERROR, c(t).onError), c(t).onEmergencyAbortLoad && t.hls && t.hls.off(r.default.Events.ERROR, c(t).onEmergencyAbortLoad), (0, l.uncacheNamespace)("error_handling", t)
                }
        },
        222: (t, e, i) => {
            i.d(e, {
                allHlsAudioAssets: () => o,
                allMp4VideoAssets: () => l,
                audioTracksForVideo: () => u,
                buildMasterM3u8Asset: () => c,
                multivariantM3u8Url: () => a,
                rejectAudioAsset: () => h
            });
            var r = i(30),
                s = i(6),
                n = i(21),
                a = function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if (t.attributes.liveMedia) return t.mediaData.liveStreamEventDetails.manifestUrl;
                    var i = t.attributes,
                        r = i.authorization,
                        s = i.clipForPoster,
                        a = i.clipTo,
                        o = i.clipFrom,
                        l = i.password,
                        u = i.startPosition,
                        c = i.deliveryCdn,
                        h = i.qualityMax,
                        d = i.qualityMin,
                        f = (i.includeExtendedAudioDescription, i.forceInstantHls),
                        g = e.qualityMin || d,
                        m = e.qualityMax || h,
                        p = function(t) {
                            var e, i = t.mediaData,
                                r = t.attributes,
                                s = "".concat((0, n.eV1Protocol)(), "//").concat((0, n.cdnFastWistiaComHost)(r.embedHost)),
                                a = "".concat((0, n.eV1Protocol)(), "//").concat((0, n.cdnFastProtectedWistiaComHost)(r.assetHost));
                            return i.protected && null !== (e = r.authorization) && void 0 !== e && e.jwt ? new URL("".concat(a, "/embed/accounts/").concat(i.accountId, "/medias/").concat(i.hashedId, ".m3u8")) : new URL("".concat(s, "/embed/medias/").concat(i.hashedId, ".m3u8"))
                        }(t);
                    return "HlsVideo" !== (null == t ? void 0 : t.name) && (g && p.searchParams.set("quality_min", g), m && p.searchParams.set("quality_max", m)), c && p.searchParams.set("delivery_cdn", c), u && -1 !== u && p.searchParams.set("start_position", u), s && null != o && a && (p.searchParams.set("clip_to", a), p.searchParams.set("clip_from", o)), f && p.searchParams.set("force_instant_hls", !0), null != r && r.jwt && p.searchParams.set("pma", r.jwt), l && p.searchParams.set("password", l), p.toString()
                },
                o = function(t) {
                    return (0, r.filter)(t, {
                        type: "mp4_alternate_audio",
                        status: r.READY
                    })
                },
                l = function(t) {
                    return (0, r.filter)(t, {
                        container: "mp4",
                        status: r.READY,
                        public: !0,
                        metadata: function(t) {
                            return Object(t).max_bitrate
                        },
                        type: /\b(?!captioned_video)\S+/
                    }).sort((function(t, e) {
                        return (t.metadata.max_bitrate || 0) - (e.metadata.max_bitrate || 0)
                    }))
                },
                u = function(t) {
                    var e = [{
                        audioCodec: void 0,
                        autoselect: !0,
                        default: !0,
                        forced: !1,
                        groupId: "audio",
                        id: 0,
                        lang: void 0,
                        name: "Off",
                        label: "Off",
                        type: "AUDIO",
                        isSelected: !0
                    }];
                    return t.forEach((function(t, i) {
                        var r, s;
                        e.push({
                            audioCodec: void 0,
                            autoselect: !1,
                            default: !1,
                            forced: !1,
                            groupId: "audio",
                            id: i + 1,
                            lang: void 0,
                            name: (null === (r = t.details) || void 0 === r ? void 0 : r.languageMetadata.name) || "Alt Audio",
                            label: (null === (s = t.details) || void 0 === s ? void 0 : s.languageMetadata.name) || "Alt Audio",
                            type: "AUDIO",
                            isSelected: !1
                        })
                    })), e
                },
                c = function(t) {
                    return {
                        bitrate: "variable",
                        ext: "m3u8",
                        height: "variable",
                        public: !0,
                        size: "variable",
                        type: "hls_video",
                        url: t,
                        width: "variable",
                        slug: "hls_master_m3u8_seg3s"
                    }
                },
                h = function(t, e) {
                    return (0, s.filter)(e, (function(t) {
                        return "Audio" != t.display_name
                    }))
                }
        },
        581: (t, e, i) => {
            i.d(e, {
                assetToLevel: () => c,
                bestStartingLevel: () => f,
                deliveryUrlToLevel: () => h,
                filteredHlsAssets: () => g,
                levelToAsset: () => m,
                startLoadOnce: () => p,
                stopLoad: () => y,
                teardown: () => T
            });
            var r = i(30),
                s = i(6),
                n = i(558),
                a = i(222),
                o = (0, n.makeNamespace)("asset_to_level"),
                l = (0, n.makeNamespace)("level_to_asset"),
                u = function(t) {
                    if (t) {
                        var e = t.match(/deliveries\/(.*?)(?=\.)/);
                        return e && e[1] ? e[1] : void 0
                    }
                },
                c = function(t, e) {
                    return h(t, e.url)
                },
                h = function(t, e) {
                    var i, r = u(e);
                    if (null != (i = o(t)[r])) return i;
                    if (!t.hls || !t.hls.levels) return -1;
                    var n = (0, s.filter)(t.hls.levels, (function(t) {
                            return u(t.url[0]) === r
                        }))[0],
                        a = t.hls.levels.indexOf(n);
                    return n && (o(t)[r] = a), a
                },
                d = function(t) {
                    if (t.attrs.BANDWIDTH) return Number(t.attrs.BANDWIDTH)
                },
                f = function(t) {
                    return v(t) ? v(t) : -1 !== t.hls.autoLevelCapping ? t.hls.autoLevelCapping : t.hls.levels.length - 1
                },
                g = function(t, e) {
                    var i = e,
                        s = t.attributes,
                        n = s.qualityMin,
                        o = s.qualityMax;
                    n > 0 && (i = a.rejectAudioAsset(t, i));
                    var l = (0, r.withinQualityRange)(i, n, o);
                    return i = l.length > 0 ? l : (0, r.nearestOutsideRange)(i, n, o)
                },
                m = function(t, e) {
                    var i;
                    if (null != (i = l(t)[e])) return i;
                    var r = (0, s.getDeep)(t.hls.levels, [e, "url", 0]),
                        n = u(r),
                        a = (0, s.filter)(t.allAssets, (function(t) {
                            if (t.url) {
                                var e = u(t.url);
                                return n === e
                            }
                        }))[0];
                    return l(t)[e] = a, a
                },
                p = function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
                    t.attributes.calledStartLoad || (t.onReady().then((function() {
                        t.hls.startLoad(e)
                    })), t.setAttributes({
                        calledStartLoad: !0
                    }))
                },
                v = function(t) {
                    var e = t.attributes,
                        i = e.qualityMin,
                        s = void 0 === i ? 100 : i,
                        n = e.qualityMax,
                        a = void 0 === n ? 1e4 : n,
                        o = e.bwEstimateOnInit;
                    if (o && t.hls.levels) {
                        for (var l, u, c = t.hls.autoLevelCapping || t.hls.levels.length - 1, h = 0; h <= c; h++) {
                            var f = t.hls.levels[h],
                                g = (u = f).attrs.AVERAGE_BANDWIDTH ? Number(u.attrs.AVERAGE_BANDWIDTH) : d(u),
                                m = (0, r.numericSizeSnapped)(f.width, f.height);
                            s <= m && m <= a && g < 99999999999 && g < o * t.abrBandWidthUpFactor() && (l = h)
                        }
                        return l
                    }
                },
                y = function(t) {
                    t.hls.stopLoad(), t.setAttributes({
                        calledStartLoad: !1
                    })
                },
                T = function(t) {
                    (0, n.uncacheNamespace)("level_to_asset", t), (0, n.uncacheNamespace)("asset_to_level", t)
                }
        },
        555: (t, e, i) => {
            i.d(e, {
                default: () => I
            });
            var r = i(556),
                s = i(30),
                n = i(6),
                a = i(13),
                o = i(24),
                l = i(91),
                u = i(90),
                c = i(557),
                h = i(559),
                d = i(560),
                f = i(222),
                g = i(561),
                m = i(562),
                p = i(579),
                v = i(570),
                y = i(25),
                T = i(581),
                E = i(582),
                S = i(583);

            function b(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var r = e[i];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, A(r.key), r)
                }
            }

            function A(t) {
                var e = function(t, e) {
                    if ("object" != typeof t || !t) return t;
                    var i = t[Symbol.toPrimitive];
                    if (void 0 !== i) {
                        var r = i.call(t, e || "default");
                        if ("object" != typeof r) return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === e ? String : Number)(t)
                }(t, "string");
                return "symbol" == typeof e ? e : e + ""
            }

            function L(t, e, i) {
                (function(t, e) {
                    if (e.has(t)) throw new TypeError("Cannot initialize the same private elements twice on an object")
                })(t, e), e.set(t, i)
            }

            function k(t, e) {
                return t.get(R(t, e))
            }

            function R(t, e, i) {
                if ("function" == typeof t ? t === e : t.has(e)) return arguments.length < 3 ? e : i;
                throw new TypeError("Private element is not present on this object")
            }
            var w = m.default.delegatePublicMethods,
                _ = a.wlog.getPrefixedFunctions("hls_video"),
                D = new WeakMap,
                C = function() {
                    return t = function t(e, i, r, s) {
                        var a, l, c, h = this;
                        ! function(t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), L(this, D, void 0), a = this, c = function() {
                            var t, e;
                            if (h._liveStreamStartPromise) return h._liveStreamStartPromise;
                            if (null !== (t = h.mediaData.liveStreamEventDetails) && void 0 !== t && t.startedAt && null !== (e = h.mediaData.liveStreamEventDetails) && void 0 !== e && e.m3u8RenditionProgramTime) return h._liveStreamStartPromise = Promise.resolve(), h._liveStreamStartPromise;
                            var i = h.attributes,
                                r = i.hashedId,
                                s = i.embedHost,
                                n = {
                                    hashed_id: r
                                };
                            return h._liveStreamStartPromise = new Promise((function(t) {
                                var e = function(i) {
                                    var a = performance.now();
                                    (0, y.fetchFreshMediaDataJson)(r, {
                                        embedHost: s
                                    }).then((function(r) {
                                        var s, o;
                                        null !== (s = r.media.liveStreamEventDetails) && void 0 !== s && s.startedAt && null !== (o = r.media.liveStreamEventDetails) && void 0 !== o && o.m3u8RenditionProgramTime ? (h.onMediaDataChanged(r.media), t()) : (i % 60 == 0 && ((0, u.count)("live_stream/polling/count", Math.max(i, 1), n), (0, u.sample)("live_stream/polling/latency", performance.now() - a, n), i = 0), setTimeout((function() {
                                            e(i + 1)
                                        }), 1e3))
                                    }))
                                };
                                e(0)
                            })).catch((function(t) {
                                (0, u.count)("live_stream/polling/errors", 1, n)
                            })), h._liveStreamStartPromise
                        }, (l = A(l = "pollForLiveStream")) in a ? Object.defineProperty(a, l, {
                            value: c,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : a[l] = c, this.uuid = (0, o.seqId)("wistia_hls_video_"), this.root = e, this.name = "HlsVideo", this.mediaData = i, this.allAssets = this.mediaData.assets, this.attributes = (0, n.assign)(this.defaultAttributes(), r || {}), this._startPosition = this.attributes.startPosition || -1, this.state = {}, this.simpleVideo = new m.default(this.root, this.mediaData, this.attributes, s), this.setupHls()
                    }, e = [{
                        key: "abrBandWidthFactor",
                        value: function() {
                            return 1.1
                        }
                    }, {
                        key: "abrBandWidthUpFactor",
                        value: function() {
                            return 1.4
                        }
                    }, {
                        key: "adaptiveAsset",
                        value: function() {
                            var t = f.multivariantM3u8Url(this),
                                e = f.buildMasterM3u8Asset(t);
                            return e.display_name = "Auto", e.slug = "Auto", e
                        }
                    }, {
                        key: "addTextTracks",
                        value: function() {}
                    }, {
                        key: "assetFromQuality",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t,
                                i = (0, s.withinQualityRange)(this.allAssets, t, e);
                            return 0 === i.length && (i = (0, s.nearestOutsideRange)(this.allAssets, t, e)), i[0]
                        }
                    }, {
                        key: "changeAudioTrack",
                        value: function(t) {
                            var e = this;
                            return new Promise((function(i) {
                                var s = "beforeplay" === e.getPlaybackMode(),
                                    n = e.getCurrentAudioTrack().id;
                                s || n === t || e.hls.once(r.default.Events.AUDIO_TRACK_SWITCHED, (function() {
                                    i()
                                })), e.hls.audioTracks[t] && n !== t ? (e.hls.audioTrack = t, "beforeplay" === e.getPlaybackMode() && i()) : i()
                            }))
                        }
                    }, {
                        key: "changeLevel",
                        value: function(t) {
                            var e = this;
                            this.hls.currentLevel !== t && this.hls.startLevel !== t && (this.hls.startLevel = t), "playing" === this.getPlaybackMode() && -1 !== t && (this.hls.once(r.default.Events.LEVEL_SWITCHED, (function() {
                                e.play()
                            })), this.pause()), this.hls.currentLevel !== t && (this.hls.currentLevel = t)
                        }
                    }, {
                        key: "changeQuality",
                        value: function(t, e, i) {
                            if ("auto" === t.toString().toLowerCase()) return this.changeStream(-1, e, i);
                            var r = (0, s.findClosestAssetByQuality)(this.hls.levels, t),
                                n = (0, T.deliveryUrlToLevel)(this, r.url[0]);
                            return this.changeStream(n, e, i)
                        }
                    }, {
                        key: "changeStream",
                        value: function(t) {
                            var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                            return this.changeLevel(t), e ? this.play() : Promise.resolve()
                        }
                    }, {
                        key: "changeStreamWithoutLoad",
                        value: function(t) {
                            if ((0, T.assetToLevel)(this, t) !== this.hls.currentLevel) {
                                var e = (0, T.assetToLevel)(this, t);
                                this.stopLoad(), this.changeLevel(e)
                            }
                        }
                    }, {
                        key: "changeVideo",
                        value: function(t, e) {
                            var i = this;
                            return new Promise((function(r) {
                                i.mediaData = null, i.allAssets = [], i.attributes = {}, i.state = {}, i.state.isChangingVideo = !0, i._bindings = {}, i.destroyHls(), (0, v.teardownBeforeChangeVideo)(i.simpleVideo), i.mediaData = t, i.allAssets = t.assets, i.attributes = e, (0, v.initAfterChangeVideo)(i.simpleVideo, t, e), i.setAttributes({
                                    bwEstimateOnInit: (0, l.setOrGet)("hls.bandwidth_estimate")
                                }), i.setupHls(), i.state.isChangingVideo = !1, r()
                            }))
                        }
                    }, {
                        key: "currentLevel",
                        value: function() {
                            return this.hls.currentLevel
                        }
                    }, {
                        key: "currentAsset",
                        value: function() {
                            return this.hls.currentLevel >= 0 ? (0, T.levelToAsset)(this, this.hls.currentLevel) || this.adaptiveAsset() : null != this.hls.startLevel && this.hls.startLevel >= 0 && (0, T.levelToAsset)(this, this.hls.startLevel) || this.adaptiveAsset()
                        }
                    }, {
                        key: "defaultAttributes",
                        value: function() {
                            return {
                                contentType: "video/m3u8",
                                qualityMin: 360,
                                qualityMax: 2160,
                                preload: "metadata"
                            }
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            return this._bindings = {}, this.destroyHls(), this.simpleVideo.destroy()
                        }
                    }, {
                        key: "destroyHls",
                        value: function() {
                            var t = this,
                                e = function(t) {
                                    try {
                                        return t()
                                    } catch (t) {
                                        _.error(t)
                                    }
                                };
                            e((function() {
                                d.teardown(t)
                            })), e((function() {
                                c.teardown(t)
                            })), e((function() {
                                h.teardown(t)
                            })), e((function() {
                                g.teardown(t)
                            })), e((function() {
                                (0, T.teardown)(t)
                            })), this.hls && (this.hls.destroy(), this.hls = null)
                        }
                    }, {
                        key: "determineMinAutoBitrate",
                        value: function() {
                            var t = this.hlsAssetFromQuality(360, 1080);
                            return t && t.metadata && t.metadata.max_bitrate ? t.metadata.max_bitrate - 1 : 6e5
                        }
                    }, {
                        key: "diagnosticData",
                        value: function() {
                            var t = this,
                                e = function(t) {
                                    try {
                                        return t()
                                    } catch (t) {
                                        return "ERROR: ".concat(t.message)
                                    }
                                },
                                i = {
                                    simpleVideo: this.simpleVideo.diagnosticData(),
                                    attributes: this.attributes,
                                    currentLevel: e((function() {
                                        return t.currentLevel()
                                    })),
                                    startLevel: e((function() {
                                        return t.hls.startLevel
                                    })),
                                    nextLevel: e((function() {
                                        return t.hls.nextLevel
                                    })),
                                    loadLevel: e((function() {
                                        return t.hls.loadLevel
                                    })),
                                    autoLevel: e((function() {
                                        return t.hls.autoLevel
                                    })),
                                    autoLevelCapping: e((function() {
                                        return t.hls.autoLevelCapping
                                    })),
                                    nextAutoLevel: e((function() {
                                        return t.hls.nextAutoLevel
                                    })),
                                    manualLevel: e((function() {
                                        return t.hls.manualLevel
                                    })),
                                    bandwidthEstimate: e((function() {
                                        return t.hls.abrController.bwEstimator.getEstimate()
                                    }))
                                };
                            return this.hls.currentLevel && (i.currentAsset = (0, T.levelToAsset)(this, this.hls.currentLevel)), "auto" !== this.selectedQuality() && this.hls.manualLevel > -1 && (i.selectedAsset = (0, T.levelToAsset)(this, this.hls.manualLevel)), i
                        }
                    }, {
                        key: "filteredVideoAssets",
                        value: function() {
                            var t = f.allMp4VideoAssets(this.allAssets);
                            return (0, T.filteredHlsAssets)(this, t)
                        }
                    }, {
                        key: "getAudioTracks",
                        value: function() {
                            var t, e = this,
                                i = this.m3u8AudioAssets();
                            return (null === (t = this.hls) || void 0 === t ? void 0 : t.audioTracks.length) > 0 ? this.hls.audioTracks.map((function(t, r) {
                                var s = i[r - 1];
                                return t.isSelected = r === e.getHlsAudioTrackId(), t.label = null == s ? void 0 : s.details.languageMetadata.nativeName, 0 === r && (t.label = "Original"), t
                            })) : f.audioTracksForVideo(i)
                        }
                    }, {
                        key: "getCurrentAudioTrack",
                        value: function() {
                            this.loadForAudioTracks();
                            var t = this.getHlsAudioTrackId(),
                                e = this.hls.audioTracks[t];
                            return e.isSelected = !0, e
                        }
                    }, {
                        key: "getCurrentAudioTrackId",
                        value: function() {
                            return this.getCurrentAudioTrack().id
                        }
                    }, {
                        key: "getCurrentQuality",
                        value: function() {
                            var t = this.hls.currentLevel >= 0 ? this.hls.currentLevel : this.hls.startLevel,
                                e = this.hls.levels[t];
                            return e ? e ? (0, s.numericSizeSnapped)(e.width, e.height) : "?" : "auto"
                        }
                    }, {
                        key: "getCurrentTime",
                        value: function() {
                            var t;
                            if (!this.attributes.liveMedia || !k(D, this) || null === (t = this.mediaData.liveStreamEventDetails) || void 0 === t || !t.m3u8RenditionProgramTime) return this.simpleVideo.getCurrentTime();
                            var e = new Date(this.mediaData.liveStreamEventDetails.m3u8RenditionProgramTime).getTime();
                            return (k(D, this) - e) / 1e3 + this.simpleVideo.getCurrentTime()
                        }
                    }, {
                        key: "getHlsAudioTrackId",
                        value: function() {
                            return -1 === this.hls.audioTrack ? 0 : this.hls.audioTrack
                        }
                    }, {
                        key: "getMaxMaxBufferLengthForConfig",
                        value: function() {
                            switch (this.attributes.preload) {
                                case "auto":
                                case !0:
                                    return 27;
                                case "metadata":
                                    return 1;
                                default:
                                    return this.getMaxMaxBufferLengthAfterPlay()
                            }
                        }
                    }, {
                        key: "getMaxMaxBufferLengthAfterPlay",
                        value: function() {
                            return this.usingInstantHls() ? 12 : 60
                        }
                    }, {
                        key: "hlsAssetFromQuality",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t,
                                i = (0, s.withinQualityRange)(this.filteredVideoAssets(), t, e);
                            return 0 === i.length && (i = (0, s.nearestOutsideRange)(this.filteredVideoAssets(), t, e)), i[0]
                        }
                    }, {
                        key: "isChangingVideo",
                        value: function() {
                            return !!this.state.isChangingVideo
                        }
                    }, {
                        key: "loadForAudioTracks",
                        value: function() {
                            0 === this.hls.audioTracks.length && this.startHlsLoadOnce()
                        }
                    }, {
                        key: "liveConfig",
                        value: function() {
                            return {
                                abrBandWidthFactor: 1.1,
                                abrBandWidthUpFactor: 1.4,
                                abrEwmaDefaultEstimate: this.attributes.bwEstimateOnInit,
                                testBandwidth: !1,
                                autoStartLoad: !1,
                                debug: {
                                    log: function() {
                                        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                                        a.wlog.info.apply(a.wlog, ["hlsjs log >"].concat(e))
                                    },
                                    error: function() {
                                        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                                        a.wlog.notice.apply(a.wlog, ["hlsjs error >"].concat(e))
                                    },
                                    warn: function() {
                                        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                                        a.wlog.notice.apply(a.wlog, ["hlsjs warn >"].concat(e))
                                    },
                                    info: function() {
                                        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                                        a.wlog.info.apply(a.wlog, ["hlsjs info >"].concat(e))
                                    },
                                    debug: function() {
                                        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                                        a.wlog.debug.apply(a.wlog, ["hlsjs debug >"].concat(e))
                                    }
                                },
                                maxBufferSize: 6e7,
                                maxFragLookUpTolerance: .2,
                                maxMaxBufferLength: this.attributes.maxMaxBufferLength || this.getMaxMaxBufferLengthAfterPlay(),
                                seekHoleNudgeDuration: .1
                            }
                        }
                    }, {
                        key: "loadSource",
                        value: function() {
                            var t = this.adaptiveAsset();
                            this.hls.loadSource(t.url)
                        }
                    }, {
                        key: "m3u8AudioAssets",
                        value: function() {
                            return f.allHlsAudioAssets(this.allAssets)
                        }
                    }, {
                        key: "onEnterFullscreen",
                        value: function() {
                            this.simpleVideo.onEnterFullscreen(), "beforeplay" !== this.getPlaybackMode() && this.changeLevel(-1)
                        }
                    }, {
                        key: "onHeightChange",
                        value: function(t) {
                            this.simpleVideo.onHeightChange(t), this.setAttributes({
                                height: t
                            })
                        }
                    }, {
                        key: "onMediaDataChanged",
                        value: function(t) {
                            this.mediaData = t
                        }
                    }, {
                        key: "onReady",
                        value: function() {
                            var t = this;
                            return this.readyPromise || (this.readyPromise = this.simpleVideo.onReady().then((function() {
                                return Promise.all([t.mediaAttachedPromise, t.manifestParsedPromise])
                            }))), this.readyPromise
                        }
                    }, {
                        key: "onWidthChange",
                        value: function(t) {
                            this.simpleVideo.onWidthChange(t), this.setAttributes({
                                width: t
                            })
                        }
                    }, {
                        key: "play",
                        value: function(t) {
                            var e = this;
                            return this.hls.config.autoStartLoad || this.startHlsLoadOnce(), this.hls.config.maxMaxBufferLength = this.getMaxMaxBufferLengthAfterPlay(), this.attributes.liveMedia ? ((0, u.count)("live_stream/play", 1, {
                                hashed_id: this.attributes.hashedId
                            }), this.setCurrentTimeToLiveEdge().then((function() {
                                return e.simpleVideo.play(t).then((function(t) {
                                    return (0, u.count)("live_stream/play/success", 1, {
                                        hashed_id: e.attributes.hashedId
                                    }), t
                                }))
                            }))) : this.simpleVideo.play(t)
                        }
                    }, {
                        key: "qualityForLevel",
                        value: function(t) {
                            if (-1 === t) return "auto";
                            var e = this.hls.levels[t];
                            return (0, s.numericSizeSnapped)(e.width, e.height)
                        }
                    }, {
                        key: "qualityMax",
                        value: function(t) {
                            this.hls.config && (this.hls.config.qualityMax = t)
                        }
                    }, {
                        key: "qualityMin",
                        value: function(t) {
                            this.hls.config && (this.hls.config.qualityMin = t)
                        }
                    }, {
                        key: "removeSourceElem",
                        value: function() {
                            var t = this.getMediaElement(),
                                e = Array.prototype.slice.call(t.childNodes);
                            e.length > 0 && e.forEach((function(e) {
                                t.removeChild(e)
                            }))
                        }
                    }, {
                        key: "removeTextTracks",
                        value: function() {}
                    }, {
                        key: "reset",
                        value: function() {
                            this.simpleVideo.reset()
                        }
                    }, {
                        key: "seek",
                        value: function(t, e) {
                            return this.startHlsLoadOnce(t), this.simpleVideo.seek(t, e)
                        }
                    }, {
                        key: "selectableQualities",
                        value: function() {
                            var t = this,
                                e = this.hls.levels.map((function(e, i) {
                                    return t.qualityForLevel(i)
                                }));
                            return [this.qualityForLevel(-1)].concat(e)
                        }
                    }, {
                        key: "selectedQuality",
                        value: function() {
                            return this.hls.manualLevel >= 0 ? this.qualityForLevel(this.hls.manualLevel) : "auto"
                        }
                    }, {
                        key: "setAttributes",
                        value: function(t) {
                            return (0, n.assign)(this.attributes, t), this.simpleVideo.setAttributes(t)
                        }
                    }, {
                        key: "setCurrentTimeToLiveEdge",
                        value: function() {
                            return "beforeplay" !== this.getPlaybackMode() ? this.seek(this.hls.liveSyncPosition) : Promise.resolve()
                        }
                    }, {
                        key: "setupEventListeners",
                        value: function() {
                            var t = this;
                            this.manifestParsedPromise = new Promise((function(e) {
                                t.hls.on(r.default.Events.MANIFEST_PARSED, e)
                            })), this.mediaAttachedPromise = new Promise((function(e) {
                                t.hls.on(r.default.Events.MEDIA_ATTACHED, e)
                            })), this.hls.on(r.default.Events.AUDIO_TRACKS_UPDATED, (function() {
                                t.trigger("audiotracksupdated")
                            })), this.hls.on(r.default.Events.LEVEL_SWITCHED, (function(e, i) {
                                var r = (0, T.levelToAsset)(t, i.level);
                                t.trigger("hlslevelswitched", {
                                    asset: r
                                })
                            })), this.hls.once(r.default.Events.LEVEL_LOADED, (function(e, i) {
                                var r, s, n, a, o, l;
                                a = D, o = t, l = null === (r = i.details) || void 0 === r || null === (s = r.fragments) || void 0 === s || null === (n = s[0]) || void 0 === n ? void 0 : n.programDateTime, a.set(R(a, o), l)
                            }))
                        }
                    }, {
                        key: "setupHls",
                        value: function() {
                            this.attributes.liveMedia ? this.setupLiveHls() : this.setupVodHls()
                        }
                    }, {
                        key: "setupLiveHls",
                        value: function() {
                            var t = this,
                                e = this.liveConfig();
                            this.hls = new r.default(e), g.setup(this), this.setupEventListeners(), this.hls.attachMedia(this.simpleVideo.getMediaElement()), this.removeSourceElem(), c.setup(this), d.setup(this), this.pollForLiveStream().then((function() {
                                t.loadSource(), t.onReady().then((function() {
                                    t.trigger("livestreamready")
                                }))
                            }))
                        }
                    }, {
                        key: "setupVodHls",
                        value: function() {
                            var t = this,
                                e = this.vodConfig();
                            this.hls = new r.default(e), g.setup(this), this.loadSource(), this.setupEventListeners(), this.hls.attachMedia(this.simpleVideo.getMediaElement()), this.removeSourceElem(), h.setup(this), d.setup(this), c.setup(this), this.hls.once(r.default.Events.MANIFEST_PARSED, (function() {
                                t.hls.startLevel = (0, T.bestStartingLevel)(t)
                            }))
                        }
                    }, {
                        key: "selectedAsset",
                        value: function() {
                            if (0 !== this.hls.levels.length) return this.hls.currentLevel ? this.hls.levels[this.hls.currentLevel] : this.hls.levels[this.hls.startLevel]
                        }
                    }, {
                        key: "showFirstFrame",
                        value: function() {
                            return this.seek(.01)
                        }
                    }, {
                        key: "startHlsLoadOnce",
                        value: function(t) {
                            var e = t || this._startPosition;
                            (0, T.startLoadOnce)(this, e)
                        }
                    }, {
                        key: "stopLoad",
                        value: function() {
                            (0, T.stopLoad)(this)
                        }
                    }, {
                        key: "updateStartPosition",
                        value: function(t) {
                            this.hls.config.startPosition !== t && (this.attributes.startPosition = t, this._startPosition = t, this.hls.config.startPosition = t, this.hls && this.loadSource())
                        }
                    }, {
                        key: "usingInstantHls",
                        value: function() {
                            return (this.attributes.forceInstantHls || !this.mediaData.playableWithoutInstantHls) && this.mediaData.instantHlsAssetsReady
                        }
                    }, {
                        key: "vodConfig",
                        value: function() {
                            return {
                                abrBandWidthFactor: 1.1,
                                abrBandWidthUpFactor: 1.4,
                                abrController: E.default,
                                abrEwmaFastVoD: 4,
                                abrEwmaSlowVoD: 15,
                                autoStartLoad: "none" !== this.attributes.preload && !1 !== this.attributes.preload,
                                capLevelToPlayerSize: !0,
                                capLevelController: S.default,
                                debug: {
                                    log: function() {
                                        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                                        a.wlog.info.apply(a.wlog, ["hlsjs log >"].concat(e))
                                    },
                                    error: function() {
                                        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                                        a.wlog.notice.apply(a.wlog, ["hlsjs error >"].concat(e))
                                    },
                                    warn: function() {
                                        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                                        a.wlog.notice.apply(a.wlog, ["hlsjs warn >"].concat(e))
                                    },
                                    info: function() {
                                        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                                        a.wlog.info.apply(a.wlog, ["hlsjs info >"].concat(e))
                                    },
                                    debug: function() {
                                        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                                        a.wlog.debug.apply(a.wlog, ["hlsjs debug >"].concat(e))
                                    }
                                },
                                fragLoadPolicy: {
                                    default: {
                                        maxTimeToFirstByteMs: this.usingInstantHls() ? 3e4 : 1e4,
                                        maxLoadTimeMs: 12e4,
                                        timeoutRetry: {
                                            maxNumRetry: this.usingInstantHls() ? 2 : 4,
                                            retryDelayMs: 0,
                                            maxRetryDelayMs: 0
                                        },
                                        errorRetry: {
                                            maxNumRetry: this.usingInstantHls() ? 2 : 6,
                                            retryDelayMs: 1e3,
                                            maxRetryDelayMs: 8e3
                                        }
                                    }
                                },
                                maxBufferSize: 6e7,
                                maxFragLookUpTolerance: .2,
                                maxMaxBufferLength: this.getMaxMaxBufferLengthForConfig(),
                                minAutoBitrate: this.determineMinAutoBitrate(),
                                seekHoleNudgeDuration: .1,
                                startPosition: this._startPosition,
                                qualityMin: this.attributes.qualityMin || 360,
                                qualityMax: this.attributes.qualityMax || 2160
                            }
                        }
                    }], e && b(t.prototype, e), i && b(t, i), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t;
                    var t, e, i
                }();
            w(C.prototype, (function() {
                return this.simpleVideo
            })), (0, p.default)("HlsVideo", C);
            const I = C
        },
        561: (t, e, i) => {
            i.d(e, {
                setup: () => u,
                teardown: () => c
            });
            var r = i(556),
                s = i(13),
                n = i(558),
                a = s.wlog.getPrefixedFunctions("hls_video"),
                o = (0, n.makeCacheable)("track_stream_changes"),
                l = (0, n.makeNamespace)("track_stream_changes"),
                u = function(t) {
                    var e = t.hls;
                    l(t).lastLevel = null, l(t).lastAutoLevel = null, l(t).substreamIndex = 0;
                    var i = o(t, "onFragChanged", (function() {
                        return function(e, i) {
                            if (i.frag.level !== t._lastLevel || i.frag.autoLevel != t._lastAutoLevel) {
                                var r = t.hls.levels[i.frag.level];
                                l(t).lastLevel = i.frag.level, l(t).lastAutoLevel = i.frag.autoLevel, l(t).substreamIndex += 1, i.frag.level >= 0 ? a.notice("frag switch to", r, "at", t.getCurrentTime()) : a.notice("frag switch to Auto at", t.getCurrentTime())
                            }
                        }
                    }));
                    e.off(r.default.Events.FRAG_CHANGED, i), e.on(r.default.Events.FRAG_CHANGED, i);
                    var s = o(t, "onAudioSwitching", (function() {
                        return function(e, i) {
                            t.trigger("audiostreamchange"), i.id > 0 ? a.notice("audio asset switch to track: ", i.id, "at", t.lastBufferedTime()) : a.notice("level switch to original encoded audio at", t.lastBufferedTime())
                        }
                    }));
                    e.off(r.default.Events.AUDIO_TRACK_SWITCHING, s), e.on(r.default.Events.AUDIO_TRACK_SWITCHING, s);
                    var n = o(t, "onLevelSwitching", (function() {
                        return function(e, i) {
                            if (i.level >= 0) {
                                var r = t.hls.levels[i.level];
                                a.notice("level switch to", r, "at", t.lastBufferedTime())
                            } else a.notice("level switch to Auto at", t.lastBufferedTime())
                        }
                    }));
                    e.off(r.default.Events.LEVEL_SWITCHING, n), e.on(r.default.Events.LEVEL_SWITCHING, n)
                },
                c = function(t) {
                    l(t).onFragChanged && t.hls && t.hls.off(r.default.Events.FRAG_CHANGED, l(t).onFragChanged), l(t).onLevelSwitch && t.hls && t.hls.off(r.default.Events.LEVEL_SWITCHING, l(t).onLevelSwitching), (0, n.uncacheNamespace)("track_stream_changes", t)
                }
        },
        578: (t, e, i) => {
            i.d(e, {
                PUBLIC_METHODS: () => r,
                delegatePublicMethods: () => s
            });
            var r = ["activeBufferRange", "addTextTracks", "anyBuffered", "bind", "bindNamed", "bufferInfo", "canDownloadMedia", "cancelFullscreen", "captureCurrentFrame", "changeQuality", "changeStream", "changeStreamWithoutLoad", "changeVideo", "currentAsset", "defaultAsset", "destroy", "diagnosticData", "eventContext", "fit", "getAudioTracks", "getCurrentQuality", "getCurrentTime", "getCuts", "getDuration", "getDurationBeforeCuts", "getMediaElement", "getMediaType", "getPlaybackMode", "getPlaybackRate", "getPreload", "getState", "getTimeAfterCuts", "getTimeBeforeCuts", "getTrim", "getVolume", "hasIssuedPlay", "isChangingVideo", "isInitializingFromUnmuted", "isInFullscreen", "isMuted", "isSeeking", "isSourceOfBrowserEvent", "lastBufferedTime", "mute", "onEnterFullscreen", "onHeightChange", "onLeaveFullscreen", "onMediaDataChanged", "onPlayed", "onReady", "onWidthChange", "pause", "play", "playType", "removeTextTracks", "requestFullscreen", "reset", "seek", "seekOnPlay", "selectedAsset", "selectableAssets", "selectableQualities", "selectedQuality", "sequentialBufferedRange", "setAttributes", "setCurrentTime", "setPlaybackRate", "setCuts", "setTrim", "setVolume", "showFirstFrame", "stopStreaming", "timeBeforeEndOfBuffer", "totalBuffered", "totalPlayed", "trigger", "unbind", "unbindNamed", "unbindAllInNamespace", "unmute", "updateStartPosition"],
                s = function(t, e) {
                    ! function(t, e, i) {
                        for (var r = 0; r < t.length; r++) {
                            var s = t[r];
                            e[s] || function(t) {
                                e[t] = function() {
                                    var e = i.call(this);
                                    return e ? e[t].apply(e, arguments) : null
                                }
                            }(s)
                        }
                    }(r, t, e)
                }
        },
        564: (t, e, i) => {
            i.d(e, {
                activeBufferRange: () => o,
                anyBuffered: () => a,
                lastBufferedTime: () => c,
                sequentialBufferedRange: () => u,
                timeBeforeEndOfBuffer: () => h,
                totalBuffered: () => l
            });
            var r = i(13),
                s = i(563),
                n = r.wlog.getPrefixedFunctions("buffering"),
                a = function(t) {
                    var e = t.video;
                    return e.buffered.length > 0 && e.buffered.end(0) > 0
                },
                o = function(t) {
                    for (var e = t.video, i = e.currentTime, r = 0; r < e.buffered.length; r++) {
                        var s = e.buffered.start(r),
                            n = e.buffered.end(r);
                        if (s <= i && i < n) return [s, n]
                    }
                    return null
                },
                l = function(t) {
                    return s.sumTimeRanges(t.video.buffered)
                },
                u = function(t) {
                    var e = t.video,
                        i = e.buffered,
                        r = null;
                    try {
                        for (var s = 0; s < i.length; s++) {
                            var a = i.start(s) - .5,
                                o = i.end(s) + .5;
                            if (a <= e.currentTime && e.currentTime < o) {
                                r = s;
                                break
                            }
                        }
                        if (null != r) {
                            for (var l = r, u = r; u < i.length; u++) {
                                if (!(i.start(u) - .5 <= i.end(l) + .5)) break;
                                l = u
                            }
                            return [i.start(r), i.end(l)]
                        }
                        return null
                    } catch (t) {
                        return n.error(t), null
                    }
                },
                c = function(t, e) {
                    return function(t, e, i) {
                        var r = t.video;
                        if (r) {
                            var n, a = r.buffered,
                                o = [];
                            for (n = 0; n < a.length; n++) o.push({
                                start: a.start(n),
                                end: a.end(n)
                            });
                            return s.bufferedInfo(o, e, i)
                        }
                        return {
                            len: 0,
                            start: 0,
                            end: 0,
                            nextStart: void 0
                        }
                    }(t, t.getCurrentTime(), e).end
                },
                h = function(t, e) {
                    return c(t, e) - t.getCurrentTime()
                }
        },
        572: (t, e, i) => {
            i.d(e, {
                setup: () => a,
                teardown: () => o
            });
            var r = i(6),
                s = i(55),
                n = function(t) {
                    var e = t.attributes;
                    return (null != e.eventLoopDuration ? e.eventLoopDuration : 300) / t.getPlaybackRate()
                },
                a = function(t) {
                    null == t.state && (t.state = {}), "playing" === t.getPlaybackMode() && (t.state.hasPlayed = !0), t.bind("playing", (function() {
                        t.state.hasPlayed = !0
                    })), t.bind("waiting", (function() {
                        t.state.gotWaiting = !0
                    })), t.bind("loadedmetadata", (function() {
                        t.state.loadedMetadata = !0
                    })), (0, r.assign)(t.state, {
                        lastPlaybackMode: t.getPlaybackMode(),
                        lastTimePosition: t.getCurrentTime(),
                        lastEventLoopDuration: n(t)
                    });
                    var e = "".concat(t.uuid, ".custom_state_and_events");
                    s.globalEventLoop.add(e, n(t), (function() {
                        (0, r.assign)(t.state, {
                            lastTimePosition: t.getCurrentTime(),
                            lastPlaybackMode: t.getPlaybackMode(),
                            lastEventLoopDuration: n(t)
                        }), s.globalEventLoop.interval(e, n(t))
                    }))
                },
                o = function(t) {
                    var e = "".concat(t.uuid, ".custom_state_and_events");
                    s.globalEventLoop.remove(e)
                }
        },
        568: (t, e, i) => {
            i.d(e, {
                enforceCuts: () => d,
                getCurrentTimeAfterCuts: () => s.getCurrentTimeAfterCuts,
                getDurationAfterCuts: () => s.getDurationAfterCuts,
                getTrim: () => u,
                setCuts: () => c,
                setTrim: () => m,
                teardownCuts: () => f,
                trimStartFromCuts: () => o
            });
            var r = i(11),
                s = i(236),
                n = i(565),
                a = (0, r.cachedDetect)(),
                o = function(t) {
                    var e = (0, s.getCuts)(t);
                    return e.length < 1 || e[0].start > 0 ? 0 : e[0].end
                },
                l = function(t) {
                    var e = (0, s.getCuts)(t),
                        i = (0, s.getDurationBeforeCuts)(t);
                    return e.length < 1 || e[e.length - 1].end < i ? -1 : e[e.length - 1].start
                },
                u = function(t) {
                    return {
                        start: o(t),
                        end: l(t)
                    }
                },
                c = function(t, e) {
                    t.attributes.cuts = e, e !== t._rawCuts && (t._cuts = void 0, t._rawCuts = void 0), d(t)
                },
                h = function(t, e) {
                    return e || (e = {
                            current: null
                        }), e.current = requestAnimationFrame((function() {
                            !1 !== t() && h(t, e)
                        })),
                        function() {
                            cancelAnimationFrame(e.current)
                        }
                },
                d = function(t) {
                    if (!t._stopEnforcingCuts && 0 !== (0, s.getCuts)(t).length) {
                        var e = function() {
                                t._stopEnforcingCutsViaRafLoop && (t._stopEnforcingCutsViaRafLoop(), t._stopEnforcingCutsViaRafLoop = void 0)
                            },
                            i = [t.on("playing", (function() {
                                e(), t._stopEnforcingCutsViaRafLoop = h((function() {
                                    if (!t.state.seeking && !t.video.seeking) return g(t), !!t._stopEnforcingCutsViaRafLoop && void 0
                                }))
                            })), t.on("pause", e), t.on("ended", e), t.on("beforeplay", e), t.on("timeupdate", (function() {
                                g(t)
                            }))];
                        t._stopEnforcingCuts = function() {
                            e(), i.forEach((function(t) {
                                return t()
                            })), t._stopEnforcingCuts = void 0
                        }
                    }
                },
                f = function(t) {
                    t._stopEnforcingCuts && (t._stopEnforcingCuts(), t._stopEnforcingCuts = void 0)
                },
                g = function(t) {
                    if ("beforeplay" !== t.getPlaybackMode()) {
                        var e = t.video.currentTime,
                            i = (0, s.getCuts)(t),
                            r = -1,
                            o = i.filter((function(t, i) {
                                return t.start <= e && e < t.end && r < 0 && (r = i), t.start <= e && e < t.end
                            }))[0],
                            l = (0, s.getDurationBeforeCuts)(t);
                        if (t.state.fakeEnded && (0, s.getTimeAfterCuts)(t, e) < (0, s.getDurationAfterCuts)(t) - .1 && (t.state.fakeEnded = !1), o) {
                            var u = p(i, r);
                            if (u < l - .1) {
                                var c = a.ios.version > 0 ? .09 : 1e-6;
                                (0, n.seekWithoutCuts)(t, u + c)
                            } else t.state.fakeEnded || (t.state.fakeEnded = !0, t.attributes.loop ? (t.trigger("ended"), t.seek(0).then((function() {
                                return t.play()
                            }))) : (t.pause(), t.trigger("ended")))
                        }
                    }
                },
                m = function(t, e) {
                    var i = e.start,
                        r = e.end;
                    null != i && (i >= 0 ? t.attributes.trimStart = e.start : delete t.attributes.trimStart), null != r && (r >= 0 ? t.attributes.trimEnd = e.end : delete t.attributes.trimEnd), t._cuts = void 0, g(t), d(t)
                },
                p = function(t, e) {
                    if (e >= t.length) return -1;
                    for (var i = t[e].end, r = e; r < t.length; r += 1) {
                        var s = t[r];
                        if (s.start > i) break;
                        s.start === i && (i = s.end)
                    }
                    return i
                }
        },
        236: (t, e, i) => {
            function r(t) {
                return function(t) {
                    if (Array.isArray(t)) return s(t)
                }(t) || function(t) {
                    if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                }(t) || function(t, e) {
                    if (t) {
                        if ("string" == typeof t) return s(t, e);
                        var i = {}.toString.call(t).slice(8, -1);
                        return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? s(t, e) : void 0
                    }
                }(t) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function s(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for (var i = 0, r = Array(e); i < e; i++) r[i] = t[i];
                return r
            }
            i.d(e, {
                getCurrentTimeAfterCuts: () => u,
                getCuts: () => h,
                getDurationAfterCuts: () => a,
                getDurationBeforeCuts: () => n,
                getTimeAfterCuts: () => l,
                getTimeBeforeCuts: () => o
            });
            var n = function(t) {
                    var e = t.attributes;
                    return null != e.duration ? e.duration : t.video.readyState >= 2 ? t.video.duration : null
                },
                a = function(t) {
                    var e = h(t),
                        i = n(t);
                    if (e.length < 1) return i;
                    var r = i;
                    return e.forEach((function(t) {
                        r -= t.end - t.start
                    })), r
                },
                o = function(t, e) {
                    var i = n(t),
                        r = h(t),
                        s = 0,
                        a = 0,
                        o = 0;
                    return r.forEach((function(t) {
                        var i = t.start - a;
                        if ((o += i) <= e + s) {
                            var r = t.end - t.start;
                            s += r, o += r
                        }
                        a = t.end
                    })), Math.min(i, e + s)
                },
                l = function(t, e) {
                    var i = h(t);
                    if (i.length < 1) return e;
                    var r = e;
                    return i.forEach((function(t) {
                        t.start <= e && (r -= Math.min(e, t.end) - t.start)
                    })), Math.max(0, r)
                },
                u = function(t) {
                    return l(t, t.video.currentTime)
                },
                c = Object.freeze([]),
                h = function(t) {
                    var e = t.attributes,
                        i = e.cuts,
                        r = e.trimStart,
                        s = e.trimEnd;
                    if (t._cuts && i === t._rawCuts) return t._cuts;
                    if (!i && null == r && null == s) return c;
                    t._rawCuts = i, t._cuts = d(t);
                    var n = {
                        start: t.attributes.trimStart,
                        end: t.attributes.trimEnd
                    };
                    return t._cuts = f(t, n, t._cuts), Object.freeze(t._cuts), t._cuts
                },
                d = function(t) {
                    var e = n(t),
                        i = t.attributes,
                        r = i.cuts,
                        s = i.trimStart,
                        a = i.trimEnd;
                    if (!r) return [];
                    var o = r.map((function(i) {
                        var r = null != i.start ? g(t, i.start) : 0,
                            s = null != i.end && -1 !== i.end ? g(t, i.end) : e;
                        return s > r ? {
                            start: r,
                            end: s
                        } : null
                    })).filter(Boolean);
                    null != s && o.push({
                        start: 0,
                        end: s
                    }), null != a && o.push({
                        start: a,
                        end: e
                    }), o = o.sort((function(t, e) {
                        return t.start - e.start
                    }));
                    var l = {
                        start: 0,
                        end: 0
                    };
                    return o = o.map((function(t) {
                        return t.end < l.end ? null : (t.start < l.end && (t.start = l.end), l = t, t)
                    })).filter(Boolean)
                },
                f = function(t, e, i) {
                    var s = r(i),
                        a = n(t),
                        o = e.start,
                        l = e.end,
                        u = s[0],
                        c = s[s.length - 1],
                        h = u && (0 === u.start || u.start < 0) ? u : void 0,
                        d = c && (c.end >= a || c.end < 0) ? c : void 0;
                    if (null != o)
                        if (o >= 0) {
                            var f = {
                                start: 0,
                                end: o
                            };
                            h ? s.splice(0, 1, f) : s.unshift(f)
                        } else h && s.shift();
                    if (null != l)
                        if (l >= 0) {
                            var g = {
                                start: l,
                                end: a
                            };
                            d ? s.splice(s.length - 1, 1, g) : s.push(g)
                        } else d && s.pop();
                    return s
                },
                g = function(t, e) {
                    var i = n(t);
                    return Math.min(i, Math.max(0, e))
                }
        },
        577: (t, e, i) => {
            i.d(e, {
                getDiagnosticData: () => a
            });
            var r = i(237),
                s = i(21),
                n = function(t) {
                    try {
                        return t()
                    } catch (t) {
                        return "ERROR: ".concat(t.message)
                    }
                },
                a = function(t) {
                    var e = "" !== s.TAGGED_VERSION && s.TAGGED_VERSION.length > 0 ? s.TAGGED_VERSION : r.PLAYER_VERSION,
                        i = {};
                    return i.player_version = e, i.state = t.state, i.attributes = t.attributes, i.currentAsset = t.currentAsset(), i.currentAsset && i.currentAsset.url && i.currentAsset.url.length > 100 && (i.currentAsset.url = "".concat(i.currentAsset.url.substring(0, 97), "...")), i.selectedAsset = t.selectedAsset(), i.selectedAsset && i.selectedAsset.url && i.selectedAsset.url.length > 100 && (i.selectedAsset.url = "".concat(i.selectedAsset.url.substring(0, 97), "...")), i.getState = n((function() {
                        return t.getState()
                    })), i.getDuration = n((function() {
                        return t.getDuration()
                    })), i.getPlaybackRate = n((function() {
                        return t.getPlaybackRate()
                    })), i.getPlaybackMode = n((function() {
                        return t.getPlaybackMode()
                    })), i.isSeeking = n((function() {
                        return t.isSeeking()
                    })), i.getCurrentTime = n((function() {
                        return t.getCurrentTime()
                    })), i.activeBufferRange = n((function() {
                        return t.activeBufferRange()
                    })), i.sequentialBufferedRange = n((function() {
                        return t.sequentialBufferedRange()
                    })), i.getVolume = n((function() {
                        return t.getVolume()
                    })), i.timeBeforeEndOfBuffer = n((function() {
                        return t.timeBeforeEndOfBuffer()
                    })), i.lastBufferedTime = n((function() {
                        return t.lastBufferedTime()
                    })), i.totalBuffered = n((function() {
                        return t.totalBuffered()
                    })), i.anyBuffered = n((function() {
                        return t.anyBuffered()
                    })), i.getPreload = n((function() {
                        return t.getPreload()
                    })), i.rawVideoProps = n((function() {
                        return l(t)
                    })), i
                },
                o = ["autoplay", "controls", "crossOrigin", "currentSrc", "currentTime", "defaultMuted", "defaultPlaybackRate", "duration", "ended", "error", "loop", "muted", "networkState", "paused", "playbackRate", "preload", "readyState", "seeking", "src", "startDate", "volume"],
                l = function(t) {
                    for (var e = t.video, i = {}, r = 0; r < o.length; r++) {
                        var s = o[r],
                            n = e[s];
                        i[s] = n
                    }
                    return i
                }
        },
        575: (t, e, i) => {
            i.d(e, {
                fixWebkitControlsBug: () => o
            });
            var r = i(11),
                s = i(13),
                n = (0, r.cachedDetect)(),
                a = s.wlog.getPrefixedFunctions("SimpleVideo"),
                o = function(t) {
                    var e = t.video;
                    if (n.browser.webkit) {
                        a.info("fixWebkitControlsBug");
                        var i = e.getAttribute("controls");
                        e.setAttribute("controls", "controls"), e.removeAttribute("controls"), null != i && e.setAttribute("controls", i)
                    }
                }
        },
        563: (t, e, i) => {
            i.d(e, {
                bufferedInfo: () => g,
                createElement: () => l,
                properAssetUrl: () => m,
                setupVideoElemAttributes: () => c,
                srcProtocolAndHost: () => d,
                sumTimeRanges: () => f
            });
            var r = i(5),
                s = i(22),
                n = i(30),
                a = i(21),
                o = "".concat((0, a.eV1Protocol)(), "//").concat((0, a.eV1HostWithPort)(), "/assets/images/blank.gif"),
                l = function(t, e, i) {
                    var s = {
                            tagName: "video",
                            id: t,
                            crossorigin: "anonymous",
                            style: {
                                background: "transparent",
                                display: "block",
                                height: "100%",
                                maxHeight: "none",
                                maxWidth: "none",
                                position: "static",
                                visibility: "visible",
                                width: "100%"
                            }
                        },
                        n = {
                            tagName: "source",
                            src: m(e.url),
                            type: h(e, i)
                        };
                    return i.excludeSourceElem || (s.childNodes = [n]), c((0, r.elemFromObject)(s), e, i)
                },
                u = function(t, e, i) {
                    null != i && !1 !== i ? !0 === i ? (t[e] = !0, t.setAttribute(e, "")) : (t[e] = i, t.setAttribute(e, i)) : (t[e] = !1, t.removeAttribute(e))
                },
                c = function(t, e, i) {
                    return i.poster ? (t.poster = i.poster, t.setAttribute("poster", i.poster)) : (t.poster = o, t.setAttribute("poster", o)), u(t, "aria-label", "Video"), u(t, "src", m(e.url)), u(t, "controlslist", i.controlslist || "nodownload"), u(t, "playsinline", i.playsinline), u(t, "muted", i.muted), u(t, "loop", i.loop), u(t, "controls", null != i.controls && i.controls), u(t, "preload", i.preload || "none"), u(t, "type", h(e, i)), u(t, "x-webkit-airplay", null != i.webkitAirplay ? i.webkitAirplay : "allow"), null != i.volume && (t.volume = i.volume), i.disablePictureInPicture && u(t, "disablePictureInPicture", i.disablePictureInPicture), t
                },
                h = function(t, e) {
                    if (null != e.contentType) return e.contentType;
                    var i = "video/".concat(t.ext);
                    return e.spherical && (i += ";dimension=360;"), i
                },
                d = function(t) {
                    if ((0, n.isBakeryUrl)(t)) {
                        var e = new s.Url(t);
                        if (e.protocol) return "".concat(e.protocol, "//").concat(e.host)
                    }
                    return "".concat((0, a.eV1Protocol)(), "//").concat((0, a.deliveryHost)((0, a.eV1Protocol)()))
                },
                f = function(t) {
                    if (null == t) return null;
                    for (var e = 0, i = 0; i < t.length; i++) e += t.end(i) - t.start(i);
                    return e
                },
                g = function(t, e, i) {
                    var r, s, n, a, o, l = [];
                    for (t.sort((function(t, e) {
                            var i = t.start - e.start;
                            return i || e.end - t.end
                        })), o = 0; o < t.length; o++) {
                        var u = l.length;
                        if (u) {
                            var c = l[u - 1].end;
                            t[o].start - c < i ? t[o].end > c && (l[u - 1].end = t[o].end) : l.push(t[o])
                        } else l.push(t[o])
                    }
                    for (o = 0, r = 0, s = n = e; o < l.length; o++) {
                        var h = l[o].start,
                            d = l[o].end;
                        if (e + i >= h && e < d) s = h, r = (n = d) - e;
                        else if (e + i < h) {
                            a = h;
                            break
                        }
                    }
                    return {
                        len: r,
                        start: s,
                        end: n,
                        nextStart: a
                    }
                },
                m = function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "mp4";
                    return (0, n.isBakeryUrl)(t) && /\.bin$/.test(t) ? "".concat(t.replace(/\.bin$/, ""), "/file.").concat(e) : t
                }
        },
        562: (t, e, i) => {
            i.d(e, {
                default: () => R
            });
            var r = i(16),
                s = i(6),
                n = i(30),
                a = i(24),
                o = i(563),
                l = i(564),
                u = i(565),
                c = i(569),
                h = i(570),
                d = i(567),
                f = i(575),
                g = i(566),
                m = i(576),
                p = i(577),
                v = i(571),
                y = i(578),
                T = i(568),
                E = i(579),
                S = i(236),
                b = i(580);

            function A(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var r = e[i];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, L(r.key), r)
                }
            }

            function L(t) {
                var e = function(t, e) {
                    if ("object" != typeof t || !t) return t;
                    var i = t[Symbol.toPrimitive];
                    if (void 0 !== i) {
                        var r = i.call(t, e || "default");
                        if ("object" != typeof r) return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === e ? String : Number)(t)
                }(t, "string");
                return "symbol" == typeof e ? e : e + ""
            }
            var k = function() {
                return t = function t(e, i, r, s) {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.uuid = (0, a.seqId)("wistia_simple_video_"), this.root = e, this.state = {}, this.name = "SimpleVideo", v.setupProperties(this, i, r || {}), s ? v.fromOtherEngine(this, s) : v.injectVideo(this), f.fixWebkitControlsBug(this), v.setupBindingsAndLoops(this), m.fit(this)
                }, e = [{
                    key: "addTextTracks",
                    value: function(t) {
                        (0, b.addTextTracks)(t, this.video)
                    }
                }, {
                    key: "activeBufferRange",
                    value: function() {
                        return l.activeBufferRange(this)
                    }
                }, {
                    key: "anyBuffered",
                    value: function() {
                        return l.anyBuffered(this)
                    }
                }, {
                    key: "cancelFullscreen",
                    value: function() {
                        return d.cancelFullscreen(this)
                    }
                }, {
                    key: "captureCurrentFrame",
                    value: function() {
                        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                        return d.captureCurrentFrame.apply(d, [this].concat(e))
                    }
                }, {
                    key: "changeQuality",
                    value: function(t) {
                        return h.changeQuality(this, t)
                    }
                }, {
                    key: "changeStream",
                    value: function(t) {
                        return h.changeStream(this, t)
                    }
                }, {
                    key: "changeStreamWithoutLoad",
                    value: function(t) {
                        return h.changeStreamWithoutLoad(this, t)
                    }
                }, {
                    key: "changeVideo",
                    value: function(t, e) {
                        return h.changeVideo(this, t, e)
                    }
                }, {
                    key: "currentAsset",
                    value: function() {
                        return this._currentAsset
                    }
                }, {
                    key: "defaultAsset",
                    value: function() {
                        return this.selectableAssets()[0]
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        var t = this.state || {};
                        this.state = {
                            eventContext: t.eventContext,
                            destroyed: !0,
                            issuedPlay: t.issuedPlay
                        }, v.killBindingsAndStopLoops(this), this._bindings = {}
                    }
                }, {
                    key: "diagnosticData",
                    value: function() {
                        return p.getDiagnosticData(this)
                    }
                }, {
                    key: "eventContext",
                    value: function() {
                        return this.state.eventContext
                    }
                }, {
                    key: "fit",
                    value: function() {
                        return m.fit(this)
                    }
                }, {
                    key: "hasIssuedPlay",
                    value: function() {
                        return !!this.state.issuedPlay
                    }
                }, {
                    key: "getAudioTracks",
                    value: function() {
                        return []
                    }
                }, {
                    key: "getCurrentQuality",
                    value: function() {
                        var t = this.currentAsset();
                        if (t) return (0, n.numericSizeSnapped)(t.width, t.height);
                        var e = this.selectedAsset();
                        return e ? (0, n.numericSizeSnapped)(e.width, e.height) : "?"
                    }
                }, {
                    key: "getCurrentTime",
                    value: function() {
                        return d.getCurrentTime(this)
                    }
                }, {
                    key: "getCuts",
                    value: function() {
                        return (0, S.getCuts)(this)
                    }
                }, {
                    key: "getDuration",
                    value: function() {
                        return d.getDuration(this)
                    }
                }, {
                    key: "getMediaElement",
                    value: function() {
                        return this.video
                    }
                }, {
                    key: "getMediaType",
                    value: function() {
                        return this.mediaData.mediaType
                    }
                }, {
                    key: "getPlaybackMode",
                    value: function() {
                        return g.getPlaybackMode(this)
                    }
                }, {
                    key: "getPlaybackRate",
                    value: function() {
                        return d.getPlaybackRate(this)
                    }
                }, {
                    key: "getPreload",
                    value: function() {
                        return d.getPreload(this)
                    }
                }, {
                    key: "getState",
                    value: function() {
                        return d.getState(this)
                    }
                }, {
                    key: "getDurationBeforeCuts",
                    value: function() {
                        return (0, S.getDurationBeforeCuts)(this)
                    }
                }, {
                    key: "getTimeAfterCuts",
                    value: function(t) {
                        return (0, S.getTimeAfterCuts)(this, t)
                    }
                }, {
                    key: "getTimeBeforeCuts",
                    value: function(t) {
                        return (0, S.getTimeBeforeCuts)(this, t)
                    }
                }, {
                    key: "getTrim",
                    value: function() {
                        return (0, T.getTrim)(this)
                    }
                }, {
                    key: "getVolume",
                    value: function() {
                        return d.getVolume(this)
                    }
                }, {
                    key: "isChangingVideo",
                    value: function() {
                        return h.isChangingVideo(this)
                    }
                }, {
                    key: "isInFullscreen",
                    value: function() {
                        return d.isInFullscreen(this)
                    }
                }, {
                    key: "isInitializingFromUnmuted",
                    value: function() {
                        return d.isInitializingFromUnmuted(this)
                    }
                }, {
                    key: "isMuted",
                    value: function() {
                        return d.isMuted(this)
                    }
                }, {
                    key: "isSeeking",
                    value: function() {
                        return u.isSeeking(this)
                    }
                }, {
                    key: "isSourceOfBrowserEvent",
                    value: function(t) {
                        return d.isSourceOfBrowserEvent(this, t)
                    }
                }, {
                    key: "lastBufferedTime",
                    value: function(t) {
                        return l.lastBufferedTime(this, t)
                    }
                }, {
                    key: "loadSource",
                    value: function() {
                        var t = this.currentAsset();
                        t && this.changeStream(t)
                    }
                }, {
                    key: "mute",
                    value: function() {
                        return d.mute(this)
                    }
                }, {
                    key: "onEnterFullscreen",
                    value: function() {
                        return d.onEnterFullscreen(this)
                    }
                }, {
                    key: "onHeightChange",
                    value: function(t) {
                        return m.onHeightChange(this, t)
                    }
                }, {
                    key: "onLeaveFullscreen",
                    value: function() {
                        return d.onLeaveFullscreen(this)
                    }
                }, {
                    key: "onReady",
                    value: function() {
                        return c.onReady(this)
                    }
                }, {
                    key: "onWidthChange",
                    value: function(t) {
                        return m.onWidthChange(this, t)
                    }
                }, {
                    key: "pause",
                    value: function() {
                        return d.pause(this)
                    }
                }, {
                    key: "play",
                    value: function(t) {
                        return d.play(this, t)
                    }
                }, {
                    key: "playType",
                    value: function() {
                        return d.playType(this)
                    }
                }, {
                    key: "removeTextTracks",
                    value: function(t) {
                        (0, b.removeTextTracks)(t, this.video)
                    }
                }, {
                    key: "requestFullscreen",
                    value: function() {
                        return d.requestFullscreen(this)
                    }
                }, {
                    key: "reset",
                    value: function() {
                        this.state = {}
                    }
                }, {
                    key: "seek",
                    value: function(t, e) {
                        return u.seek(this, t, e)
                    }
                }, {
                    key: "seekOnPlay",
                    value: function(t) {
                        return u.seekOnPlay(this, t)
                    }
                }, {
                    key: "selectedAsset",
                    value: function() {
                        return this._currentAsset
                    }
                }, {
                    key: "selectableAssets",
                    value: function() {
                        return this.allAssets
                    }
                }, {
                    key: "selectableQualities",
                    value: function() {
                        return this.selectableAssets().map((function(t) {
                            return "variable" === t.width ? t.slug : (0, n.numericSizeSnapped)(t.width, t.height)
                        })).sort((function(t, e) {
                            return ("auto" === t ? -1 : t) - ("auto" === e ? -1 : e)
                        }))
                    }
                }, {
                    key: "selectedQuality",
                    value: function() {
                        var t = this.selectedAsset();
                        return t ? (0, n.numericSizeSnapped)(t.width, t.height) : "?"
                    }
                }, {
                    key: "sequentialBufferedRange",
                    value: function() {
                        return l.sequentialBufferedRange(this)
                    }
                }, {
                    key: "setAttributes",
                    value: function(t) {
                        (0, s.assign)(this.attributes, t)
                    }
                }, {
                    key: "onMediaDataChanged",
                    value: function() {}
                }, {
                    key: "onPlayed",
                    value: function() {
                        var t = this,
                            e = this.state;
                        return e && e.hasPlayed ? Promise.resolve() : new Promise((function(e) {
                            var i = function() {
                                t.unbind("playing", i), e()
                            };
                            t.bind("playing", i)
                        }))
                    }
                }, {
                    key: "setCurrentTime",
                    value: function(t) {
                        return d.setCurrentTime(this, t)
                    }
                }, {
                    key: "setCuts",
                    value: function(t) {
                        return (0, T.setCuts)(this, t)
                    }
                }, {
                    key: "setPlaybackRate",
                    value: function(t) {
                        return d.setPlaybackRate(this, t)
                    }
                }, {
                    key: "setTrim",
                    value: function(t) {
                        return (0, T.setTrim)(this, t)
                    }
                }, {
                    key: "setVolume",
                    value: function(t) {
                        return d.setVolume(this, t)
                    }
                }, {
                    key: "showFirstFrame",
                    value: function() {
                        return u.seek(this, .01)
                    }
                }, {
                    key: "canDownloadMedia",
                    value: function() {
                        return !0
                    }
                }, {
                    key: "stopStreaming",
                    value: function() {
                        return h.stopStreaming(this)
                    }
                }, {
                    key: "timeBeforeEndOfBuffer",
                    value: function(t) {
                        return l.timeBeforeEndOfBuffer(this, t)
                    }
                }, {
                    key: "totalBuffered",
                    value: function() {
                        return l.totalBuffered(this)
                    }
                }, {
                    key: "totalPlayed",
                    value: function() {
                        return o.sumTimeRanges(this.video.played)
                    }
                }, {
                    key: "unmute",
                    value: function() {
                        return d.unmute(this)
                    }
                }, {
                    key: "updateStartPosition",
                    value: function() {}
                }], e && A(t.prototype, e), i && A(t, i), Object.defineProperty(t, "prototype", {
                    writable: !1
                }), t;
                var t, e, i
            }();
            (0, r.bindify)(k.prototype), k.delegatePublicMethods = y.delegatePublicMethods, k.PUBLIC_METHODS = y.PUBLIC_METHODS, k.mediaDataWithAssets = function(t, e) {
                var i = (0, s.clone)(t);
                return i.assets = (0, s.clone)(e), i
            }, (0, E.default)("SimpleVideo", k);
            const R = k
        },
        571: (t, e, i) => {
            i.d(e, {
                fromOtherEngine: () => h,
                injectVideo: () => c,
                killBindingsAndStopLoops: () => f,
                setupBindingsAndLoops: () => d,
                setupProperties: () => u
            });
            var r = i(5),
                s = i(563),
                n = i(572),
                a = i(573),
                o = i(574),
                l = i(568),
                u = function(t, e, i) {
                    var r = e.assets;
                    0 === r.length && (r = [{}]), t.mediaData = e, t.allAssets = r, t.attributes = i
                },
                c = function(t) {
                    t._currentAsset = t.defaultAsset(), t.video = s.createElement(t.uuid, t._currentAsset, t.attributes), t.onReady(), (0, r.elemAppend)(t.root, t.video)
                },
                h = function(t, e) {
                    var i = e.isMuted(),
                        r = e.hasIssuedPlay();
                    "Audio" === e.mediaData.mediaType ? c(t) : t.video = e.getMediaElement(), t.onReady(), t.bind("loadstart", (function() {
                        return setTimeout((function() {
                            t.state.isInitializingFromOtherEngine = !1
                        }), 0), t.unbind
                    })), s.setupVideoElemAttributes(t.video, t.defaultAsset(), t.attributes), t.state.eventContext = e.eventContext(), t.root.appendChild(t.video), t._currentAsset = t.defaultAsset(), t.changeStreamWithoutLoad(t.defaultAsset()), t.state.isInitializingFromOtherEngine = !0, t.state.otherEngineWasMuted = i, t.state.otherEnginePlayed = r, t.video.load()
                },
                d = function(t) {
                    a.setup(t), (0, l.enforceCuts)(t), o.setup(t), n.setup(t)
                },
                f = function(t) {
                    o.teardown(t), (0, l.teardownCuts)(t), n.teardown(t), a.teardown(t)
                }
        },
        576: (t, e, i) => {
            i.d(e, {
                fit: () => h,
                onHeightChange: () => o,
                onWidthChange: () => a
            });
            var r = i(5),
                s = i(30),
                n = (0, i(11).cachedDetect)(),
                a = function(t, e) {
                    return t.setAttributes({
                        width: e
                    }), h(t)
                },
                o = function(t, e) {
                    return t.setAttributes({
                        height: e
                    }), h(t)
                },
                l = "contain",
                u = "fill",
                c = function(t) {
                    return !!t || !n.iphone && !n.ipad
                },
                h = function(t) {
                    var e = t.attributes.fitStrategy || d(t);
                    return e === l ? g(t) : "cover" === e ? f(t) : e === u ? m(t) : g(t)
                },
                d = function(t) {
                    var e = t.attributes.height,
                        i = t.attributes.width,
                        r = (0, s.originalAspect)(t.allAssets),
                        a = e * r,
                        o = 2 * Math.floor(i / r / 2),
                        c = Math.abs(o - e),
                        h = Math.abs(a - i),
                        d = n.firefox && n.browser.mozilla && n.browser.version >= 36;
                    return (n.browser.webkit || d) && c > 0 && c <= 10 && h > 0 && h <= 10 ? u : l
                },
                f = function(t) {
                    var e = t.video,
                        i = (0, s.videoAspect)(t.allAssets),
                        a = (0, r.elemWidth)(t.root) / (0, r.elemHeight)(t.root);
                    n.edge ? a <= i ? (0, r.elemStyle)(e, {
                        height: "100%",
                        left: "50%",
                        objectFit: "contain",
                        position: "relative",
                        top: "50%",
                        transform: "translate(-50%,-50%)",
                        width: "1920px"
                    }) : (0, r.elemStyle)(e, {
                        height: "1088px",
                        left: "50%",
                        objectFit: "contain",
                        position: "relative",
                        top: "50%",
                        transform: "translate(-50%,-50%)",
                        width: "100%"
                    }) : c(t.attributes.clipForPoster) && (0, r.elemStyle)(e, {
                        objectFit: "cover"
                    })
                },
                g = function(t) {
                    var e = t.video,
                        i = {
                            height: "100%",
                            width: "100%"
                        };
                    c(t.attributes.clipForPoster) && (i.objectFit = "contain"), (0, r.elemStyle)(e, i)
                },
                m = function(t) {
                    var e = t.video,
                        i = {
                            height: "100%",
                            width: "100%"
                        };
                    c(t.attributes.clipForPoster) && (i.objectFit = "fill"), (0, r.elemStyle)(e, i)
                }
        },
        569: (t, e, i) => {
            i.d(e, {
                onReady: () => s
            });
            var r = i(13).wlog.getPrefixedFunctions("SimpleVideo"),
                s = function(t) {
                    var e = t.video;
                    null == t.state && (t.state = {});
                    var i = t.state;
                    return i.onReadyPromise || (i.onReadyPromise = new Promise((function(s) {
                        if (i.hasBeenReady) s();
                        else {
                            if (e.readyState >= 2) r.info("ready readyState", e.src, e.readyState), i.hasBeenReady = !0, s();
                            else {
                                t.bind("loadstart", (function() {
                                    r.info("ready loadstart"), i.hasBeenReady = !0, s()
                                }))
                            }
                            setTimeout((function() {
                                i.hasBeenReady || (i.hasBeenReady = !0, s())
                            }), 200)
                        }
                    }))), i.onReadyPromise
                }
        },
        566: (t, e, i) => {
            i.d(e, {
                BEFORE_PLAY: () => s,
                getPlaybackMode: () => n
            });
            var r = i(13).wlog.getPrefixedFunctions("SimpleVideo"),
                s = "beforeplay",
                n = function(t) {
                    var e = t.video;
                    try {
                        return t.state.hasPlayed ? t.state.fakeEnded || e.ended ? "ended" : e.paused ? "paused" : "playing" : s
                    } catch (t) {
                        return r.warn(t), "unknown"
                    }
                }
        },
        574: (t, e, i) => {
            i.d(e, {
                setup: () => n,
                teardown: () => a
            });
            var r = i(5),
                s = ["beforeplay", "canplay", "canplaythrough", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "playing", "progress", "ratechange", "seeked", "seeking", "volumechange", "timeupdate", "waiting", "webkitbeginfullscreen", "webkitendfullscreen", "webkitplaybacktargetavailabilitychanged"],
                n = function(t) {
                    for (var e = 0; e < s.length; e++) {
                        var i = s[e];
                        ! function(e, i) {
                            var s = "_marshalEvent_".concat(i);
                            t[s] = t[s] || function(r) {
                                null == t.state && (t.state = {}), ("playing" !== i || "playing" === i && !e.paused) && (t.state.eventContext = r, t.trigger(i, r), t.state.eventContext = null)
                            }, (0, r.elemBind)(e, i, t[s])
                        }(t.video, i)
                    }
                },
                a = function(t) {
                    for (var e = 0; e < s.length; e++) {
                        var i = s[e],
                            n = "_marshalEvent_".concat(i);
                        (0, r.elemUnbind)(t.video, i, t[n])
                    }
                }
        },
        565: (t, e, i) => {
            i.d(e, {
                isSeeking: () => p,
                seek: () => c,
                seekOnPlay: () => g,
                seekWithoutCuts: () => h
            });
            var r = i(6),
                s = i(5),
                n = i(13),
                a = i(566),
                o = i(567),
                l = i(236),
                u = n.wlog.getPrefixedFunctions("SimpleVideo"),
                c = function(t, e, i) {
                    var r = (0, l.getTimeBeforeCuts)(t, e);
                    return h(t, r, i)
                },
                h = function(t, e, i) {
                    return u.info("seek", e), t.getPlaybackMode() === a.BEFORE_PLAY ? d(t, e, i) : f(t, e, i)
                },
                d = function(t, e) {
                    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                        s = t.video;
                    return u.info("seekBeforePlay", e), new Promise((function(n, a) {
                        u.info("time ".concat(e, ": seek beforeplay"));
                        var l = "playing" === t.getPlaybackMode();
                        s.style.visibility = "hidden", (0, r.assign)(t.state, {
                            seeking: !0
                        }), u.info("time ".concat(e, ": start stream by calling play")), (0, o.playWithoutCuts)(t).then((function(a) {
                            u.info("time ".concat(e, ": jump to time after playing")), s.currentTime = e;
                            var c = new Promise((function(r) {
                                l || !1 === i.pause ? (u.info("time: ".concat(e, ": play after seek")), r()) : (u.info("time: ".concat(e, ": pause after seek")), (0, o.pause)(t).then(r))
                            }));
                            m(t).then((function() {
                                c.then((function() {
                                    s.style.visibility = "inherit", (0, r.assign)(t.state, {
                                        seeking: !1
                                    }), n(a)
                                }))
                            }))
                        })).catch((function(e) {
                            s.style.visibility = "inherit", (0, r.assign)(t.state, {
                                seeking: !1
                            }), a(e)
                        }))
                    }))
                },
                f = function(t, e) {
                    return u.info("seekNow", e), new Promise((function(i) {
                        u.info("seekNow: start", e), t.video.currentTime = e, (0, r.assign)(t.state, {
                            seeking: !0
                        }), m(t).then((function() {
                            (0, r.assign)(t.state, {
                                seeking: !1
                            }), u.info("seekNow: resolve", e), i()
                        }))
                    }))
                },
                g = function(t, e) {
                    return new Promise((function(i) {
                        "playing" === t.getPlaybackMode() ? f(t, e).then(i) : t.bind("playing", (function() {
                            return f(t, e).then(i), t.unbind
                        }))
                    }))
                },
                m = function(t) {
                    var e = t.video;
                    return new Promise((function(t) {
                        e.seeking ? (u.info("waiting for seek"), (0, s.elemBind)(e, "seeked", (function() {
                            return u.info("seeked"), t(), s.elemUnbind
                        }))) : (u.info("no wait for seek"), t())
                    }))
                },
                p = function(t) {
                    var e = t.state,
                        i = t.video;
                    return Boolean(e.seeking || i.seeking)
                }
        },
        567: (t, e, i) => {
            i.r(e), i.d(e, {
                cancelFullscreen: () => $,
                captureCurrentFrame: () => G,
                getCurrentTime: () => E,
                getDuration: () => w,
                getPlaybackRate: () => R,
                getPreload: () => C,
                getState: () => S,
                getVolume: () => A,
                isInFullscreen: () => F,
                isInitializingFromUnmuted: () => O,
                isMuted: () => D,
                isSourceOfBrowserEvent: () => _,
                mute: () => I,
                onEnterFullscreen: () => x,
                onHeightChange: () => B,
                onLeaveFullscreen: () => M,
                onWidthChange: () => N,
                pause: () => v,
                play: () => g,
                playType: () => p,
                playWithoutCuts: () => m,
                requestFullscreen: () => U,
                setCurrentTime: () => y,
                setCurrentTimeWithoutCuts: () => T,
                setPlaybackRate: () => k,
                setVolume: () => b,
                supportsPlaybackRate: () => L,
                unmute: () => P
            });
            var r = i(5),
                s = i(13),
                n = i(11),
                a = i(6),
                o = i(236),
                l = i(568),
                u = s.wlog.getPrefixedFunctions("SimpleVideo"),
                c = (0, n.cachedDetect)(),
                h = "play",
                d = "play-silently",
                f = "cannot-play",
                g = function(t, e) {
                    var i = (0, l.trimStartFromCuts)(t);
                    return t.state.fakeEnded || t.video.currentTime < i ? new Promise((function(i, r) {
                        t.seek(0, {
                            pause: !1
                        }).then((function(s) {
                            m(t, (0, a.merge)({}, e, {
                                playType: h
                            })).then((function() {
                                i(s)
                            })).catch(r)
                        })).catch(r)
                    })) : m(t, e)
                },
                m = function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        i = t.video,
                        s = e.playType || p(t, e);
                    return null == t.state.issuedPlay && s !== f && (t.state.issuedPlay = !0), new Promise((function(n, a) {
                        t.state.lastPlayRejected = !1;
                        var o = t.getPlaybackMode();
                        if (u.info("play: start", s), "playing" === o) u.info("play: already playing, resolve"), n(h);
                        else if (s === f) a(new Error("Cannot issue play."));
                        else {
                            s === d && t.mute(), t.trigger("beforeplay"), "ended" === o && c.ios.version > 0 && (i.load(), t.attributes.hasCalledLoad = !0);
                            var l = i.play();
                            if (l && l.then && l.catch) l.then((function() {
                                u.info("play: got", s, "resolve"), n(s)
                            })).catch((function(r) {
                                u.notice(r), t.state.lastPlayRejected = !0;
                                var o = null != e.silentAutoplay ? e.silentAutoplay : t.attributes.silentAutoplay;
                                s !== h || t.isMuted() || "allow" !== o && null != o ? (u.notice("play: rejected"), a(r)) : (t.mute(), i.play().then((function() {
                                    u.info("play: got silent fallback, resolve"), n(d)
                                })).catch((function(e) {
                                    t.unmute(), a(e)
                                })))
                            }));
                            else {
                                setTimeout((function() {
                                    c.ios.version && c.ios.version < 10.1 && i.paused && a(new Error("Video still paused after play issued."))
                                }), 10);
                                t.bind("playing", (function() {
                                    return u.info("play: got playing, resolve"), n(s), r.elemUnbind
                                }))
                            }
                        }
                    }))
                },
                p = function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if ("playing" === t.getPlaybackMode()) return h;
                    if (t.isInitializingFromUnmuted()) return h;
                    if ((0, r.inUserEventContext)()) return h;
                    var i = t.attributes,
                        s = null != e.silentAutoplay ? e.silentAutoplay : i.silentAutoplay;
                    return !0 === s ? t.isMuted() ? h : d : !1 === s ? h : "allow" === s || null == s ? c.chrome || c.firefox || c.edge || (c.safari || c.ios.version && c.ios.version >= 12) || t.isMuted() ? h : d : h
                },
                v = function(t) {
                    var e = t.video;
                    return u.info("pause"), new Promise((function(t) {
                        u.info("pause: start"), e.pause(), (0, r.safeRequestAnimationFrame)((function() {
                            u.info("pause: resolve"), t()
                        }))
                    }))
                },
                y = function(t, e) {
                    var i = (0, o.getTimeBeforeCuts)(t, e);
                    return T(t, i)
                },
                T = function(t, e) {
                    u.info("setCurrentTime", e), t.video.currentTime = e
                },
                E = function(t) {
                    return (0, l.getCurrentTimeAfterCuts)(t)
                },
                S = function(t) {
                    return {
                        playbackMode: t.getPlaybackMode(),
                        currentTime: t.getCurrentTime(),
                        volume: t.getVolume(),
                        playbackRate: t.getPlaybackRate()
                    }
                },
                b = function(t, e) {
                    u.info("setVolume", e), t.video.volume = e
                },
                A = function(t) {
                    return t.video.volume
                },
                L = function(t) {
                    return null != t.video.playbackRate
                },
                k = function(t, e) {
                    u.info("setPlaybackRate", e), L(t) ? t.video.playbackRate = e : u.info("playbackRate is not supported on", t.video)
                },
                R = function(t) {
                    return L(t) ? t.video.playbackRate : 1
                },
                w = function(t) {
                    return (0, l.getDurationAfterCuts)(t)
                },
                _ = function(t, e) {
                    return e.target == t.video
                },
                D = function(t) {
                    var e = t.video;
                    return !!(e.muted || t.state.loadedMetadata && 0 === e.volume || t.state.hasPlayed && e.audioTracks && 0 === e.audioTracks.length)
                },
                C = function(t) {
                    return t.video.getAttribute("preload")
                },
                I = function(t) {
                    t.video.muted = !0, t.video.setAttribute("muted", "muted")
                },
                P = function(t) {
                    t.video.muted = !1, t.video.removeAttribute("muted")
                },
                x = function(t) {
                    t.state.isInFullscreen = !0;
                    var e = t.attributes.backgroundColor || "#000";
                    t.video.style.backgroundColor = e
                },
                M = function(t) {
                    t.state.isInFullscreen = !1, t.video.style.backgroundColor = "transparent"
                },
                O = function(t) {
                    var e = t.state;
                    return e.isInitializingFromOtherEngine && e.otherEnginePlayed && !e.otherEngineWasMuted
                },
                F = function(t) {
                    return !!t.state.isInFullscreen
                },
                N = function(t) {},
                B = function(t) {},
                U = function(t) {
                    return t.setAttributes({
                        fitStrategy: "contain"
                    }), t.fit(), (0, r.elemRequestFullscreen)(t.video)
                },
                $ = function(t) {
                    return t.setAttributes({
                        fitStrategy: "auto"
                    }), t.fit(), (0, r.elemCancelFullscreen)(t.video)
                },
                G = function(t) {
                    var e = t.video,
                        i = document.createElement("canvas");
                    i.width = e.videoWidth, i.height = e.videoHeight, i.getContext("2d").drawImage(e, 0, 0, i.width, i.height);
                    for (var r = arguments.length, s = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++) s[n - 1] = arguments[n];
                    return i.toDataURL.apply(i, s)
                }
        },
        570: (t, e, i) => {
            i.d(e, {
                changeQuality: () => c,
                changeStream: () => d,
                changeStreamWithoutLoad: () => h,
                changeVideo: () => g,
                initAfterChangeVideo: () => p,
                isChangingVideo: () => f,
                stopStreaming: () => u,
                teardownBeforeChangeVideo: () => m
            });
            var r = i(13),
                s = i(5),
                n = i(30),
                a = i(571),
                o = i(563),
                l = r.wlog.getPrefixedFunctions("SimpleVideo"),
                u = function(t) {
                    try {
                        if (t.state.destroyed) return;
                        l.info("stopStreaming");
                        var e = t.video;
                        e.src = "".concat(o.srcProtocolAndHost(e.getAttribute("src")), "/tiny.mp4"), e.load()
                    } catch (t) {
                        l.notice(t)
                    }
                },
                c = function(t, e, i, r) {
                    var s = t.selectableAssets(),
                        a = (0, n.findClosestAssetByQuality)(s, e);
                    return "beforeplay" === t.getPlaybackMode() ? (h(t, a), Promise.resolve()) : d(t, a, i, r)
                },
                h = function(t, e) {
                    l.info("changeStreamWithoutLoad", e && e.slug, e);
                    var i = t.video;
                    if ((0, s.elemInDom)(i)) {
                        var r = o.properAssetUrl(e.url, e.container);
                        t.state = {
                            eventContext: t.state.eventContext
                        }, t._currentAsset = e, i.src = r;
                        var n = function(t) {
                            for (var e = t.video, i = [], r = 0; r < e.childNodes.length; r++) {
                                var s = e.childNodes[r];
                                1 === s.nodeType && "source" === s.tagName.toLowerCase() && i.push(s)
                            }
                            return i
                        }(t);
                        n.length > 0 && (n[0].src = r)
                    }
                },
                d = function(t, e) {
                    var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                        r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                    l.info("changeStream", i, r, e && e.slug, e);
                    var n = t.video;
                    return t.asset = e, new Promise((function(a) {
                        var l = o.properAssetUrl(e.url, e.container);
                        if (r || l !== n.getAttribute("src")) {
                            var u = t.getState();
                            t.state.seeking = !0, (0, s.elemBind)(n, "loadstart", (function() {
                                return r ? (n.style.visibility = "visible", t.state.seeking = !1, a()) : u.currentTime > 2 ? t.seek(u.currentTime).then((function() {
                                    "playing" === u.playbackMode ? t.play().then((function() {
                                        t.state.seeking = !1, n.style.visibility = "visible", a()
                                    })) : t.pause().then((function() {
                                        n.style.visibility = "visible", t.state.seeking = !1, a()
                                    }))
                                })) : ("playing" === u.playbackMode && t.play(), n.style.visibility = "visible", t.state.seeking = !1, a()), t.setPlaybackRate(u.playbackRate), s.elemUnbind
                            })), n.style.visibility = "hidden", h(t, e, r), "beforeplay" === u.playbackMode || i || t.play()
                        } else a()
                    }))
                },
                f = function(t) {
                    return !!t.state.isChangingVideo
                },
                g = function(t, e, i) {
                    return m(t), t.state.isChangingVideo = !0, p(t, e, i), new Promise((function(e) {
                        d(t, t.defaultAsset()).then((function() {
                            t.state.isChangingVideo = !1, e()
                        }))
                    }))
                },
                m = function(t) {
                    var e = t.state.eventContext;
                    t.destroy(), t.state.eventContext = e
                },
                p = function(t, e, i) {
                    a.setupProperties(t, e, i), a.setupBindingsAndLoops(t, t.allAssets, i)
                }
        },
        580: (t, e, i) => {
            i.d(e, {
                addTextTracks: () => n,
                removeTextTracks: () => a
            });
            var r = i(24),
                s = i(5),
                n = function(t, e) {
                    var i = (0, r.seqId)("wistia_captions_");
                    t.forEach((function(t) {
                        var r = document.createElement("track");
                        r.kind = t.kind || "captions", r.label = t.native_name, r.srclang = t.language, r.src = t.src, r._wistiaCaptionsId = t._wistiaCaptionsId || i, e.appendChild(r, {
                            wistiaGridCaller: !0
                        })
                    }))
                },
                a = function(t, e) {
                    for (var i = Array.prototype.slice.call(e.childNodes), r = 0; r < i.length; r++) {
                        var n = i[r];
                        /^track$/i.test(n.tagName) && n._wistiaCaptionsId === t && (0, s.elemRemove)(n)
                    }
                }
        },
        573: (t, e, i) => {
            i.d(e, {
                setup: () => o,
                teardown: () => l
            });
            var r = i(6),
                s = i(5),
                n = i(55),
                a = function(t) {
                    var e = t.attributes;
                    return (null != e.eventLoopDuration ? e.eventLoopDuration : 300) / t.getPlaybackRate()
                },
                o = function(t) {
                    null == t.state && (t.state = {}), t.state.waiting = -1;
                    var e = "".concat(t.uuid, ".waiting_events");
                    n.globalEventLoop.add(e, a(t), (function() {
                        u(t), n.globalEventLoop.interval(e, a(t))
                    }))
                },
                l = function(t) {
                    var e = "".concat(t.uuid, ".waiting_events");
                    n.globalEventLoop.remove(e)
                },
                u = function(t) {
                    var e = t.video,
                        i = t.state,
                        n = i.lastPlaybackMode,
                        o = i.gotWaiting && "beforeplay" === t.getPlaybackMode() || "playing" === t.getPlaybackMode(),
                        l = "playing" === n || "beforeplay" === n && !i.lastPlayRejected,
                        u = i.lastEventLoopDuration || a(t);
                    if (o && l)
                        if (t.getCurrentTime() === i.lastTimePosition) {
                            var h = i.startedWaitingAt;
                            h ? (i.waiting = ((new Date).getTime() - h) / 1e3, t.trigger("custom-waiting", i.waiting)) : ((0, r.assign)(i, {
                                startedWaitingAt: (new Date).getTime() - u,
                                waiting: u / 1e3
                            }), t.trigger("custom-waiting", u / 1e3), (0, s.elemBind)(e, "timeupdate", (function() {
                                return c(t), s.elemUnbind
                            })))
                        } else c(t);
                    else c(t)
                },
                c = function(t) {
                    var e = t.state.waiting;
                    (0, r.assign)(t.state, {
                        waiting: -1,
                        startedWaitingAt: null
                    }), null != e && e >= 0 && t.trigger("custom-done-waiting", e)
                }
        },
        30: (t, e, i) => {
            i.d(e, {
                READY: () => h,
                filter: () => f,
                findClosestAssetByQuality: () => T,
                isBakeryUrl: () => S,
                nearestOutsideRange: () => _,
                numericSizeSnapped: () => y,
                originalAspect: () => w,
                readyPublicOver400: () => p,
                videoAspect: () => R,
                withinQualityRange: () => v
            });
            var r = i(6),
                s = i(22),
                n = (i(11), i(21)),
                a = i(13),
                o = i(23);

            function l(t, e) {
                return function(t) {
                    if (Array.isArray(t)) return t
                }(t) || function(t, e) {
                    var i = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                    if (null != i) {
                        var r, s, n, a, o = [],
                            l = !0,
                            u = !1;
                        try {
                            if (n = (i = i.call(t)).next, 0 === e) {
                                if (Object(i) !== i) return;
                                l = !1
                            } else
                                for (; !(l = (r = n.call(i)).done) && (o.push(r.value), o.length !== e); l = !0);
                        } catch (t) {
                            u = !0, s = t
                        } finally {
                            try {
                                if (!l && null != i.return && (a = i.return(), Object(a) !== a)) return
                            } finally {
                                if (u) throw s
                            }
                        }
                        return o
                    }
                }(t, e) || function(t, e) {
                    if (t) {
                        if ("string" == typeof t) return u(t, e);
                        var i = {}.toString.call(t).slice(8, -1);
                        return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? u(t, e) : void 0
                    }
                }(t, e) || function() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function u(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for (var i = 0, r = Array(e); i < e; i++) r[i] = t[i];
                return r
            }
            var c = Array.prototype.slice,
                h = 2,
                d = ["select", "sortFn", "sortBy", "unique"],
                f = function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if (!t) return [];
                    t.assets && (t = t.assets), null == e.qualityMin && null == e.qualityMax || (t = v(t, e.qualityMin, e.qualityMax), e = (0, r.except)(e, ["qualityMin", "qualityMax"]));
                    var i = (0, r.only)(e, d),
                        s = i.select || (0, r.except)(e, d);
                    s && (i.select = s);
                    var n = i.select ? (0, r.select)(t, i.select) : (0, r.clone)(t);
                    if ((i.sortFn || i.sortBy) && (n = (0, r.sort)(n, i.sortFn || i.sortBy)), i.unique) {
                        for (var a = {}, o = 0; o < n.length; o++) {
                            var l = n[o],
                                u = l["".concat(i.unique)] || "__undefined__";
                            a[u] || (a[u] = l)
                        }
                        for (var c in n = [], a) n.push(a[c])
                    }
                    return n
                },
                g = function(t, e) {
                    return f(t, e)[0] || null
                },
                m = function(t) {
                    for (var e = [], i = 0; i < t.length; i++) {
                        var r = t[i],
                            s = null != r.opt_vbitrate && r.opt_vbitrate >= 500 && r.opt_vbitrate <= 1e5,
                            n = null != r.width && r.width > 400;
                        (s || n) && e.push(r)
                    }
                    return e
                },
                p = function(t) {
                    return m(f(t, {
                        container: /mp4/,
                        public: !0,
                        status: h
                    }))
                },
                v = function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100,
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e4;
                    return f(t, {
                        select: function(t) {
                            var r = y(t.width, t.height);
                            return e <= r && r <= i
                        }
                    })
                },
                y = function(t, e) {
                    if (e > t) {
                        var i = t;
                        t = e, e = i
                    }
                    var r = t / e,
                        s = t * e + 1;
                    return s >= 3840 / r * 3840 ? 2160 : s >= 2560 / r * 2560 ? 1440 : s >= 1920 / r * 1920 ? 1080 : s >= 1280 / r * 1280 ? 720 : s >= 960 / r * 960 ? 540 : s >= 640 / r * 640 ? 360 : e
                },
                T = function(t, e) {
                    var i;
                    i = "4k" === e ? 2160 : parseInt(e, 10);
                    var r = v(t, i, i)[0];
                    if (r) return r;
                    var s = _(t, i, i);
                    if (1 === s.length) return s[0];
                    var n = R(t),
                        a = Math.round(n * i),
                        o = l(s, 2),
                        u = o[0],
                        c = o[1];
                    return Math.abs(u.width - a) < Math.abs(c.width - a) ? u : c
                },
                E = ((0, o.appHostname)("fast"), [n.EMBED_HOST, n.SSL_EMBED_HOST, (0, o.appHostname)("embed"), (0, o.appHostname)("prime"), (0, o.appHostname)("mixergy-cdn"), (0, o.appHostname)("embed-fastly"), n.PROD_EMBED_HOST, n.PROD_SSL_EMBED_HOST, n.PROD_FASTLY_SSL_HOST]),
                S = function(t) {
                    if (null == t) return !1;
                    var e = new s.Url(t);
                    return !!e.host && E.join(",").indexOf(e.host) >= 0
                },
                b = function(t, e, i) {
                    return i = (0, r.merge)({
                        container: e,
                        public: !0,
                        status: h
                    }, i), g(t, i)
                },
                A = function(t, e) {
                    return b(t, "mp4", e)
                },
                L = function(t, e) {
                    return b(t, "webm", e)
                },
                k = function(t) {
                    return g(t, {
                        type: "original"
                    })
                },
                R = function(t) {
                    var e = A(t) || function(t, e) {
                        return b(t, "m3u8", e)
                    }(t) || L(t) || k(t);
                    return e && e.height ? e.width / e.height : 640 / 360
                },
                w = function(t) {
                    var e = R(t),
                        i = k(t);
                    if (i && i.width && i.height) {
                        var r = i.width / i.height;
                        return r > 1 && e < 1 || r < 1 && e > 1 ? 1 / r : r
                    }
                    return e
                },
                _ = function(t, e, i) {
                    if (0 === t.length) return [];
                    for (var r, s, n = c.call(t).sort((function(t, e) {
                            return y(t.width, t.height) - y(e.width, e.height)
                        })), o = 0; o < n.length; o++) {
                        var l = n[o],
                            u = y(l.width, l.height);
                        if (u < e && (r = l), u >= i) {
                            s = l;
                            break
                        }
                    }
                    var h = [];
                    return r && h.push(r), s && h.push(s), 0 === h.length && (a.wlog.error("nearestOutsideRange: no nearby assets found, using first in list", n[0]), h.push(n[0])), h
                }
        },
        7: (t, e, i) => {
            i.d(e, {
                assign: () => s
            });
            var r = function(t, e) {
                    if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                    return Object.prototype.hasOwnProperty.call(Object(t), e)
                },
                s = function(t) {
                    for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) i[r - 1] = arguments[r];
                    if (Object.assign) return Object.assign.apply(Object, [t].concat(i));
                    for (var s = 0; s < i.length; s++) n(t, i[s]);
                    return t
                },
                n = function(t, e) {
                    for (var i in e) r(e, i) && (t[i] = e[i]);
                    return t
                }
        },
        16: (t, e, i) => {
            i.d(e, {
                bind: () => l,
                bindNamed: () => g,
                bindify: () => y,
                trigger: () => h,
                unbind: () => u,
                unbindAllInNamespace: () => p,
                unbindNamed: () => m
            });
            var r = i(3),
                s = function(t, e) {
                    if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                    return Object.prototype.hasOwnProperty.call(Object(t), e)
                };

            function n(t) {
                return function(t) {
                    if (Array.isArray(t)) return a(t)
                }(t) || function(t) {
                    if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                }(t) || function(t, e) {
                    if (t) {
                        if ("string" == typeof t) return a(t, e);
                        var i = {}.toString.call(t).slice(8, -1);
                        return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? a(t, e) : void 0
                    }
                }(t) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function a(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for (var i = 0, r = Array(e); i < e; i++) r[i] = t[i];
                return r
            }
            var o = Array.prototype.slice,
                l = function(t, e) {
                    var i = this;
                    return i._bindings || (i._bindings = {}), i._bindings[t] || (i._bindings[t] = []), i._bindings[t].push(e),
                        function() {
                            i.unbind(t, e)
                        }
                },
                u = function(t, e) {
                    if (!this._bindings) return this;
                    if (!this._bindings[t]) return this;
                    for (var i = [], r = 0; r < this._bindings[t].length; r++) {
                        var s = this._bindings[t][r];
                        s !== e && i.push(s)
                    }
                    this._bindings[t] = i
                },
                c = function(t, e) {
                    return this.unbind(t, e), this.bind(t, e), {
                        event: t,
                        fn: e
                    }
                },
                h = function(t) {
                    for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) i[r - 1] = arguments[r];
                    return this._bindings && null != this._bindings.all && d.apply(this, ["all", t].concat(i)), d.apply(this, [t].concat(i))
                },
                d = function(t) {
                    if (!this._bindings) return this;
                    if (!this._bindings[t]) return this;
                    for (var e, i = o.call(arguments, 1), s = n(this._bindings[t]), a = 0; a < s.length; a++) {
                        var l = s[a];
                        try {
                            l.apply(this, i) === this.unbind && (null == e && (e = []), e.push({
                                event: t,
                                fn: l
                            }))
                        } catch (t) {
                            if (this._throwTriggerErrors) throw t;
                            r.Wistia.error && r.Wistia.error(t)
                        }
                    }
                    if (e)
                        for (var u = 0; u < e.length; u++) {
                            var c = e[u];
                            this.unbind(c.event, c.fn)
                        }
                    return this
                },
                f = function(t, e) {
                    null == t._namedBindings && (t._namedBindings = {}), null == t._namedBindings[e] && (t._namedBindings[e] = {})
                },
                g = function(t, e, i, r) {
                    return this.unbindNamed(t, e),
                        function(t, e, i, r, s) {
                            f(t, e), t._namedBindings[e][i] = {
                                event: r,
                                fn: s
                            }
                        }(this, t, e, i, r), this.bind(i, r),
                        function() {
                            this.unbindNamed(t, e)
                        }
                },
                m = function(t, e) {
                    f(this, t);
                    var i = function(t, e, i) {
                        return f(t, e), t._namedBindings[e][i]
                    }(this, t, e);
                    if (i) {
                        var r = i.event,
                            s = i.fn;
                        this.unbind(r, s)
                    }
                    var n = this._namedBindings;
                    return delete n[t][e], v(n[t]) && delete n[t], this
                },
                p = function(t) {
                    var e = this._namedBindings && this._namedBindings[t];
                    if (null == e) return this;
                    for (var i in e) s(e, i) && this.unbindNamed(t, i)
                },
                v = function(t) {
                    for (var e in t)
                        if (s(t, e)) return !1;
                    return !0
                },
                y = function(t) {
                    return t.bind = l, t.unbind = u, t.on = l, t.off = u, t.rebind = c, t.trigger = h, t.bindNamed = g, t.unbindNamed = m, t.unbindAllInNamespace = p, t
                };
            y(function() {}.prototype)
        },
        558: (t, e, i) => {
            i.d(e, {
                makeCacheable: () => r,
                makeNamespace: () => s,
                uncacheNamespace: () => u
            });
            var r = function(t) {
                    return function(e, i, r) {
                        if (o(t, e), n(t, e, i)) return a(t, e, i);
                        var s = r();
                        return l(t, e, i, s), s
                    }
                },
                s = function(t) {
                    return function(e) {
                        return null == e[t] && (e[t] = {}), e[t]
                    }
                },
                n = function(t, e, i) {
                    return null != a(t, e, i)
                },
                a = function(t, e, i) {
                    return o(t, e), e[t][i]
                },
                o = function(t, e) {
                    null == e[t] && (e[t] = {})
                },
                l = function(t, e, i, r) {
                    o(t, e), e[t][i] = r
                },
                u = function(t, e) {
                    e[t] = {}
                }
        },
        11: (t, e, i) => {
            i.d(e, {
                cachedDetect: () => V
            });
            var r, s = i(3),
                n = i(4),
                a = i(12),
                o = navigator.userAgent,
                l = /(webkit)[ /]([^\s]+)/i,
                u = /OPR\/([^\s]+)/i,
                c = /(edge)\/(\d+(?:\.\d+)?)/i,
                h = /(mozilla)(?:.*? rv:([^\s)]+))?/i,
                d = /(android) ([^;]+)/i,
                f = /(iphone)/i,
                g = /(Windows Phone OS (\d+(?:\.\d+)?))/,
                m = /OS (\d+)_(\d+)/i,
                p = /(playstation 3)/i,
                v = /BlackBerry|BB10/i,
                y = /(firefox)/i,
                T = /Mobile VR/i,
                E = /Version\/([^\s]+)/i,
                S = function() {
                    return (A()[1] || "webkit").toLowerCase()
                },
                b = function() {
                    return A()[2]
                },
                A = function() {
                    var t;
                    return (t = o.match(c)) || (t = o.match(l)) || (t = o.match(u)) ? t : t ? (null != document.documentMode && (t[2] = document.documentMode), t) : (t = o.match(h)) || []
                },
                L = function() {
                    var t = o.match(d);
                    return null != t && {
                        version: t[2]
                    }
                },
                k = function() {
                    return f.test(o)
                },
                R = function() {
                    return O() > 0 || L() || D()
                },
                w = function() {
                    try {
                        var t = matchMedia("(hover:hover)");
                        if ("not all" !== t.media) return t.matches
                    } catch (t) {}
                    return !R()
                },
                _ = function() {
                    return v.test(o)
                },
                D = function() {
                    return /Macintosh/i.test(navigator.userAgent) && navigator.maxTouchPoints && navigator.maxTouchPoints > 1
                },
                C = function() {
                    return l.test(o) && !/chrome/i.test(o) && !D() && !k()
                },
                I = function() {
                    return !(!/Chrome/.test(o) || !/Google Inc/.test(navigator.vendor)) && {
                        version: x()
                    }
                },
                P = function() {
                    var t = o.match(/\bSilk\/([^\s]+)/);
                    return t && t[1]
                },
                x = function() {
                    var t = o.match(/\bChrome\/([^\s]+)/);
                    return t && t[1]
                },
                M = function() {
                    return u.test(o)
                },
                O = function() {
                    var t = o.match(m),
                        e = o.match(E);
                    return null != t ? parseFloat("".concat(t[1], ".").concat(t[2])) : null != e && e[1] && D() ? parseFloat(e[1]) : 0
                },
                F = function() {
                    return c.test(o)
                },
                N = function() {
                    return y.test(o)
                },
                B = function() {
                    var t = document.createElement("video"),
                        e = !1;
                    try {
                        if (t.canPlayType) {
                            var i = 'video/mp4; codecs="avc1.42E01E';
                            (e = {}).h264 = !!t.canPlayType("".concat(i, '"')) || !!t.canPlayType("".concat(i, ', mp4a.40.2"')), e.webm = !!t.canPlayType('video/webm; codecs="vp9, vorbis"'), e.nativeHls = !!t.canPlayType("application/vnd.apple.mpegURL")
                        }
                    } catch (t) {
                        e = {
                            ogg: !1,
                            h264: !1,
                            webm: !1,
                            nativeHls: !1
                        }
                    }
                    return e
                },
                U = function() {
                    try {
                        return "localStorage" in n.root && null != n.root.localStorage
                    } catch (t) {
                        return !1
                    }
                },
                $ = ["WebKit", "Moz", "O", "Ms", ""],
                G = function() {
                    for (var t = 0; t < $.length; t++) {
                        var e = "".concat($[t], "MutationObserver");
                        if (n.root[e]) return e
                    }
                    return null
                },
                H = function() {
                    if (null != r) return r;
                    try {
                        var t = Object.defineProperty({}, "passive", {
                            get: function() {
                                r = !0
                            }
                        });
                        window.addEventListener("test", null, t)
                    } catch (t) {
                        r = !1
                    }
                    return r
                },
                V = function() {
                    return s.Wistia._detectCache || (s.Wistia._detectCache = W()), s.Wistia._detectCache
                },
                W = function() {
                    var t, e, i, r, s, l, u, c, h, d, f, m, v = {
                        amazonSilk: !!/Silk/.test(o) && {
                            version: P()
                        },
                        browser: {
                            version: b()
                        },
                        edge: F(),
                        firefox: N(),
                        gearvr: T.test(o),
                        android: L(),
                        oldandroid: L() && parseFloat(L().version) < 4.1,
                        iphone: k(),
                        ipad: D(),
                        blackberry: _(),
                        safari: C(),
                        chrome: I(),
                        opera: M(),
                        winphone: {
                            version: g.test(o)[2]
                        },
                        ios: {
                            version: O()
                        },
                        windows: /win/i.test(navigator.platform),
                        mac: /mac/i.test(navigator.platform),
                        linux: /linux/i.test(navigator.platform),
                        retina: null != n.root.devicePixelRatio && n.root.devicePixelRatio > 1,
                        hoverIsNatural: w(),
                        touchScreen: R(),
                        ps3: p.test(o),
                        video: B(),
                        mediaSource: n.root.MediaSource && n.root.MediaSource.isTypeSupported("".concat('video/mp4; codecs="avc1.42E01E', ', mp4a.40.2"')),
                        nativeHls: (k() || D() || C()) && B().nativeHls,
                        localstorage: U(),
                        json: !(!n.root.JSON || "function" != typeof JSON.parse),
                        backgroundSize: (m = document.createElement("div"), "" === m.style.backgroundSize || "" === m.style.webkitBackgroundSize || "" === m.style.mozBackgroundSize || "" === m.style.oBackgroundSize),
                        fullscreenEnabled: document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled,
                        vulcanSupport: (f = /webkit|mozilla|edge/.test(S()), Boolean(!k() && !D() && !L() && !_() && f && B().h264 && Object.defineProperties)),
                        mutationObserver: G(),
                        callingPlayRequiresEventContext: O() > 0 || L() || C(),
                        passiveSupported: H(),
                        webp: (t = I(), e = N(), i = F(), r = M(), s = t && b() >= 32, l = t && b() >= 75 && L(), u = e && b() >= 65, c = e && b() >= 67 && L(), h = i && b() >= 18, d = r && b() >= 19, s || l || u || c || h || d),
                        performanceMeasure: (0, a.hasPerformanceMeasureSupport)()
                    };
                    return v.browser[S()] = !0, v
                }
        },
        8: (t, e, i) => {
            i(9)
        },
        5: (t, e, i) => {
            i.d(e, {
                elemAppend: () => f,
                elemBind: () => A,
                elemCancelFullscreen: () => w,
                elemFromObject: () => d,
                elemHeight: () => S,
                elemInDom: () => b,
                elemRemove: () => g,
                elemRequestFullscreen: () => R,
                elemStyle: () => m,
                elemUnbind: () => L,
                elemWidth: () => E,
                inUserEventContext: () => I,
                pageLoaded: () => n.pageLoaded,
                safeRequestAnimationFrame: () => C
            });
            var r, s = i(6),
                n = (i(8), i(10)),
                a = i(11),
                o = i(13),
                l = (i(17), i(18), i(24)),
                u = i(3),
                c = function(t, e) {
                    if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                    return Object.prototype.hasOwnProperty.call(Object(t), e)
                },
                h = (u.Wistia, (0, a.cachedDetect)()),
                d = function(t) {
                    if ((0, s.isArray)(t)) {
                        for (var e = [], i = 0; i < t.length; i++) e.push(d(t[i]));
                        return e
                    }
                    var r = t.tagName || "div",
                        n = t.childNodes || [];
                    (0, s.isArray)(n) || (n = [n]);
                    var a = document.createElement(r);
                    for (var o in t)
                        if (c(t, o)) {
                            var l = t[o];
                            if ("childNodes" !== o && "tagName" !== o && "ref" !== o) {
                                var u = o.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
                                if ("style" === o)
                                    if ((0, s.isObject)(l))
                                        for (var h in l) a.style[h] = l[h];
                                    else
                                        for (var g = l.split(";"), m = 0; m < g.length; m++) {
                                            var p = g[m].split(/\s*:\s*/),
                                                v = p[0],
                                                y = p[1];
                                            v && y && (a.style[v] = y)
                                        } else if ("events" === o)
                                            for (var T in l) {
                                                var E = l[T];
                                                A(a, T, E)
                                            } else "className" === o || "class" === o ? a.className = l : "innerHTML" === o ? a.innerHTML = l : "innerText" === o ? a.innerText = l : null != l && "function" == typeof l.toString && a.setAttribute(u, l.toString())
                            }
                        }
                    for (var S = 0; S < n.length; S++) {
                        var b = n[S];
                        if ((0, s.isObject)(b)) {
                            var L = d(b);
                            f(a, L)
                        } else {
                            var k = document.createTextNode(b.toString());
                            f(a, k)
                        }
                    }
                    return "function" == typeof t.ref && t.ref(a), a
                },
                f = function(t, e) {
                    if ((0, s.isArray)(e))
                        for (var i = 0; i < e.length; i++) f(t, e[i]);
                    else t.tagName.includes("-") ? t.shadowRoot.appendChild(e, {
                        wistiaGridCaller: !0
                    }) : t.appendChild(e, {
                        wistiaGridCaller: !0
                    })
                },
                g = function(t) {
                    var e;
                    if ((0, s.isArray)(t) || window.NodeList && t instanceof NodeList)
                        for (var i = 0; i < t.length; i++) g(t[i]);
                    else null == t || 1 !== t.nodeType && 3 !== t.nodeType || !(e = t.parentNode) || (e.removeChild(t), t = null)
                },
                m = function(t) {
                    for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) i[r - 1] = arguments[r];
                    if ((0, s.isArray)(t) || window.NodeList && t instanceof NodeList) {
                        for (var n = [], a = 0; a < t.length; a++) {
                            var l = t[a];
                            1 === l.nodeType && n.push(m.apply(void 0, [l].concat(i)))
                        }
                        return n
                    }
                    if (2 === i.length) {
                        var u = i[0],
                            c = i[1];
                        t.style[u] = c
                    } else if (1 === i.length)
                        if ("string" == typeof i[0]) {
                            var h = i[0];
                            try {
                                return t.currentStyle ? t.currentStyle[h] : window.getComputedStyle ? window.getComputedStyle(t, null).getPropertyValue(h) : null
                            } catch (t) {
                                o.wlog.notice(t)
                            }
                        } else {
                            var d = y(i[0]);
                            for (var f in d) {
                                var g = d[f];
                                t.style[f] = g
                            }
                        }
                    else o.wlog.apply(void 0, ["Unexpected args", t].concat(i))
                },
                p = {
                    borderImage: !0,
                    mixBlendMode: !0,
                    transform: !0,
                    transition: !0,
                    transitionDuration: !0
                },
                v = ["webkit", "moz", "o", "ms"],
                y = function(t) {
                    if (h.chrome) return t;
                    var e = {};
                    for (var i in t) {
                        var r = t[i];
                        if (e[i] = r, p[i])
                            for (var s = v, n = 0; n < s.length; n++) {
                                var a = s[n] + i.charAt(0).toUpperCase() + i.slice(1);
                                i[a] || (e[a] = r)
                            }
                    }
                    return e
                },
                T = function(t, e) {
                    if (!window.getComputedStyle) return null;
                    var i = window.getComputedStyle(t, null);
                    return null == i ? null : null != e ? i[e] : i
                },
                E = function(t) {
                    if (t === window) return window.innerWidth ? window.innerWidth : document.documentElement ? document.documentElement.offsetWidth : document.body.offsetWidth;
                    if (t === document) {
                        var e = document.body,
                            i = document.documentElement;
                        return Math.max(e.scrollWidth, e.offsetWidth, i.clientWidth, i.scrollWidth, i.offsetWidth)
                    }
                    var r;
                    return (r = T(t, "width")) && null != r ? parseFloat(r) : t.currentStyle ? t.offsetWidth : -1
                },
                S = function(t) {
                    if (t === window) return window.innerHeight ? window.innerHeight : document.documentElement ? document.documentElement.offsetHeight : document.body.offsetHeight;
                    if (t === document) {
                        var e = document.body,
                            i = document.documentElement;
                        return Math.max(e.scrollHeight, e.offsetHeight, i.clientHeight, i.scrollHeight, i.offsetHeight)
                    }
                    var r;
                    return (r = T(t, "height")) && null != r ? parseFloat(r) : t.currentStyle ? t.offsetHeight : -1
                },
                b = function(t) {
                    for (; t;) {
                        if (t === document) return !0;
                        t = t.parentNode || t.getRootNode().host
                    }
                    return !1
                },
                A = function(t, e, i) {
                    var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                        s = function(r) {
                            (r = r || window.event).pageX || r.pageY || !r.clientX && !r.clientY || (r.pageX = r.clientX + D(), r.pageY = r.clientY + _()), r.preventDefault || (r.preventDefault = function() {
                                r.returnValue = !1
                            }), r.stopPropagation || (r.stopPropagation = function() {
                                r.cancelBubble = !0
                            }), null == r.which && (r.which = null != r.charCode ? r.charCode : r.keyCode), null == r.which && null != r.button && (1 & r.button ? r.which = 1 : 2 & r.button ? r.which = 3 : 4 & r.button ? r.which = 2 : r.which = 0), r.target || r.srcElement && (r.target = r.srcElement), r.target && 3 === r.target.nodeType && (r.target = r.target.parentNode);
                            for (var s = arguments.length, n = new Array(s > 1 ? s - 1 : 0), a = 1; a < s; a++) n[a - 1] = arguments[a];
                            var o = i.apply(r.target, [r].concat(n));
                            return o === L && L(t, e, i), o
                        };
                    u.Wistia._elemBind = u.Wistia._elemBind || {};
                    var n = k(t, e, i);
                    return u.Wistia._elemBind[n] = s, s.elem = t, s.event = e, t.addEventListener(e, s, r),
                        function() {
                            L(t, e, i, r)
                        }
                },
                L = function(t, e, i) {
                    var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                    if (null != t && null != t._wistiaElemId && null != i && i._wistiaBindId) {
                        var s = k(t, e, i),
                            n = u.Wistia._elemBind[s];
                        return n && (t.removeEventListener(e, n, r), n.elem = null, n.event = null), delete u.Wistia._elemBind[s]
                    }
                },
                k = function(t, e, i) {
                    return t._wistiaElemId = t._wistiaElemId || (0, l.seqId)("wistia_elem_"), i._wistiaBindId = i._wistiaBindId || (0, l.seqId)("wistia_bind_"), "".concat(t._wistiaElemId, ".").concat(e, ".").concat(i._wistiaBindId)
                },
                R = function(t) {
                    return t.requestFullscreen ? t.requestFullscreen() : t.webkitEnterFullscreen ? new Promise((function(e) {
                        t.webkitEnterFullscreen(), e()
                    })) : (o.wlog.notice("no requestFullscreen functionality detected"), Promise.resolve())
                },
                w = function(t) {
                    return document.exitFullscreen ? document.exitFullscreen() : t && t.webkitExitFullscreen ? new Promise((function(e) {
                        t.webkitExitFullscreen(), e()
                    })) : (o.wlog.notice("no cancelFullscreen functionality detected"), Promise.resolve())
                },
                _ = function(t) {
                    var e = document.body,
                        i = document.documentElement;
                    if (null == t) return i && i.scrollTop || e && e.scrollTop || 0;
                    e && (e.scrollTop = t), i && (i.scrollTop = t)
                },
                D = function(t) {
                    var e = document.body,
                        i = document.documentElement;
                    if (null == t) return i && i.scrollLeft || e && e.scrollLeft || 0;
                    e && (e.scrollLeft = t), i && (i.scrollLeft = t)
                },
                C = function(t) {
                    return (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(t) {
                        return setTimeout(t, 1e3 / 60)
                    })(t)
                },
                I = function() {
                    return !!r
                };
            ["auxclick", "click", "contextmenu", "dblclick", "focus", "keydown", "keypress", "keyup", "mousedown", "mouseup", "reset", "submit", "touchend", "touchstart"].forEach((function(t) {
                A(document, t, (function(t) {
                    r = t, Date.now(), setTimeout((function() {
                        r === t && (r = void 0)
                    }), 0)
                }), !h.passiveSupported || {
                    capture: !0,
                    passive: !0
                })
            }))
        },
        17: (t, e, i) => {
            var r;
            i.d(e, {
                elemOffset: () => n
            });
            var s = function() {
                    if (null != r) return r;
                    var t = document.createElement("div");
                    return t.style.paddingLeft = t.style.width = "1px", document.body.appendChild(t), r = 2 === t.offsetWidth, document.body.removeChild(t), r
                },
                n = function(t) {
                    var e, i, r = document.body,
                        n = document.defaultView,
                        o = document.documentElement,
                        l = t.getBoundingClientRect(),
                        u = o.clientTop || r.clientTop || 0,
                        c = o.clientLeft || r.clientLeft || 0;
                    e = n && null != n.pageYOffset ? n.pageYOffset : s() && o && null != o.scrollTop ? o.scrollTop : r.scrollTop, i = n && null != n.pageXOffset ? n.pageXOffset : s() && o && null != o.scrollLeft ? o.scrollLeft : r.scrollLeft;
                    var h = a(t);
                    return {
                        height: l.height * h,
                        top: l.top * h + e - u,
                        left: l.left * h + i - c,
                        width: l.width * h,
                        zoom: h
                    }
                },
                a = function(t) {
                    return t && t !== document.documentElement ? a(t.parentElement) * (getComputedStyle(t).zoom || 1) : 1
                }
        },
        55: (t, e, i) => {
            i.d(e, {
                globalEventLoop: () => l
            });
            var r = i(13),
                s = i(3),
                n = r.wlog.getPrefixedFunctions("event_loop"),
                a = function() {
                    var t = this,
                        e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    this._timeoutId = null, this._latency = null != e.latency ? e.latency : 100, this._blurLatency = null != e.blurLatency ? e.blurLatency : 2e3, this._functions = {}, this._paused = {}, window.addEventListener("blur", (function() {
                        return t.blur()
                    }), !1), window.addEventListener("focus", (function() {
                        return t.focus()
                    }), !1), this.start()
                },
                o = a.prototype;
            o.start = function() {
                var t = this;
                clearTimeout(this._timeoutId), this._loopFn = this._loopFn || function() {
                    t.runFunctions(), t._timeoutId = setTimeout(t._loopFn, t._latency)
                }, this._loopFn()
            }, o.resync = function() {
                this.start()
            }, o.resyncNextTick = function() {
                var t = this;
                setTimeout((function() {
                    t.resync()
                }), 0)
            }, o.stop = function() {
                clearTimeout(this._timeoutId)
            }, o.clear = function() {
                this._functions = {}
            }, o.runFunctions = function() {
                this._pausedDirty && this.updatePaused();
                var t = [];
                for (var e in this._functions) {
                    var i = this._functions[e],
                        r = (new Date).getTime(),
                        s = r - i.lastRanAt;
                    if (!i.paused && s >= i.interval) {
                        i.lastRanAt = r;
                        try {
                            i.fn() === this.remove && t.push(e)
                        } catch (t) {
                            n.error(t)
                        }
                    }
                }
                for (var a = 0; a < t.length; a++) this.remove(t[a])
            }, o.add = function(t, e, i) {
                var r = (new Date).getTime();
                this._functions[t] = {
                    addedAt: r,
                    lastRanAt: -1,
                    interval: e,
                    fn: i
                };
                var s = i();
                this._functions[t] && (this._functions[t].lastRanAt = (new Date).getTime()), this._functions[t] && s === this.remove ? delete this._functions[t] : this._pausedDirty = !0
            }, o.remove = function(t) {
                var e = this;
                this.forEachMatchingKey(t, (function(t) {
                    delete e._functions[t]
                }))
            }, o.forEachMatchingKey = function(t, e) {
                for (var i in this._functions) {
                    var r = this._functions[i];
                    this.key1IncludesKey2(t, i) && e(i, r)
                }
            }, o.latency = function(t) {
                if (null == t) return this._latency;
                this._latency = t
            }, o.interval = function(t, e) {
                if (null == e) return this._functions[t].interval;
                null == this._functions[t] ? n.notice("setting interval of ", t, "to", e, "failed because", t, "is not defined") : this._functions[t].interval = e
            }, o.pause = function(t) {
                this._paused[t] = !0, this._pausedDirty = !0
            }, o.unpause = function(t) {
                this._paused[t] = !1, this._pausedDirty = !0
            }, o.isPaused = function(t) {
                for (var e in this.paused) {
                    if (this._paused[e] && this.key1IncludesKey2(e, t)) return !0
                }
                return !1
            }, o.updatePaused = function() {
                for (var t in this._functions) {
                    this._functions[t].paused = this.isPaused(t)
                }
                this._pausedDirty = !1
            }, o.key1IncludesKey2 = function(t, e) {
                return "function" == typeof e.indexOf && 0 === e.indexOf(t) && (e.length === t.length || "." === e.charAt(t.length))
            }, o.blur = function() {
                this._blurred || (this._blurred = !0, this._savedLatency = this._latency, this._latency = this._blurLatency)
            }, o.focus = function() {
                this._blurred && (this._blurred = !1, this._latency = this._savedLatency, this.resync())
            }, null == s.Wistia.eventLoop && (s.Wistia.eventLoop = new a({
                latency: 100,
                blurLatency: 100
            }));
            var l = s.Wistia.eventLoop
        },
        14: (t, e, i) => {
            i.d(e, {
                globalTrigger: () => s
            });
            var r = i(3);
            (0, i(15).makeWbindable)(r.Wistia);
            r.Wistia.bind.bind(r.Wistia), r.Wistia.on.bind(r.Wistia), r.Wistia.off.bind(r.Wistia), r.Wistia.rebind.bind(r.Wistia);
            var s = r.Wistia.trigger.bind(r.Wistia);
            r.Wistia.unbind.bind(r.Wistia)
        },
        21: (t, e, i) => {
            i.d(e, {
                EMBED_HOST: () => l,
                PROD_EMBED_HOST: () => h,
                PROD_FASTLY_SSL_HOST: () => f,
                PROD_FAST_HOSTNAME_COM: () => c,
                PROD_FAST_HOSTNAME_NET: () => u,
                PROD_SSL_EMBED_HOST: () => d,
                SSL_EMBED_HOST: () => g,
                TAGGED_VERSION: () => m,
                cdnFastProtectedWistiaComHost: () => T,
                cdnFastWistiaComHost: () => y,
                cdnFastWistiaNetHost: () => E,
                deliveryHost: () => v,
                eV1HostWithPort: () => A,
                eV1Protocol: () => L,
                mediaDataHost: () => k,
                metricsHost: () => R
            });
            var r = i(4),
                s = i(22),
                n = i(23),
                a = ((0, n.appHostname)("app"), (0, n.appHostname)("fast-protected")),
                o = (0, n.appHostname)("fast"),
                l = "embed.wistia.com",
                u = "fast.wistia.net",
                c = "fast.wistia.com",
                h = "embed.wistia.com",
                d = "embed-ssl.wistia.com",
                f = "embed-fastly.wistia.com",
                g = "embed-ssl.wistia.com",
                m = "",
                p = "undefined" != typeof window && r.root === window && r.root.location ? r.root.location.protocol : "https:",
                v = function() {
                    return function(t, e, i) {
                        return "https:" === t ? e : i
                    }(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : p, g, l)
                },
                y = function(t) {
                    return t || o
                },
                T = function(t) {
                    return t || a
                },
                E = function() {
                    return "fast.".concat("wistia.net")
                },
                S = function() {
                    for (var t = document.getElementsByTagName("script"), e = 0; e < t.length; e++) {
                        var i = t[e];
                        if (i.src) {
                            var r = new s.Url(i.src),
                                n = /\/assets\/external\/E-v1?\.js$/.test(r.rawPath),
                                a = r.host === y() || r.host === E() || "fast-canary.wistia.net" === r.host,
                                o = "https:" === location.protocol && "https:" === r.protocol,
                                l = "" === r.protocol || null == r.protocol,
                                u = o || l || "http:" === location.protocol,
                                c = !i.readyState || /loaded|complete/.test(i.readyState);
                            if (n && a && u && c) return r
                        }
                    }
                    return new s.Url("".concat((0, s.proto)(), "//").concat(E(), "/E-v1.js"))
                }(),
                b = function() {
                    return S.host
                },
                A = function() {
                    return S.port ? "".concat(b(), ":").concat(S.port) : b()
                },
                L = function() {
                    return S.protocol
                },
                k = function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return t.embedHost ? D(t.embedHost) : A()
                },
                R = function() {
                    return "pipedream.".concat("wistia.com")
                },
                w = [].concat(["wistia.net", "wistia.com"], ["wistia.mx", "wistia.dev", "wistia.tech", "wistia.am", "wistia.se", "wistia.io", "wistia.st"]),
                _ = new RegExp("(".concat(w.map((function(t) {
                    return "\\.".concat(t.replace(".", "\\."))
                })).join("|"), ")$")),
                D = function(t) {
                    return t && _.test(t) ? t : A()
                }
        },
        91: (t, e, i) => {
            i.d(e, {
                setOrGet: () => a
            });
            var r = i(3),
                s = i(33),
                n = i(6);
            r.Wistia._localStorage || (r.Wistia._localStorage = (0, s.getWistiaLocalStorage)());
            var a = function(t, e) {
                if (null != e) {
                    var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2] ? n.unsetDeep : n.setDeep;
                    return r.Wistia._localStorage = (0, s.updateWistiaLocalStorage)((function(r) {
                        return i(r, t, e)
                    })), e
                }
                return null != t ? (0, n.getDeep)(r.Wistia._localStorage, t) : r.Wistia._localStorage
            };
            s.removeWistiaLocalStorage
        },
        29: (t, e, i) => {
            i.d(e, {
                mediaDataTransforms: () => c
            });
            var r = i(6),
                s = i(22),
                n = i(11),
                a = i(30);

            function o(t) {
                return function(t) {
                    if (Array.isArray(t)) return l(t)
                }(t) || function(t) {
                    if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                }(t) || function(t, e) {
                    if (t) {
                        if ("string" == typeof t) return l(t, e);
                        var i = {}.toString.call(t).slice(8, -1);
                        return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? l(t, e) : void 0
                    }
                }(t) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function l(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for (var i = 0, r = Array(e); i < e; i++) r[i] = t[i];
                return r
            }
            var u = (0, n.cachedDetect)(),
                c = function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        i = (0, r.assign)({}, t);
                    return i = function(t) {
                        if (!0 !== (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).allowOriginalAsMp4) return t;
                        var e = t.assets.filter((function(t) {
                            return "original" === t.type
                        }))[0];
                        return (0, a.readyPublicOver400)(t.assets).length > 0 || (t.assets = [].concat(o(t.assets), [(0, r.assign)({}, e, {
                            display_name: "".concat(e.display_name, " copy"),
                            container: "mp4",
                            codec: "h264",
                            type: "mp4_video"
                        })])), t
                    }(i, e), i = function(t) {
                        return t.assets && u.webp && (t.assets = t.assets.map((function(t) {
                            if ("still_image" === t.type && Object(t).url) {
                                var e = new s.Url(t.url);
                                e.ext("webp"), t.url = e.absolute()
                            }
                            return t
                        }))), t
                    }(i), i
                }
        },
        25: (t, e, i) => {
            i.d(e, {
                fetchFreshMediaDataJson: () => n
            });
            i(4), i(3), i(6);
            var r = i(13),
                s = (i(19), i(26), i(21));
            i(29), i(31);
            var n = function(t, e) {
                    var i = a(t, e);
                    return fetch(i).then((function(t) {
                        return t.json()
                    })).catch((function(t) {
                        r.wlog.error("error fetching mediaData", t)
                    }))
                },
                a = function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        i = (0, s.mediaDataHost)(e);
                    return "".concat((0, s.eV1Protocol)(), "//").concat(i, "/embed/medias/").concat(t, ".json")
                }
        },
        90: (t, e, i) => {
            i.d(e, {
                count: () => g,
                sample: () => m
            });
            var r = i(3),
                s = i(67),
                n = i(13),
                a = i(6),
                o = i(5),
                l = i(22),
                u = i(21),
                c = i(32);
            r.Wistia;
            null == r.Wistia._metricsCache && (r.Wistia._metricsCache = {});
            var h = r.Wistia._metricsCache,
                d = function(t, e, i) {
                    var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                    try {
                        null == h.toMput && (h.toMput = []), null == h.requestId && (h.requestId = 0);
                        var l = (0, a.merge)({
                                type: t,
                                key: e,
                                value: null != i ? i : null,
                                request_id: h.requestId
                            }, r),
                            u = JSON.stringify(l);
                        n.wlog.debug("send metrics", u), h.toMput.push(u), (0, s.doTimeout)("metrics.debounce", (function() {
                            (0, o.pageLoaded)((function() {
                                f.apply(undefined, h.toMput), h.toMput = [], h.requestId += 1
                            }))
                        }), 500)
                    } catch (t) {
                        n.wlog.error(t)
                    }
                },
                f = function() {
                    if ((0, c.isVisitorTrackingEnabled)()) {
                        for (var t = "".concat((0, l.proto)(), "//").concat((0, u.metricsHost)(), "/mput?topic=metrics"), e = arguments.length, i = new Array(e), r = 0; r < e; r++) i[r] = arguments[r];
                        return fetch(t, {
                            method: "POST",
                            mode: "cors",
                            headers: {
                                "Content-Type": "application/x-www-form-urlencoded"
                            },
                            body: i.join("\n")
                        }).then((function(t) {
                            t.ok || console.error(t)
                        })).catch((function(t) {
                            console.error(t)
                        }))
                    }
                },
                g = function(t) {
                    return d("count", t, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {})
                },
                m = function(t, e, i) {
                    return d("sample", t, e, i)
                }
        },
        34: (t, e, i) => {
            i.d(e, {
                getLocalStorage: () => l,
                removeLocalStorage: () => u,
                setLocalStorage: () => c,
                updateLocalStorage: () => h
            });
            var r = i(3),
                s = function(t) {
                    setTimeout((function() {
                        throw t
                    }), 0)
                },
                n = "_namespacedLocalStorage",
                a = function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "wistia-test-localstorage";
                    if (null != r.Wistia._localStorageWorks) return r.Wistia._localStorageWorks;
                    try {
                        var e = localStorage.getItem(t);
                        localStorage.removeItem(t), localStorage.setItem(t, e), localStorage.removeItem(t), r.Wistia._localStorageWorks = !0
                    } catch (t) {
                        r.Wistia._localStorageWorks = !1
                    }
                    return r.Wistia._localStorageWorks
                },
                o = function() {
                    return null == r.Wistia[n] && (r.Wistia[n] = {}), r.Wistia[n]
                },
                l = function(t) {
                    if (!a()) return o()[t] || {};
                    if (localStorage[t]) try {
                        return "null" === localStorage[t] ? {} : JSON.parse(localStorage[t])
                    } catch (t) {
                        s(t)
                    }
                    return {}
                },
                u = function(t) {
                    if (a()) try {
                        localStorage.removeItem(t)
                    } catch (t) {
                        s(t)
                    } else o()[t] = {}
                },
                c = function(t, e) {
                    if (!a()) return null != e && "object" == typeof e && (o()[t] = e), e;
                    try {
                        o()[t] = e, localStorage[t] = JSON.stringify(e)
                    } catch (t) {
                        s(t)
                    }
                    return e
                },
                h = function(t, e) {
                    var i = l(t);
                    try {
                        e(i)
                    } catch (t) {
                        s(t)
                    }
                    return c(t, i)
                }
        },
        6: (t, e, i) => {
            i.d(e, {
                assign: () => r.assign,
                cast: () => p,
                clone: () => c,
                eachLeaf: () => M,
                except: () => E,
                filter: () => L,
                getDeep: () => h,
                isArray: () => R,
                isEmpty: () => P,
                isObject: () => _,
                merge: () => a,
                only: () => T,
                select: () => S,
                setAndPreserveUndefined: () => f,
                setDeep: () => d,
                sort: () => A,
                unsetDeep: () => m
            });
            var r = i(7),
                s = function(t, e) {
                    if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                    return Object.prototype.hasOwnProperty.call(Object(t), e)
                },
                n = Array.prototype.slice,
                a = function(t) {
                    if (0 == (arguments.length <= 1 ? 0 : arguments.length - 1)) return t;
                    for (var e = 0; e < (arguments.length <= 1 ? 0 : arguments.length - 1); e++) o(t, e + 1 < 1 || arguments.length <= e + 1 ? void 0 : arguments[e + 1]);
                    return t
                },
                o = function(t, e) {
                    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : l,
                        r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : u;
                    if (R(e)) {
                        R(t) || (t = []);
                        for (var n = 0; n < e.length; n++) {
                            var a = e[n];
                            null == t[n] && null != a && (R(a) ? t[n] = [] : _(a) && (t[n] = {}));
                            var c = o(t[n], a, i);
                            r(e, n, c) ? delete t[n] : t[n] = c
                        }
                        return i(t)
                    }
                    if (_(e)) {
                        for (var h in e)
                            if (s(e, h) && (s(t, h) || null == t[h])) {
                                var d = e[h];
                                R(d) ? (R(t[h]) || (t[h] = []), o(t[h], d, i), t[h] = i(t[h])) : _(d) ? (_(t[h]) || (t[h] = {}), o(t[h], d, i), t[h] = i(t[h])) : null == t ? (t = {}, r(e, h, d) || (t[h] = i(d))) : r(e, h, d) ? delete t[h] : t[h] = i(d)
                            }
                        return i(t)
                    }
                    return i(e)
                },
                l = function(t) {
                    return t
                },
                u = function(t, e, i) {
                    return null == i
                },
                c = function(t, e) {
                    return R(t) ? o([], t, e) : o({}, t, e)
                },
                h = function(t, e, i) {
                    e = "string" == typeof e ? e.split(".") : n.call(e);
                    for (var r, a = t; null != t && e.length;) {
                        var o = e.shift();
                        void 0 !== t[o] && (_(t[o]) || R(t[o])) || !i || (0 === o ? (t = a[r] = [])[o] = {} : t[o] = {}), a = t, r = o, t = s(t, o) ? t[o] : void 0
                    }
                    return t
                },
                d = function(t, e, i) {
                    return g(t, e, i, !0)
                },
                f = function(t, e, i) {
                    return g(t, e, i, !1)
                },
                g = function(t, e, i) {
                    var r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                        s = (e = "string" == typeof e ? e.split(".") : n.call(e)).pop();
                    null != (t = h(t, e, !0)) && (_(t) || R(t)) && null != s && (r && null == i ? delete t[s] : t[s] = i)
                },
                m = function(t, e) {
                    return d(t, e)
                },
                p = function(t) {
                    return null == t ? t : _(t) || R(t) ? y(t) : v("".concat(t), t)
                },
                v = function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t;
                    return /^-?[1-9]\d*?$/.test(t) ? parseInt(t, 10) : "0" === t || "-0" === t ? 0 : /^-?\d*\.\d+$/.test(t) ? parseFloat(t) : !!/^true$/i.test(t) || !/^false$/i.test(t) && e
                },
                y = function(t) {
                    return o(t, t, (function(t) {
                        return "string" == typeof t ? v(t) : t
                    }), (function() {
                        return !1
                    }))
                },
                T = function(t, e) {
                    for (var i = {}, r = {}, s = 0; s < e.length; s++) r[e[s]] = !0;
                    for (var n in t) r[n] && (i[n] = t[n]);
                    return i
                },
                E = function(t, e) {
                    for (var i = {}, r = {}, s = 0; s < e.length; s++) r[e[s]] = !0;
                    for (var n in t) r[n] || (i[n] = t[n]);
                    return i
                },
                S = function(t, e) {
                    for (var i = [], r = "function" == typeof e, s = r ? e : null, n = 0; n < t.length; n++) {
                        var a = t[n];
                        if (r) s(a) && i.push(a);
                        else {
                            var o = !0;
                            for (var l in e) {
                                var u = e[l];
                                if (u instanceof Array) {
                                    if (!a[l] || a[l] < u[0] || a[l] > u[1]) {
                                        o = !1;
                                        break
                                    }
                                } else if (u instanceof RegExp) {
                                    if (!u.test(a[l])) {
                                        o = !1;
                                        break
                                    }
                                } else if (u instanceof b) {
                                    for (var c = !1, h = 0; h < u.values.length; h++) {
                                        var d = u.values[h];
                                        if (a[l] === d) {
                                            c = !0;
                                            break
                                        }
                                    }
                                    if (!c) {
                                        o = !1;
                                        break
                                    }
                                } else if ("function" == typeof u) {
                                    if (null == a[l] || !u(a[l])) {
                                        o = !1;
                                        break
                                    }
                                } else if (a[l] !== u) {
                                    o = !1;
                                    break
                                }
                            }
                            o && i.push(a)
                        }
                    }
                    return i
                },
                b = function(t) {
                    var e = this;
                    return e.values = t, e
                },
                A = function(t, e) {
                    var i = "function" == typeof e,
                        r = i ? e : null,
                        s = n.call(t);
                    return i ? s.sort(r) : s.sort((function(t, i) {
                        var r;
                        r = e instanceof Array ? c(e) : e.split(/\s*,\s*/);
                        for (var s = 0; 0 === s && r.length > 0;) {
                            var n = r.shift().split(/\s+/),
                                a = n[0],
                                o = n[1];
                            if (o = "desc" === o ? -1 : 1, t[a] < i[a]) {
                                s = -1 * o;
                                break
                            }
                            if (t[a] !== i[a]) {
                                s = 1 * o;
                                break
                            }
                            s = 0
                        }
                        return s
                    })), s
                },
                L = function(t, e, i) {
                    for (var r = void 0 === i ? undefined : i, s = [], n = 0; n < t.length; n++) e.call(r, t[n], n, t) && s.push(t[n]);
                    return s
                },
                k = /^\s*function Array()/,
                R = function(t) {
                    return null != t && t.push && k.test(t.constructor)
                },
                w = /^\s*function Object()/,
                _ = function(t) {
                    return null != t && "object" == typeof t && w.test(t.constructor)
                },
                D = /^\s*function RegExp()/,
                C = /^string|number|boolean|function$/i,
                I = function(t) {
                    return null != t && (C.test(typeof t) || function(t) {
                        return null != t && D.test(t.constructor)
                    }(t))
                },
                P = function(t) {
                    return null == t || (!(!R(t) || t.length) || !!_(t) && !Object.keys(t).length)
                },
                x = function(t, e, i, r, a) {
                    if (null == i && (i = []), I(t)) e(t, i, r, a);
                    else if (_(t) || R(t)) {
                        for (var o in e(t, i, r, a), t)
                            if (s(t, o)) {
                                var l = n.call(i);
                                l.push(o), x(t[o], e, l, t, o)
                            }
                    } else e(t, i, r, a)
                },
                M = function(t, e) {
                    x(t, (function(t, i, r, s) {
                        R(t) || _(t) || e(t, i, r, s)
                    }))
                }
        },
        10: (t, e, i) => {
            i.d(e, {
                pageLoaded: () => r
            });
            var r = function(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4e3,
                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : document,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : window;
                if (/loaded|complete/.test(i.readyState)) setTimeout(t, 0);
                else {
                    var s = function() {
                            r.removeEventListener("load", n, !1)
                        },
                        n = function() {
                            clearTimeout(a), s(), t()
                        };
                    r.addEventListener("load", n, !1);
                    var a = setTimeout((function() {
                        s(), t()
                    }), e)
                }
            }
        },
        237: (t, e, i) => {
            i.d(e, {
                PLAYER_VERSION: () => r
            });
            var r = "main"
        },
        9: (t, e, i) => {
            i.d(e, {
                poll: () => r
            });
            var r = function(t, e, i, r, s) {
                var n = null,
                    a = (new Date).getTime(),
                    o = function() {
                        (new Date).getTime() - a > r ? "function" == typeof s && s() : t() ? e() : (clearTimeout(n), n = setTimeout(o, i))
                    };
                n = setTimeout(o, 1)
            }
        },
        4: (t, e, i) => {
            var r;
            i.d(e, {
                root: () => s
            });
            try {
                (r = self).self !== r && void 0 !== r.self && "undefined" != typeof window && (r = window)
            } catch (t) {
                r = "undefined" != typeof globalThis ? globalThis : window
            }
            var s = r
        },
        20: (t, e, i) => {
            i.d(e, {
                runScript: () => s
            });
            var r = i(21),
                s = function(t, e) {
                    var i = r.TAGGED_VERSION;
                    return new Promise((function(r, s) {
                        var n;
                        null == e && (e = 8e3), (n = document.createElement("script")).src = t, n.async = !0, n.type = "text/javascript", /https?:\/\/fast\.wistia\./.test(n.src) && "" !== i && i.length > 0 && (n.src = "".concat(n.src, "@").concat(i));
                        var a = null,
                            o = !1,
                            l = function() {
                                n.onerror = n.onreadystatechange = n.onload = null, clearTimeout(a), clearTimeout(c), a = setTimeout((function() {
                                    n && n.parentNode && n.parentNode.removeChild(n)
                                }), 500)
                            },
                            u = function() {
                                var t = n.readyState;
                                o || t && !/loaded|complete/.test(t) || (o = !0, setTimeout((function() {
                                    r(), l()
                                }), 1))
                            },
                            c = setTimeout((function() {
                                o = !0, l(), s(new Error("timeout"))
                            }), e);
                        n.onerror = function(t) {
                            o = !0, l(), s(t)
                        }, n.onreadystatechange = u, n.onload = u, (document.body || document.head).appendChild(n)
                    }))
                }
        },
        18: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
            __webpack_require__.d(__webpack_exports__, {
                execScriptTags: () => execScriptTags,
                getScriptTags: () => getScriptTags,
                removeScriptTags: () => removeScriptTags
            });
            var utilities_script_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19),
                getScriptTags = function(t) {
                    return t.match(/<script.*?src[^>]*>\s*<\/script>|<script.*?>[\s\S]+?<\/script>/gi) || []
                },
                scriptTagsToRunScriptsInput = function scriptTagsToRunScriptsInput(scriptTags) {
                    if (!scriptTags) return [];
                    scriptTags instanceof Array || (scriptTags = getScriptTags(scriptTags));
                    for (var hashes = [], _loop = function _loop() {
                            var scriptTag = scriptTags[i],
                                hash = {},
                                matches = scriptTag.match(/<script.*?>/i);
                            if (matches && (matches = matches[0].match(/src="([^"]+)"/i), matches && (hash.src = matches[1], hash.async = /async/i.test(scriptTag.replace(hash.src, "")))), !matches && (matches = scriptTag.match(/<script>([\s\S]+?)<\/script>/i), matches)) {
                                var src = matches[1];
                                hash.fn = function() {
                                    return eval(src)
                                }
                            }
                            hashes.push(hash)
                        }, i = 0; i < scriptTags.length; i++) _loop();
                    return hashes
                },
                execScriptTags = function(t, e) {
                    if (!t) return null;
                    var i = scriptTagsToRunScriptsInput(t);
                    return (0, utilities_script_utils_js__WEBPACK_IMPORTED_MODULE_0__.runScripts)(i).then(e)
                },
                removeScriptTags = function(t) {
                    return t.replace(/<script.*?src[^>]*>\s*<\/script>|<script>[\s\S]+?<\/script>/g, "")
                }
        },
        19: (t, e, i) => {
            i.d(e, {
                removeScriptsBySrc: () => u,
                runScripts: () => h
            });
            var r = i(13),
                s = i(6),
                n = i(20);

            function a(t, e) {
                var i = Object.keys(t);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(t);
                    e && (r = r.filter((function(e) {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                    }))), i.push.apply(i, r)
                }
                return i
            }

            function o(t, e, i) {
                return (e = function(t) {
                    var e = function(t, e) {
                        if ("object" != typeof t || !t) return t;
                        var i = t[Symbol.toPrimitive];
                        if (void 0 !== i) {
                            var r = i.call(t, e || "default");
                            if ("object" != typeof r) return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return ("string" === e ? String : Number)(t)
                    }(t, "string");
                    return "symbol" == typeof e ? e : e + ""
                }(e)) in t ? Object.defineProperty(t, e, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = i, t
            }
            var l = function(t) {
                    for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = document.getElementsByTagName("script"), r = 0; r < i.length; r++) {
                        var s = i[r],
                            n = s.getAttribute("src") || "";
                        if (e.ignoreQueryParams) {
                            var a = n.split("?");
                            n = a[0]
                        }
                        if (!e.scriptRegex && e.ignoreProtocol && (n = n.replace(/^https?:/, ""), t = t.replace(/^https?:/, "")), e.scriptRegex && e.scriptRegex.test(n)) return s;
                        if (e.testStartsWith && 0 === n.indexOf(t)) return s;
                        if (n === t) return s
                    }
                    return null
                },
                u = function(t) {
                    for (var e, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = function() {
                            if (e && (e.onload = e.onreadystatechange = e.onerror = null, e.parentNode && (e.parentNode.removeChild, 1))) try {
                                e.parentNode.removeChild(e)
                            } catch (t) {
                                setTimeout((function() {
                                    throw t
                                }), 0)
                            }
                        }; e = l(t, i);) r()
                },
                c = function(t) {
                    var e, i, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 8e3,
                        s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    return null == r && (r = 8e3), null == s && (s = {}), new Promise((function(a) {
                        !0 === s.once && (e = l(t)) && (i = !0), s.once && i ? e.readyState && !/loaded|complete/.test(e.readyState) || setTimeout((function() {
                            a()
                        }), 1) : (0, n.runScript)(t, r).then(a).catch((function(t) {
                            a(t), setTimeout((function() {
                                console.error(t)
                            }), 1)
                        }))
                    }))
                },
                h = function() {
                    for (var t, e = arguments.length, i = new Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                    t = i[0] instanceof Array ? i[0] : i, t = d(t);
                    var n = [],
                        l = [],
                        u = [];
                    return t.forEach((function(t) {
                        var e = function(t) {
                                for (var e = 1; e < arguments.length; e++) {
                                    var i = null != arguments[e] ? arguments[e] : {};
                                    e % 2 ? a(Object(i), !0).forEach((function(e) {
                                        o(t, e, i[e])
                                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : a(Object(i)).forEach((function(e) {
                                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
                                    }))
                                }
                                return t
                            }({}, t),
                            i = new Promise((function(t) {
                                e.resolve = t
                            }));
                        e.promise = i, u.push(e.promise), t.async ? n.push(e) : l.push(e)
                    })), l.reduce((function(t, e) {
                        if (e.fn) try {
                            e.fn()
                        } catch (t) {
                            r.wlog.error(t)
                        } finally {
                            e.resolve()
                        } else e.src && c(e.src, null, e).then(e.resolve);
                        return t.then(e.promise)
                    }), Promise.resolve()), setTimeout((function() {
                        n.forEach((function(t) {
                            if (t.fn) try {
                                t.fn()
                            } catch (t) {
                                r.wlog.error(t)
                            } finally {
                                t.resolve()
                            } else t.src && c(t.src, null, t).then(t.resolve)
                        }))
                    }), 1), Promise.all(u)
                },
                d = function(t) {
                    for (var e = [], i = 0; i < t.length; i++) {
                        var r = t[i];
                        "string" == typeof r ? e.push({
                            src: r,
                            async: !1
                        }) : (0, s.isObject)(r) ? e.push(r) : e.push({
                            fn: r,
                            async: !1
                        })
                    }
                    return e
                }
        },
        24: (t, e, i) => {
            i.d(e, {
                seqId: () => s
            });
            var r = i(3),
                s = function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "wistia_",
                        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                        i = r.Wistia._sequenceVal || 1,
                        s = "".concat(t).concat(i).concat(e);
                    return r.Wistia._sequenceVal = i + 1, s
                }
        },
        31: (t, e, i) => {
            i.d(e, {
                countMetric: () => u
            });
            var r = i(3),
                s = i(7),
                n = i(10),
                a = i(32),
                o = i(21);
            null == r.Wistia._simpleMetricsCache && (r.Wistia._simpleMetricsCache = {}), null == r.Wistia._simpleMetricsDebounceInterval && (r.Wistia._simpleMetricsDebounceInterval = 500);
            var l = r.Wistia._simpleMetricsCache,
                u = function(t) {
                    return h("count", t, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {})
                },
                c = function() {
                    if ((0, a.isVisitorTrackingEnabled)()) {
                        for (var t = "https://".concat((0, o.metricsHost)(), "/mput?topic=metrics"), e = arguments.length, i = new Array(e), r = 0; r < e; r++) i[r] = arguments[r];
                        return fetch(t, {
                            method: "POST",
                            mode: "cors",
                            headers: {
                                "Content-Type": "application/x-www-form-urlencoded"
                            },
                            body: i.join("\n")
                        }).then((function(t) {
                            t.ok || console.error(t)
                        })).catch((function(t) {
                            console.error(t)
                        }))
                    }
                },
                h = function(t, e, i) {
                    var o, u = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                    if ((0, a.isVisitorTrackingEnabled)()) try {
                        null == l.toMput && (l.toMput = []);
                        var h = (0, s.assign)({
                                type: t,
                                key: e,
                                value: null != i ? i : null
                            }, u),
                            d = JSON.stringify(h, (o = new WeakSet, function(t, e) {
                                if ("object" == typeof e && null !== e) {
                                    if (o.has(e)) return "[Circular]";
                                    o.add(e)
                                }
                                return e
                            }));
                        l.toMput.push(d), clearTimeout(r.Wistia._msendTimeout), r.Wistia._msendTimeout = setTimeout((function() {
                            (0, n.pageLoaded)((function() {
                                c.apply(undefined, l.toMput), l.toMput = []
                            }))
                        }), r.Wistia._simpleMetricsDebounceInterval)
                    } catch (t) {
                        console.error(t.message), console.error(t.stack)
                    }
                }
        },
        67: (t, e, i) => {
            i.d(e, {
                clearTimeouts: () => a,
                doTimeout: () => n
            });
            var r = i(3),
                s = i(6);
            r.Wistia;
            null == r.Wistia._timeouts && (r.Wistia._timeouts = {});
            var n = function(t, e) {
                    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                    (0, s.isArray)(t) && (t = t.join("."));
                    var n = l(t);
                    if (a(t, n), e) {
                        var o = r.Wistia._timeouts[n];
                        null == o && (o = r.Wistia._timeouts[n] = {});
                        var u = setTimeout((function() {
                            delete o[t], e()
                        }), i);
                        return o[t] = u, u
                    }
                    return r.Wistia._timeouts[n][t]
                },
                a = function(t) {
                    var e, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                    if ((0, s.isArray)(t) && (t = t.join(".")), "__global__" === (i = i || l(t)) && (e = r.Wistia._timeouts[t]))
                        for (var n in e) {
                            var a = e[n];
                            clearTimeout(a), delete e[n]
                        }
                    if (e = r.Wistia._timeouts[i])
                        for (var u in e) {
                            var c = e[u];
                            !u.indexOf || 0 !== u.indexOf(t) || u.length !== t.length && "." !== u.charAt(t.length) || (clearTimeout(c), delete e[u])
                        }
                    r.Wistia.blockSweepTimeouts || (r.Wistia.blockSweepTimeouts = !0, setTimeout(o, 0), setTimeout((function() {
                        r.Wistia.blockSweepTimeouts = !1
                    }), 5e3))
                },
                o = function() {
                    for (var t in r.Wistia._timeouts) {
                        var e = r.Wistia._timeouts[t];
                        (0, s.isEmpty)(e) && delete r.Wistia._timeouts[t]
                    }
                },
                l = function(t) {
                    var e = t.indexOf(".");
                    return e > 0 ? t.substring(0, e) : "__global__"
                }
        },
        32: (t, e, i) => {
            i.d(e, {
                isVisitorTrackingEnabled: () => h
            });
            var r = i(3),
                s = i(14),
                n = i(33),
                a = i(35);

            function o(t) {
                return function(t) {
                    if (Array.isArray(t)) return l(t)
                }(t) || function(t) {
                    if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                }(t) || function(t, e) {
                    if (t) {
                        if ("string" == typeof t) return l(t, e);
                        var i = {}.toString.call(t).slice(8, -1);
                        return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? l(t, e) : void 0
                    }
                }(t) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function l(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for (var i = 0, r = Array(e); i < e; i++) r[i] = t[i];
                return r
            }
            var u;
            r.Wistia._visitorTrackingDomain || (r.Wistia._visitorTrackingDomain = location.hostname || ""), r.Wistia._visitorTracking || (null != (u = (0, n.getWistiaLocalStorage)().visitorTrackingEnabled) && ((0, n.updateWistiaLocalStorage)((function(t) {
                return delete t.visitorTrackingEnabled
            })), r.Wistia._visitorTracking = {}, r.Wistia._visitorTracking[r.Wistia._visitorTrackingDomain] = {
                isEnabled: u,
                updatedAt: Date.now()
            }, (0, n.updateWistiaLocalStorage)((function(t) {
                return t.visitorTracking = r.Wistia._visitorTracking
            }))), r.Wistia._visitorTracking = (0, n.getWistiaLocalStorage)().visitorTracking || {});
            r.Wistia.consent = function(t) {
                return null == t ? h() : c(t)
            };
            var c = function(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : r.Wistia._visitorTrackingDomain;
                    "default" === t ? delete r.Wistia._visitorTracking[e] : r.Wistia._visitorTracking[e] = {
                        isEnabled: "true" === "".concat(t),
                        updatedAt: Date.now()
                    }, (0, n.updateWistiaLocalStorage)((function(t) {
                        return t.visitorTracking = r.Wistia._visitorTracking
                    })), (0, s.globalTrigger)("visitortrackingchange", t), o(document.getElementsByTagName("wistia-player")).forEach((function(e) {
                        e.dispatchEvent(new CustomEvent("visitor-tracking-change", {
                            detail: {
                                isTrackingEnabled: t
                            }
                        }))
                    }))
                },
                h = function() {
                    if ("boolean" == typeof r.Wistia._visitorTracking) return r.Wistia._visitorTracking;
                    if (r.Wistia._visitorTracking) {
                        var t = function() {
                            if (r.Wistia._visitorTrackingDomain)
                                for (var t = r.Wistia._visitorTrackingDomain.split("."); t.length > 0;) {
                                    var e = r.Wistia._visitorTracking[t.join(".")],
                                        i = e && e.isEnabled;
                                    if (null != i) return i;
                                    t.shift()
                                }
                        }();
                        if (null != t) return Boolean(t)
                    }
                    var e = (0, a.getAllApiHandles)();
                    if (r.Wistia.channel && r.Wistia.channel.all) try {
                        e.push.apply(e, o(r.Wistia.channel.all()))
                    } catch (t) {}
                    return !e.some((function(t) {
                        return !0 === (t._mediaData || t._galleryData || {}).privacyMode
                    }))
                }
        },
        22: (t, e, i) => {
            i.d(e, {
                Url: () => c,
                proto: () => n
            });
            var r = i(6),
                s = i(13),
                n = function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : location.href;
                    return /^http:\/\//.test(t) ? "http:" : "https:"
                },
                a = function(t) {
                    if (null == t) return t;
                    var e;
                    try {
                        e = decodeURIComponent(t)
                    } catch (i) {
                        setTimeout((function() {
                            s.wlog.notice(i)
                        }), 50), e = t
                    }
                    return e
                },
                o = function(t) {
                    for (var e = t[0], i = 1; i < t.length; i++) e += "[".concat(t[i], "]");
                    return e
                },
                l = function(t) {
                    return t.match(/([\w\-_]+)/g)
                },
                u = ["protocol", "host", "port", "params", "path"],
                c = function(t) {
                    var e = this;
                    return e.params = {}, e.path = [], e.host = "", "object" == typeof t ? e.fromOptions(t) : t && e.fromRaw(t), e
                },
                h = c.prototype;
            h.fromOptions = function(t) {
                for (var e = 0; e < u.length; e++) {
                    var i = u[e];
                    null != t[i] && (this[i] = t[i])
                }
                return this
            }, h.fromRaw = function(t) {
                var e;
                return this.rawUrl = t, (e = t.match(/^((?:https?:)|(?:file:)|(?:ftp:))?\/\//)) && (this.protocol = e[1] || void 0), (e = t.match(/\/\/([^:?#/]*)/)) && (this.host = e[1] || void 0), (e = t.match(/\/\/.*?(\/[^?#$]+)/) || t.match(/(^\/[^/][^?#$]+)/)) && this.setPath(e[1]), (e = t.match(/:(\d+)/)) && (this.port = parseInt(e[1], 10)), (e = t.match(/\?([^#]+)/)) && (this.rawParams = e[1], this.params = function(t) {
                    var e = {};
                    if (!t) return e;
                    for (var i = t.split("&"), n = function() {
                            var t = i[o].split("="),
                                n = t[0],
                                u = t[1];
                            try {
                                n = l(decodeURIComponent(n)) || ""
                            } catch (t) {
                                setTimeout((function() {
                                    s.wlog.notice(t)
                                }), 50), n = ""
                            }(0, r.cast)(n);
                            var c = (0, r.getDeep)(e, n);
                            if (null != c)
                                if ((0, r.isArray)(c)) c.push(a(u));
                                else {
                                    var h = [c];
                                    h.push(a(u)), (0, r.setAndPreserveUndefined)(e, n, h)
                                }
                            else(0, r.setAndPreserveUndefined)(e, n, a(u))
                        }, o = 0; o < i.length; o++) n();
                    return e
                }(this.rawParams)), (e = t.match(/#(.*)$/)) && (this.anchor = e[1]), this
            }, h.clone = function() {
                return new c({
                    protocol: this.protocol,
                    host: this.host,
                    port: this.port,
                    path: (0, r.clone)(this.path),
                    params: (0, r.clone)(this.params),
                    anchor: this.anchor
                })
            }, h.ext = function(t) {
                if (null != t) {
                    var e = this.ext(),
                        i = this.path.length - 1,
                        r = new RegExp("\\.".concat(e), "g");
                    return e && (this.path[i] = "".concat(this.path[i].replace(r, ""))), this.path[i] = "".concat(this.path[i], ".").concat(t)
                }
                var s = this.path[this.path.length - 1].match(/\.(.*)$/);
                return null != s && s[1] || null
            }, h.isRelative = function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window.location,
                    e = this.protocol,
                    i = this.host;
                return !(null != e && "" !== e && e !== t.protocol || i && i !== t.hostname)
            }, h.toString = function() {
                return this.isRelative() ? this.relative() : this.absolute()
            }, h.absolute = function() {
                var t = "";
                null != this.protocol && (t = this.protocol);
                var e = "";
                return null != this.port && (e = ":".concat(this.port)), "".concat(t, "//").concat(this.host || location.host).concat(e).concat(this.relative())
            }, h.relative = function() {
                var t, e = "";
                this.path.length > 0 && ("string" == typeof(t = this.path) && (t = t.split("/")), e = null == t ? "" : "/".concat(t.join("/")), this._hasTrailingSlash && (e += "/"));
                var i, s, n = "?".concat((i = this.params, s = [], (0, r.eachLeaf)(i, (function(t, e) {
                    null != t ? s.push("".concat(encodeURIComponent(o(e)), "=").concat(encodeURIComponent(t))) : s.push(encodeURIComponent(o(e)))
                })), s.join("&")));
                return 1 === n.length && (n = ""), "".concat(e).concat(n).concat(this.relativeAnchor())
            }, h.authority = function() {
                var t = null != this.port ? ":".concat(this.port) : "";
                return "".concat(this.host).concat(t)
            }, h.relativeProtocol = function() {
                var t = "";
                return null != this.port && (t = ":".concat(this.port)), "//".concat(this.host).concat(t).concat(this.relative())
            }, h.relativeAnchor = function() {
                var t = "";
                return null != this.anchor && (t = "#".concat(this.anchor)), "".concat(t)
            }, h.setPath = function(t) {
                this.rawPath = t, this._hasTrailingSlash = /\/$/.test(this.rawPath), this.path = function(t) {
                    var e = [];
                    if (null == t) return e;
                    for (var i = t.split(/\/+/), r = 0; r < i.length; r++) {
                        var s = i[r];
                        null != s && "" !== s && e.push(s)
                    }
                    return e
                }(this.rawPath)
            }, c.create = function(t) {
                return new c(t)
            };
            c.create;
            c.parse = function(t) {
                return new c(t)
            };
            c.parse
        },
        15: (t, e, i) => {
            i.d(e, {
                makeWbindable: () => n
            });
            var r = i(3),
                s = i(16);
            r.Wistia.bindable || (r.Wistia.bindable = {
                bind: function(t, e) {
                    return this.specialBind && !0 === this.specialBind.apply(this, arguments) ? this : e ? (s.bind.call(this, t, e), this) : void(r.Wistia.warn && r.Wistia.warn(this.constructor.name, "bind", "falsey value passed in as callback:", e))
                },
                unbind: function(t, e) {
                    return this.specialUnbind && !0 === this.specialUnbind.apply(this, arguments) || (e ? s.unbind.call(this, t, e) : this._bindings && (this._bindings[t] = []), this._bindings && this._bindings[t] && !this._bindings[t].length && (this._bindings[t] = null, delete this._bindings[t])), this
                },
                on: function(t, e) {
                    var i = this.specialBind && this.specialBind.apply(this, arguments);
                    return "function" == typeof i ? i : s.bind.call(this, t, e)
                },
                off: function(t, e) {
                    var i = this.specialUnbind && this.specialUnbind.apply(this, arguments);
                    return "function" == typeof i ? i : s.unbind.call(this, t, e)
                },
                rebind: function(t, e) {
                    return this.unbind(t, e), this.bind(t, e), this
                },
                trigger: function(t) {
                    for (var e, i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), n = 1; n < i; n++) r[n - 1] = arguments[n];
                    return (e = s.trigger).call.apply(e, [this, t].concat(r)), this
                },
                bindNamed: function() {
                    return s.bindNamed.apply(this, arguments)
                },
                unbindNamed: function() {
                    return s.unbindNamed.apply(this, arguments)
                },
                unbindAllInNamespace: function() {
                    return s.unbindAllInNamespace.apply(this, arguments)
                }
            });
            var n = function(t) {
                for (var e in r.Wistia.bindable) {
                    var i = r.Wistia.bindable[e];
                    t[e] || (t[e] = i)
                }
            }
        },
        37: (t, e, i) => {
            i.d(e, {
                wData: () => n
            });
            var r = i(3),
                s = i(6),
                n = function(t, e) {
                    return (0, s.isArray)(t) || (t = t.split(".")), null != e && (0, s.setDeep)(r.Wistia, ["_data"].concat(t), e), (0, s.getDeep)(r.Wistia, ["_data"].concat(t))
                }
        },
        33: (t, e, i) => {
            i.d(e, {
                getWistiaLocalStorage: () => a,
                removeWistiaLocalStorage: () => o,
                updateWistiaLocalStorage: () => l
            });
            var r = i(3),
                s = i(34),
                n = "wistia",
                a = function() {
                    return (0, s.getLocalStorage)(n)
                },
                o = function() {
                    return r.Wistia._localStorage = (0, s.removeLocalStorage)(n), r.Wistia._localStorage
                },
                l = function(t) {
                    return r.Wistia._localStorage = (0, s.updateLocalStorage)(n, t), r.Wistia._localStorage
                }
        },
        13: (t, e, i) => {
            i.d(e, {
                wlog: () => p
            });
            var r = i(3),
                s = i(14);

            function n(t) {
                return function(t) {
                    if (Array.isArray(t)) return a(t)
                }(t) || function(t) {
                    if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                }(t) || function(t, e) {
                    if (t) {
                        if ("string" == typeof t) return a(t, e);
                        var i = {}.toString.call(t).slice(8, -1);
                        return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? a(t, e) : void 0
                    }
                }(t) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function a(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for (var i = 0, r = Array(e); i < e; i++) r[i] = t[i];
                return r
            }
            var o = {
                    ERROR: 0,
                    WARNING: 1,
                    NOTICE: 2,
                    INFO: 3,
                    DEBUG: 4,
                    error: 0,
                    warning: 1,
                    notice: 2,
                    info: 3,
                    debug: 4
                },
                l = function() {},
                u = function(t) {
                    var e = this;
                    null == t && (t = {});
                    return e.error = function() {
                        for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++) i[r] = arguments[r];
                        return e.log(0, i)
                    }, e.warn = function() {
                        for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++) i[r] = arguments[r];
                        return e.log(1, i)
                    }, e.notice = function() {
                        for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++) i[r] = arguments[r];
                        return e.log(1, i)
                    }, e.info = function() {
                        for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++) i[r] = arguments[r];
                        return e.log(3, i)
                    }, e.debug = function() {
                        for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++) i[r] = arguments[r];
                        return e.log(4, i)
                    }, e.ctx = t, e.ctx.initializedAt || e.reset(), e
                },
                c = u.prototype;
            c.reset = function() {
                this.ctx.level = 0, this.ctx.grep = null, this.ctx.grepv = null, this.ctx.first1000LogLines = [], this.ctx.last1000LogLines = [], this.ctx.initializedAt = (new Date).getTime()
            }, c.setLevel = function(t) {
                var e = this.logFunc(3);
                null != o[t] ? (this.ctx.level = o[t], e('Log level set to "'.concat(t, '" (').concat(o[t], ")"))) : e('Unknown log level "'.concat(t, '"'))
            }, c.setGrep = function(t) {
                this.ctx.grep = t
            }, c.setGrepv = function(t) {
                this.ctx.grepv = t
            }, c.first1000LogLines = function() {
                return this.ctx.first1000LogLines
            }, c.last1000LogLines = function() {
                return this.ctx.last1000LogLines
            }, c.matchedGrep = function(t) {
                var e = !1;
                if (this.ctx.grep || this.ctx.grepv) {
                    for (var i = [], r = 0; r < t.length; r++) try {
                        var s = t[r];
                        i.push(s.toString && s.toString())
                    } catch (t) {
                        i.push("")
                    }
                    var n = i.join(" "),
                        a = !this.ctx.grep || n.match(this.ctx.grep),
                        o = !this.ctx.grepv || !n.match(this.ctx.grepv);
                    e = a && o
                } else e = !0;
                return e
            }, c.now = function() {
                return "undefined" != typeof performance && "function" == typeof performance.now ? performance.now().toFixed(3) : Date.now ? Date.now() - this.ctx.initializedAt : (new Date).getTime() - this.ctx.initializedAt
            }, c.messagesToLogLine = function(t, e, i) {
                var r, s = [t, e];
                s = s.concat(i);
                try {
                    (r = s.join(" ") || "").length > 200 && (r = r.slice(0, 200))
                } catch (t) {
                    r = "could not serialize"
                }
                return r
            }, c.persistLine = function(t) {
                this.ctx.first1000LogLines.length < 1e3 ? this.ctx.first1000LogLines.push(t) : (this.ctx.last1000LogLines.length >= 1e3 && this.ctx.last1000LogLines.shift(), this.ctx.last1000LogLines.push(t))
            }, c.log = function(t, e) {
                var i, r = t <= this.ctx.level,
                    a = t < 4,
                    o = (r || a) && this.matchedGrep(e);
                if (0 === t && (0, s.globalTrigger)("problem", {
                        type: "error-logged",
                        data: {
                            messages: e
                        }
                    }), o && (r || a) && (i = this.now()), a && o) {
                    var l = this.messagesToLogLine(t, i, e);
                    this.persistLine(l)
                }
                if (r && o) {
                    var u, c = this.logFunc(t);
                    1 === e.length && (u = e[0]) instanceof Error ? (c(u.message), u.stack && c(u.stack)) : c.apply(void 0, n(e))
                }
            };
            var h = function() {
                    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                    console.error.apply(console, e)
                },
                d = function() {
                    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                    console.warn.apply(console, e)
                },
                f = function() {
                    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                    console.info.apply(console, e)
                },
                g = function() {
                    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                    console.debug.apply(console, e)
                },
                m = function(t) {
                    console.log.apply(console, t)
                };
            c.logFunc = function(t) {
                return null == t && (t = this.level), console ? (0 === t ? e = h : 1 === t ? e = d : 3 === t ? e = f : 4 === t && (e = g), e || (e = m), "function" != typeof e && (this.noConsoleLog = !0, e = l), e) : l;
                var e
            }, c.maybePrefix = function(t, e) {
                if (t) {
                    if ("function" == typeof t) try {
                        t = t()
                    } catch (e) {
                        t = 'prefix err "'.concat(e.message, '"')
                    }
                    return t instanceof Array ? t.concat(e) : [t].concat(e)
                }
                return e
            }, c.getPrefixedFunctions = function(t) {
                var e = this;
                return {
                    log: function() {
                        for (var i = arguments.length, r = new Array(i), s = 0; s < i; s++) r[s] = arguments[s];
                        return e.log(0, e.maybePrefix(t, r))
                    },
                    error: function() {
                        for (var i = arguments.length, r = new Array(i), s = 0; s < i; s++) r[s] = arguments[s];
                        return e.log(0, e.maybePrefix(t, r))
                    },
                    warn: function() {
                        for (var i = arguments.length, r = new Array(i), s = 0; s < i; s++) r[s] = arguments[s];
                        return e.log(1, e.maybePrefix(t, r))
                    },
                    notice: function() {
                        for (var i = arguments.length, r = new Array(i), s = 0; s < i; s++) r[s] = arguments[s];
                        return e.log(1, e.maybePrefix(t, r))
                    },
                    info: function() {
                        for (var i = arguments.length, r = new Array(i), s = 0; s < i; s++) r[s] = arguments[s];
                        return e.log(3, e.maybePrefix(t, r))
                    },
                    debug: function() {
                        for (var i = arguments.length, r = new Array(i), s = 0; s < i; s++) r[s] = arguments[s];
                        return e.log(4, e.maybePrefix(t, r))
                    }
                }
            }, r.Wistia && null == r.Wistia.wlogCtx && (r.Wistia.wlogCtx = {});
            var p = new u(r.Wistia.wlogCtx)
        },
        3: (t, e, i) => {
            i.d(e, {
                Wistia: () => n
            });
            var r = i(4),
                s = function(t, e) {
                    if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                    return Object.prototype.hasOwnProperty.call(Object(t), e)
                };
            null == r.root.Wistia && (r.root.Wistia = {});
            var n = r.root.Wistia;
            null == n._initializers && (n._initializers = {}), null == n._destructors && (n._destructors = {}), null == n.mixin && (n.mixin = function(t, e) {
                for (var i in e) s(e, i) && (t[i] = e[i])
            }), null == n._remoteData && (n._remoteData = new Map), null == n._mediaDataPromises && (n._mediaDataPromises = {})
        },
        556: (t, e, i) => {
            function r(t) {
                return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
            }
            i.d(e, {
                default: () => qa
            });
            var s, n, a, o, l, u = {
                exports: {}
            };
            s = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, n = /^(?=([^\/?#]*))\1([^]*)$/, a = /(?:\/|^)\.(?=\/)/g, o = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, u.exports = l = {
                buildAbsoluteURL: function(t, e, i) {
                    if (i = i || {}, t = t.trim(), !(e = e.trim())) {
                        if (!i.alwaysNormalize) return t;
                        var r = l.parseURL(t);
                        if (!r) throw new Error("Error trying to parse base URL.");
                        return r.path = l.normalizePath(r.path), l.buildURLFromParts(r)
                    }
                    var s = l.parseURL(e);
                    if (!s) throw new Error("Error trying to parse relative URL.");
                    if (s.scheme) return i.alwaysNormalize ? (s.path = l.normalizePath(s.path), l.buildURLFromParts(s)) : e;
                    var a = l.parseURL(t);
                    if (!a) throw new Error("Error trying to parse base URL.");
                    if (!a.netLoc && a.path && "/" !== a.path[0]) {
                        var o = n.exec(a.path);
                        a.netLoc = o[1], a.path = o[2]
                    }
                    a.netLoc && !a.path && (a.path = "/");
                    var u = {
                        scheme: a.scheme,
                        netLoc: s.netLoc,
                        path: null,
                        params: s.params,
                        query: s.query,
                        fragment: s.fragment
                    };
                    if (!s.netLoc && (u.netLoc = a.netLoc, "/" !== s.path[0]))
                        if (s.path) {
                            var c = a.path,
                                h = c.substring(0, c.lastIndexOf("/") + 1) + s.path;
                            u.path = l.normalizePath(h)
                        } else u.path = a.path, s.params || (u.params = a.params, s.query || (u.query = a.query));
                    return null === u.path && (u.path = i.alwaysNormalize ? l.normalizePath(s.path) : s.path), l.buildURLFromParts(u)
                },
                parseURL: function(t) {
                    var e = s.exec(t);
                    return e ? {
                        scheme: e[1] || "",
                        netLoc: e[2] || "",
                        path: e[3] || "",
                        params: e[4] || "",
                        query: e[5] || "",
                        fragment: e[6] || ""
                    } : null
                },
                normalizePath: function(t) {
                    for (t = t.split("").reverse().join("").replace(a, ""); t.length !== (t = t.replace(o, "")).length;);
                    return t.split("").reverse().join("")
                },
                buildURLFromParts: function(t) {
                    return t.scheme + t.netLoc + t.path + t.params + t.query + t.fragment
                }
            };
            var c = u.exports;

            function h(t, e) {
                var i = Object.keys(t);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(t);
                    e && (r = r.filter((function(e) {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                    }))), i.push.apply(i, r)
                }
                return i
            }

            function d(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var i = null != arguments[e] ? arguments[e] : {};
                    e % 2 ? h(Object(i), !0).forEach((function(e) {
                        g(t, e, i[e])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : h(Object(i)).forEach((function(e) {
                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
                    }))
                }
                return t
            }

            function f(t) {
                var e = function(t, e) {
                    if ("object" != typeof t || !t) return t;
                    var i = t[Symbol.toPrimitive];
                    if (void 0 !== i) {
                        var r = i.call(t, e || "default");
                        if ("object" != typeof r) return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === e ? String : Number)(t)
                }(t, "string");
                return "symbol" == typeof e ? e : String(e)
            }

            function g(t, e, i) {
                return (e = f(e)) in t ? Object.defineProperty(t, e, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = i, t
            }

            function m() {
                return m = Object.assign ? Object.assign.bind() : function(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var i = arguments[e];
                        for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r])
                    }
                    return t
                }, m.apply(this, arguments)
            }
            const p = Number.isFinite || function(t) {
                    return "number" == typeof t && isFinite(t)
                },
                v = Number.isSafeInteger || function(t) {
                    return "number" == typeof t && Math.abs(t) <= y
                },
                y = Number.MAX_SAFE_INTEGER || 9007199254740991;
            let T = function(t) {
                    return t.MEDIA_ATTACHING = "hlsMediaAttaching", t.MEDIA_ATTACHED = "hlsMediaAttached", t.MEDIA_DETACHING = "hlsMediaDetaching", t.MEDIA_DETACHED = "hlsMediaDetached", t.BUFFER_RESET = "hlsBufferReset", t.BUFFER_CODECS = "hlsBufferCodecs", t.BUFFER_CREATED = "hlsBufferCreated", t.BUFFER_APPENDING = "hlsBufferAppending", t.BUFFER_APPENDED = "hlsBufferAppended", t.BUFFER_EOS = "hlsBufferEos", t.BUFFER_FLUSHING = "hlsBufferFlushing", t.BUFFER_FLUSHED = "hlsBufferFlushed", t.MANIFEST_LOADING = "hlsManifestLoading", t.MANIFEST_LOADED = "hlsManifestLoaded", t.MANIFEST_PARSED = "hlsManifestParsed", t.LEVEL_SWITCHING = "hlsLevelSwitching", t.LEVEL_SWITCHED = "hlsLevelSwitched", t.LEVEL_LOADING = "hlsLevelLoading", t.LEVEL_LOADED = "hlsLevelLoaded", t.LEVEL_UPDATED = "hlsLevelUpdated", t.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", t.LEVELS_UPDATED = "hlsLevelsUpdated", t.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", t.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", t.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", t.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", t.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", t.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", t.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", t.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", t.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", t.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", t.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", t.CUES_PARSED = "hlsCuesParsed", t.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", t.INIT_PTS_FOUND = "hlsInitPtsFound", t.FRAG_LOADING = "hlsFragLoading", t.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", t.FRAG_LOADED = "hlsFragLoaded", t.FRAG_DECRYPTED = "hlsFragDecrypted", t.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", t.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", t.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", t.FRAG_PARSED = "hlsFragParsed", t.FRAG_BUFFERED = "hlsFragBuffered", t.FRAG_CHANGED = "hlsFragChanged", t.FPS_DROP = "hlsFpsDrop", t.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", t.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated", t.ERROR = "hlsError", t.DESTROYING = "hlsDestroying", t.KEY_LOADING = "hlsKeyLoading", t.KEY_LOADED = "hlsKeyLoaded", t.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", t.BACK_BUFFER_REACHED = "hlsBackBufferReached", t.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded", t
                }({}),
                E = function(t) {
                    return t.NETWORK_ERROR = "networkError", t.MEDIA_ERROR = "mediaError", t.KEY_SYSTEM_ERROR = "keySystemError", t.MUX_ERROR = "muxError", t.OTHER_ERROR = "otherError", t
                }({}),
                S = function(t) {
                    return t.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", t.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", t.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", t.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", t.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", t.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", t.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", t.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", t.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", t.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", t.MANIFEST_LOAD_ERROR = "manifestLoadError", t.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", t.MANIFEST_PARSING_ERROR = "manifestParsingError", t.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", t.LEVEL_EMPTY_ERROR = "levelEmptyError", t.LEVEL_LOAD_ERROR = "levelLoadError", t.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", t.LEVEL_PARSING_ERROR = "levelParsingError", t.LEVEL_SWITCH_ERROR = "levelSwitchError", t.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", t.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", t.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", t.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", t.FRAG_LOAD_ERROR = "fragLoadError", t.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", t.FRAG_DECRYPT_ERROR = "fragDecryptError", t.FRAG_PARSING_ERROR = "fragParsingError", t.FRAG_GAP = "fragGap", t.REMUX_ALLOC_ERROR = "remuxAllocError", t.KEY_LOAD_ERROR = "keyLoadError", t.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", t.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", t.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", t.BUFFER_APPEND_ERROR = "bufferAppendError", t.BUFFER_APPENDING_ERROR = "bufferAppendingError", t.BUFFER_STALLED_ERROR = "bufferStalledError", t.BUFFER_FULL_ERROR = "bufferFullError", t.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", t.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", t.INTERNAL_EXCEPTION = "internalException", t.INTERNAL_ABORTED = "aborted", t.UNKNOWN = "unknown", t
                }({});
            const b = function() {},
                A = {
                    trace: b,
                    debug: b,
                    log: b,
                    warn: b,
                    info: b,
                    error: b
                };
            let L = A;

            function k(t, ...e) {
                e.forEach((function(e) {
                    L[e] = t[e] ? t[e].bind(t) : function(t) {
                        const e = self.console[t];
                        return e ? e.bind(self.console, `[${t}] >`) : b
                    }(e)
                }))
            }
            const R = L,
                w = /^(\d+)x(\d+)$/,
                _ = /(.+?)=(".*?"|.*?)(?:,|$)/g;
            class D {
                constructor(t) {
                    "string" == typeof t && (t = D.parseAttrList(t)), m(this, t)
                }
                get clientAttrs() {
                    return Object.keys(this).filter((t => "X-" === t.substring(0, 2)))
                }
                decimalInteger(t) {
                    const e = parseInt(this[t], 10);
                    return e > Number.MAX_SAFE_INTEGER ? Infinity : e
                }
                hexadecimalInteger(t) {
                    if (this[t]) {
                        let e = (this[t] || "0x").slice(2);
                        e = (1 & e.length ? "0" : "") + e;
                        const i = new Uint8Array(e.length / 2);
                        for (let t = 0; t < e.length / 2; t++) i[t] = parseInt(e.slice(2 * t, 2 * t + 2), 16);
                        return i
                    }
                    return null
                }
                hexadecimalIntegerAsNumber(t) {
                    const e = parseInt(this[t], 16);
                    return e > Number.MAX_SAFE_INTEGER ? Infinity : e
                }
                decimalFloatingPoint(t) {
                    return parseFloat(this[t])
                }
                optionalFloat(t, e) {
                    const i = this[t];
                    return i ? parseFloat(i) : e
                }
                enumeratedString(t) {
                    return this[t]
                }
                bool(t) {
                    return "YES" === this[t]
                }
                decimalResolution(t) {
                    const e = w.exec(this[t]);
                    if (null !== e) return {
                        width: parseInt(e[1], 10),
                        height: parseInt(e[2], 10)
                    }
                }
                static parseAttrList(t) {
                    let e;
                    const i = {};
                    for (_.lastIndex = 0; null !== (e = _.exec(t));) {
                        let t = e[2];
                        0 === t.indexOf('"') && t.lastIndexOf('"') === t.length - 1 && (t = t.slice(1, -1));
                        i[e[1].trim()] = t
                    }
                    return i
                }
            }

            function C(t) {
                return "SCTE35-OUT" === t || "SCTE35-IN" === t
            }
            class I {
                constructor(t, e) {
                    if (this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, e) {
                        const i = e.attr;
                        for (const e in i)
                            if (Object.prototype.hasOwnProperty.call(t, e) && t[e] !== i[e]) {
                                R.warn(`DATERANGE tag attribute: "${e}" does not match for tags with ID: "${t.ID}"`), this._badValueForSameId = e;
                                break
                            }
                        t = m(new D({}), i, t)
                    }
                    if (this.attr = t, this._startDate = new Date(t["START-DATE"]), "END-DATE" in this.attr) {
                        const t = new Date(this.attr["END-DATE"]);
                        p(t.getTime()) && (this._endDate = t)
                    }
                }
                get id() {
                    return this.attr.ID
                }
                get class() {
                    return this.attr.CLASS
                }
                get startDate() {
                    return this._startDate
                }
                get endDate() {
                    if (this._endDate) return this._endDate;
                    const t = this.duration;
                    return null !== t ? new Date(this._startDate.getTime() + 1e3 * t) : null
                }
                get duration() {
                    if ("DURATION" in this.attr) {
                        const t = this.attr.decimalFloatingPoint("DURATION");
                        if (p(t)) return t
                    } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
                    return null
                }
                get plannedDuration() {
                    return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null
                }
                get endOnNext() {
                    return this.attr.bool("END-ON-NEXT")
                }
                get isValid() {
                    return !!this.id && !this._badValueForSameId && p(this.startDate.getTime()) && (null === this.duration || this.duration >= 0) && (!this.endOnNext || !!this.class)
                }
            }
            class P {
                constructor() {
                    this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
                        start: 0,
                        first: 0,
                        end: 0
                    }, this.parsing = {
                        start: 0,
                        end: 0
                    }, this.buffering = {
                        start: 0,
                        first: 0,
                        end: 0
                    }
                }
            }
            var x = "audio",
                M = "video",
                O = "audiovideo";
            class F {
                constructor(t) {
                    this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = {
                        [x]: null,
                        [M]: null,
                        [O]: null
                    }, this.baseurl = t
                }
                setByteRange(t, e) {
                    const i = t.split("@", 2);
                    let r;
                    r = 1 === i.length ? (null == e ? void 0 : e.byteRangeEndOffset) || 0 : parseInt(i[1]), this._byteRange = [r, parseInt(i[0]) + r]
                }
                get byteRange() {
                    return this._byteRange ? this._byteRange : []
                }
                get byteRangeStartOffset() {
                    return this.byteRange[0]
                }
                get byteRangeEndOffset() {
                    return this.byteRange[1]
                }
                get url() {
                    return !this._url && this.baseurl && this.relurl && (this._url = c.buildAbsoluteURL(this.baseurl, this.relurl, {
                        alwaysNormalize: !0
                    })), this._url || ""
                }
                set url(t) {
                    this._url = t
                }
            }
            class N extends F {
                constructor(t, e) {
                    super(e), this._decryptdata = null, this.rawProgramDateTime = null, this.programDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.stats = new P, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.urlId = 0, this.type = t
                }
                get decryptdata() {
                    const {
                        levelkeys: t
                    } = this;
                    if (!t && !this._decryptdata) return null;
                    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
                        const t = this.levelkeys.identity;
                        if (t) this._decryptdata = t.getDecryptData(this.sn);
                        else {
                            const t = Object.keys(this.levelkeys);
                            if (1 === t.length) return this._decryptdata = this.levelkeys[t[0]].getDecryptData(this.sn)
                        }
                    }
                    return this._decryptdata
                }
                get end() {
                    return this.start + this.duration
                }
                get endProgramDateTime() {
                    if (null === this.programDateTime) return null;
                    if (!p(this.programDateTime)) return null;
                    const t = p(this.duration) ? this.duration : 0;
                    return this.programDateTime + 1e3 * t
                }
                get encrypted() {
                    var t;
                    if (null != (t = this._decryptdata) && t.encrypted) return !0;
                    if (this.levelkeys) {
                        const t = Object.keys(this.levelkeys),
                            e = t.length;
                        if (e > 1 || 1 === e && this.levelkeys[t[0]].encrypted) return !0
                    }
                    return !1
                }
                setKeyFormat(t) {
                    if (this.levelkeys) {
                        const e = this.levelkeys[t];
                        e && !this._decryptdata && (this._decryptdata = e.getDecryptData(this.sn))
                    }
                }
                abortRequests() {
                    var t, e;
                    null == (t = this.loader) || t.abort(), null == (e = this.keyLoader) || e.abort()
                }
                setElementaryStreamInfo(t, e, i, r, s, n = !1) {
                    const {
                        elementaryStreams: a
                    } = this, o = a[t];
                    o ? (o.startPTS = Math.min(o.startPTS, e), o.endPTS = Math.max(o.endPTS, i), o.startDTS = Math.min(o.startDTS, r), o.endDTS = Math.max(o.endDTS, s)) : a[t] = {
                        startPTS: e,
                        endPTS: i,
                        startDTS: r,
                        endDTS: s,
                        partial: n
                    }
                }
                clearElementaryStreamInfo() {
                    const {
                        elementaryStreams: t
                    } = this;
                    t[x] = null, t[M] = null, t[O] = null
                }
            }
            class B extends F {
                constructor(t, e, i, r, s) {
                    super(i), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.stats = new P, this.duration = t.decimalFloatingPoint("DURATION"), this.gap = t.bool("GAP"), this.independent = t.bool("INDEPENDENT"), this.relurl = t.enumeratedString("URI"), this.fragment = e, this.index = r;
                    const n = t.enumeratedString("BYTERANGE");
                    n && this.setByteRange(n, s), s && (this.fragOffset = s.fragOffset + s.duration)
                }
                get start() {
                    return this.fragment.start + this.fragOffset
                }
                get end() {
                    return this.start + this.duration
                }
                get loaded() {
                    const {
                        elementaryStreams: t
                    } = this;
                    return !!(t.audio || t.video || t.audiovideo)
                }
            }
            class U {
                constructor(t) {
                    this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = t
                }
                reloaded(t) {
                    if (!t) return this.advanced = !0, void(this.updated = !0);
                    const e = this.lastPartSn - t.lastPartSn,
                        i = this.lastPartIndex - t.lastPartIndex;
                    this.updated = this.endSN !== t.endSN || !!i || !!e || !this.live, this.advanced = this.endSN > t.endSN || e > 0 || 0 === e && i > 0, this.updated || this.advanced ? this.misses = Math.floor(.6 * t.misses) : this.misses = t.misses + 1, this.availabilityDelay = t.availabilityDelay
                }
                get hasProgramDateTime() {
                    return !!this.fragments.length && p(this.fragments[this.fragments.length - 1].programDateTime)
                }
                get levelTargetDuration() {
                    return this.averagetargetduration || this.targetduration || 10
                }
                get drift() {
                    const t = this.driftEndTime - this.driftStartTime;
                    if (t > 0) {
                        return 1e3 * (this.driftEnd - this.driftStart) / t
                    }
                    return 1
                }
                get edge() {
                    return this.partEnd || this.fragmentEnd
                }
                get partEnd() {
                    var t;
                    return null != (t = this.partList) && t.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd
                }
                get fragmentEnd() {
                    var t;
                    return null != (t = this.fragments) && t.length ? this.fragments[this.fragments.length - 1].end : 0
                }
                get age() {
                    return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
                }
                get lastPartIndex() {
                    var t;
                    return null != (t = this.partList) && t.length ? this.partList[this.partList.length - 1].index : -1
                }
                get lastPartSn() {
                    var t;
                    return null != (t = this.partList) && t.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
                }
            }

            function $(t) {
                return Uint8Array.from(atob(t), (t => t.charCodeAt(0)))
            }

            function G(t) {
                const e = t.split(":");
                let i = null;
                if ("data" === e[0] && 2 === e.length) {
                    const t = e[1].split(";"),
                        r = t[t.length - 1].split(",");
                    if (2 === r.length) {
                        const e = "base64" === r[0],
                            s = r[1];
                        e ? (t.splice(-1, 1), i = $(s)) : i = function(t) {
                            const e = H(t).subarray(0, 16),
                                i = new Uint8Array(16);
                            return i.set(e, 16 - e.length), i
                        }(s)
                    }
                }
                return i
            }

            function H(t) {
                return Uint8Array.from(unescape(encodeURIComponent(t)), (t => t.charCodeAt(0)))
            }
            const V = "undefined" != typeof self ? self : void 0;
            var W = {
                    CLEARKEY: "org.w3.clearkey",
                    FAIRPLAY: "com.apple.fps",
                    PLAYREADY: "com.microsoft.playready",
                    WIDEVINE: "com.widevine.alpha"
                },
                K = "org.w3.clearkey",
                j = "com.apple.streamingkeydelivery",
                q = "com.microsoft.playready",
                Y = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";

            function z(t) {
                switch (t) {
                    case j:
                        return W.FAIRPLAY;
                    case q:
                        return W.PLAYREADY;
                    case Y:
                        return W.WIDEVINE;
                    case K:
                        return W.CLEARKEY
                }
            }
            var X = "1077efecc0b24d02ace33c1e52e2fb4b",
                Q = "e2719d58a985b3c9781ab030af78d30e",
                J = "9a04f07998404286ab92e65be0885f95",
                Z = "edef8ba979d64acea3c827dcd51d21ed";

            function tt(t) {
                return t === Z ? W.WIDEVINE : t === J ? W.PLAYREADY : t === X || t === Q ? W.CLEARKEY : void 0
            }

            function et(t) {
                switch (t) {
                    case W.FAIRPLAY:
                        return j;
                    case W.PLAYREADY:
                        return q;
                    case W.WIDEVINE:
                        return Y;
                    case W.CLEARKEY:
                        return K
                }
            }

            function it(t) {
                const {
                    drmSystems: e,
                    widevineLicenseUrl: i
                } = t, r = e ? [W.FAIRPLAY, W.WIDEVINE, W.PLAYREADY, W.CLEARKEY].filter((t => !!e[t])) : [];
                return !r[W.WIDEVINE] && i && r.push(W.WIDEVINE), r
            }
            const rt = null != V && null != (st = V.navigator) && st.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;
            var st;

            function nt(t, e, i) {
                return Uint8Array.prototype.slice ? t.slice(e, i) : new Uint8Array(Array.prototype.slice.call(t, e, i))
            }
            const at = (t, e) => e + 10 <= t.length && 73 === t[e] && 68 === t[e + 1] && 51 === t[e + 2] && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128,
                ot = (t, e) => e + 10 <= t.length && 51 === t[e] && 68 === t[e + 1] && 73 === t[e + 2] && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128,
                lt = (t, e) => {
                    const i = e;
                    let r = 0;
                    for (; at(t, e);) {
                        r += 10;
                        r += ut(t, e + 6), ot(t, e + 10) && (r += 10), e += r
                    }
                    if (r > 0) return t.subarray(i, i + r)
                },
                ut = (t, e) => {
                    let i = 0;
                    return i = (127 & t[e]) << 21, i |= (127 & t[e + 1]) << 14, i |= (127 & t[e + 2]) << 7, i |= 127 & t[e + 3], i
                },
                ct = (t, e) => at(t, e) && ut(t, e + 6) + 10 <= t.length - e,
                ht = t => {
                    const e = gt(t);
                    for (let t = 0; t < e.length; t++) {
                        const i = e[t];
                        if (dt(i)) return Tt(i)
                    }
                },
                dt = t => t && "PRIV" === t.key && "com.apple.streaming.transportStreamTimestamp" === t.info,
                ft = t => {
                    const e = String.fromCharCode(t[0], t[1], t[2], t[3]),
                        i = ut(t, 4);
                    return {
                        type: e,
                        size: i,
                        data: t.subarray(10, 10 + i)
                    }
                },
                gt = t => {
                    let e = 0;
                    const i = [];
                    for (; at(t, e);) {
                        const r = ut(t, e + 6);
                        e += 10;
                        const s = e + r;
                        for (; e + 8 < s;) {
                            const r = ft(t.subarray(e)),
                                s = mt(r);
                            s && i.push(s), e += r.size + 10
                        }
                        ot(t, e) && (e += 10)
                    }
                    return i
                },
                mt = t => "PRIV" === t.type ? pt(t) : "W" === t.type[0] ? yt(t) : vt(t),
                pt = t => {
                    if (t.size < 2) return;
                    const e = Et(t.data, !0),
                        i = new Uint8Array(t.data.subarray(e.length + 1));
                    return {
                        key: t.type,
                        info: e,
                        data: i.buffer
                    }
                },
                vt = t => {
                    if (t.size < 2) return;
                    if ("TXXX" === t.type) {
                        let e = 1;
                        const i = Et(t.data.subarray(e), !0);
                        e += i.length + 1;
                        const r = Et(t.data.subarray(e));
                        return {
                            key: t.type,
                            info: i,
                            data: r
                        }
                    }
                    const e = Et(t.data.subarray(1));
                    return {
                        key: t.type,
                        data: e
                    }
                },
                yt = t => {
                    if ("WXXX" === t.type) {
                        if (t.size < 2) return;
                        let e = 1;
                        const i = Et(t.data.subarray(e), !0);
                        e += i.length + 1;
                        const r = Et(t.data.subarray(e));
                        return {
                            key: t.type,
                            info: i,
                            data: r
                        }
                    }
                    const e = Et(t.data);
                    return {
                        key: t.type,
                        data: e
                    }
                },
                Tt = t => {
                    if (8 === t.data.byteLength) {
                        const e = new Uint8Array(t.data),
                            i = 1 & e[3];
                        let r = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];
                        return r /= 45, i && (r += 47721858.84), Math.round(r)
                    }
                },
                Et = (t, e = !1) => {
                    const i = bt();
                    if (i) {
                        const r = i.decode(t);
                        if (e) {
                            const t = r.indexOf("\0");
                            return -1 !== t ? r.substring(0, t) : r
                        }
                        return r.replace(/\0/g, "")
                    }
                    const r = t.length;
                    let s, n, a, o = "",
                        l = 0;
                    for (; l < r;) {
                        if (s = t[l++], 0 === s && e) return o;
                        if (0 !== s && 3 !== s) switch (s >> 4) {
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                                o += String.fromCharCode(s);
                                break;
                            case 12:
                            case 13:
                                n = t[l++], o += String.fromCharCode((31 & s) << 6 | 63 & n);
                                break;
                            case 14:
                                n = t[l++], a = t[l++], o += String.fromCharCode((15 & s) << 12 | (63 & n) << 6 | 63 & a)
                        }
                    }
                    return o
                };
            let St;

            function bt() {
                if (!navigator.userAgent.includes("PlayStation 4")) return St || void 0 === self.TextDecoder || (St = new self.TextDecoder("utf-8")), St
            }
            const At = {
                    hexDump: function(t) {
                        let e = "";
                        for (let i = 0; i < t.length; i++) {
                            let r = t[i].toString(16);
                            r.length < 2 && (r = "0" + r), e += r
                        }
                        return e
                    }
                },
                Lt = Math.pow(2, 32) - 1,
                kt = [].push,
                Rt = {
                    video: 1,
                    audio: 2,
                    id3: 3,
                    text: 4
                };

            function wt(t) {
                return String.fromCharCode.apply(null, t)
            }

            function _t(t, e) {
                const i = t[e] << 8 | t[e + 1];
                return i < 0 ? 65536 + i : i
            }

            function Dt(t, e) {
                const i = It(t, e);
                return i < 0 ? 4294967296 + i : i
            }

            function Ct(t, e) {
                let i = Dt(t, e);
                return i *= Math.pow(2, 32), i += Dt(t, e + 4), i
            }

            function It(t, e) {
                return t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]
            }

            function Pt(t, e, i) {
                t[e] = i >> 24, t[e + 1] = i >> 16 & 255, t[e + 2] = i >> 8 & 255, t[e + 3] = 255 & i
            }

            function xt(t, e) {
                const i = [];
                if (!e.length) return i;
                const r = t.byteLength;
                for (let s = 0; s < r;) {
                    const n = Dt(t, s),
                        a = n > 1 ? s + n : r;
                    if (wt(t.subarray(s + 4, s + 8)) === e[0])
                        if (1 === e.length) i.push(t.subarray(s + 8, a));
                        else {
                            const r = xt(t.subarray(s + 8, a), e.slice(1));
                            r.length && kt.apply(i, r)
                        }
                    s = a
                }
                return i
            }

            function Mt(t) {
                const e = [],
                    i = t[0];
                let r = 8;
                const s = Dt(t, r);
                r += 4;
                let n = 0,
                    a = 0;
                0 === i ? (n = Dt(t, r), a = Dt(t, r + 4), r += 8) : (n = Ct(t, r), a = Ct(t, r + 8), r += 16), r += 2;
                let o = t.length + a;
                const l = _t(t, r);
                r += 2;
                for (let i = 0; i < l; i++) {
                    let i = r;
                    const n = Dt(t, i);
                    i += 4;
                    const a = 2147483647 & n;
                    if (1 === (2147483648 & n) >>> 31) return R.warn("SIDX has hierarchical references (not supported)"), null;
                    const l = Dt(t, i);
                    i += 4, e.push({
                        referenceSize: a,
                        subsegmentDuration: l,
                        info: {
                            duration: l / s,
                            start: o,
                            end: o + a - 1
                        }
                    }), o += a, i += 4, r = i
                }
                return {
                    earliestPresentationTime: n,
                    timescale: s,
                    version: i,
                    referencesCount: l,
                    references: e
                }
            }

            function Ot(t) {
                const e = [],
                    i = xt(t, ["moov", "trak"]);
                for (let t = 0; t < i.length; t++) {
                    const r = i[t],
                        s = xt(r, ["tkhd"])[0];
                    if (s) {
                        let t = s[0];
                        const i = Dt(s, 0 === t ? 12 : 20),
                            n = xt(r, ["mdia", "mdhd"])[0];
                        if (n) {
                            t = n[0];
                            const s = Dt(n, 0 === t ? 12 : 20),
                                a = xt(r, ["mdia", "hdlr"])[0];
                            if (a) {
                                const t = wt(a.subarray(8, 12)),
                                    n = {
                                        soun: x,
                                        vide: M
                                    }[t];
                                if (n) {
                                    const t = Ft(xt(r, ["mdia", "minf", "stbl", "stsd"])[0]);
                                    e[i] = {
                                        timescale: s,
                                        type: n
                                    }, e[n] = d({
                                        timescale: s,
                                        id: i
                                    }, t)
                                }
                            }
                        }
                    }
                }
                return xt(t, ["moov", "mvex", "trex"]).forEach((t => {
                    const i = Dt(t, 4),
                        r = e[i];
                    r && (r.default = {
                        duration: Dt(t, 12),
                        flags: Dt(t, 20)
                    })
                })), e
            }

            function Ft(t) {
                const e = t.subarray(8),
                    i = e.subarray(86),
                    r = wt(e.subarray(4, 8));
                let s = r;
                const n = "enca" === r || "encv" === r;
                if (n) {
                    const t = xt(e, [r])[0];
                    xt(t.subarray("enca" === r ? 28 : 78), ["sinf"]).forEach((t => {
                        const e = xt(t, ["schm"])[0];
                        if (e) {
                            const i = wt(e.subarray(4, 8));
                            if ("cbcs" === i || "cenc" === i) {
                                const e = xt(t, ["frma"])[0];
                                e && (s = wt(e))
                            }
                        }
                    }))
                }
                switch (s) {
                    case "avc1":
                    case "avc2":
                    case "avc3":
                    case "avc4":
                        {
                            const t = xt(i, ["avcC"])[0];s += "." + Bt(t[1]) + Bt(t[2]) + Bt(t[3]);
                            break
                        }
                    case "mp4a":
                        {
                            const t = xt(e, [r])[0],
                                i = xt(t.subarray(28), ["esds"])[0];
                            if (i && i.length > 12) {
                                let t = 4;
                                if (3 !== i[t++]) break;
                                t = Nt(i, t), t += 2;
                                const e = i[t++];
                                if (128 & e && (t += 2), 64 & e && (t += i[t++]), 4 !== i[t++]) break;
                                t = Nt(i, t);
                                const r = i[t++];
                                if (64 !== r) break;
                                if (s += "." + Bt(r), t += 12, 5 !== i[t++]) break;
                                t = Nt(i, t);
                                const n = i[t++];
                                let a = (248 & n) >> 3;
                                31 === a && (a += 1 + ((7 & n) << 3) + ((224 & i[t]) >> 5)), s += "." + a
                            }
                            break
                        }
                    case "hvc1":
                    case "hev1":
                        {
                            const t = xt(i, ["hvcC"])[0],
                                e = t[1],
                                r = ["", "A", "B", "C"][e >> 6],
                                n = 31 & e,
                                a = Dt(t, 2),
                                o = (32 & e) >> 5 ? "H" : "L",
                                l = t[12],
                                u = t.subarray(6, 12);s += "." + r + n,
                            s += "." + a.toString(16).toUpperCase(),
                            s += "." + o + l;
                            let c = "";
                            for (let t = u.length; t--;) {
                                const e = u[t];
                                if (e || c) {
                                    c = "." + e.toString(16).toUpperCase() + c
                                }
                            }
                            s += c;
                            break
                        }
                    case "dvh1":
                    case "dvhe":
                        {
                            const t = xt(i, ["dvcC"])[0],
                                e = t[2] >> 1 & 127,
                                r = t[2] << 5 & 32 | t[3] >> 3 & 31;s += "." + Ut(e) + "." + Ut(r);
                            break
                        }
                    case "vp09":
                        {
                            const t = xt(i, ["vpcC"])[0],
                                e = t[4],
                                r = t[5],
                                n = t[6] >> 4 & 15;s += "." + Ut(e) + "." + Ut(r) + "." + Ut(n);
                            break
                        }
                    case "av01":
                        {
                            const t = xt(i, ["av1C"])[0],
                                e = t[1] >>> 5,
                                r = 31 & t[1],
                                n = t[2] >>> 7 ? "H" : "M",
                                a = (64 & t[2]) >> 6,
                                o = (32 & t[2]) >> 5,
                                l = 2 === e && a ? o ? 12 : 10 : a ? 10 : 8,
                                u = (16 & t[2]) >> 4,
                                c = (8 & t[2]) >> 3,
                                h = (4 & t[2]) >> 2,
                                d = 3 & t[2],
                                f = 1,
                                g = 1,
                                m = 1,
                                p = 0;s += "." + e + "." + Ut(r) + n + "." + Ut(l) + "." + u + "." + c + h + d + "." + Ut(f) + "." + Ut(g) + "." + Ut(m) + "." + p;
                            break
                        }
                }
                return {
                    codec: s,
                    encrypted: n
                }
            }

            function Nt(t, e) {
                const i = e + 5;
                for (; 128 & t[e++] && e < i;);
                return e
            }

            function Bt(t) {
                return ("0" + t.toString(16).toUpperCase()).slice(-2)
            }

            function Ut(t) {
                return (t < 10 ? "0" : "") + t
            }

            function $t(t) {
                const e = xt(t, ["schm"])[0];
                if (e) {
                    const i = wt(e.subarray(4, 8));
                    if ("cbcs" === i || "cenc" === i) return xt(t, ["schi", "tenc"])[0]
                }
                return null
            }

            function Gt(t) {
                const e = Dt(t, 0);
                let i = 8;
                1 & e && (i += 4), 4 & e && (i += 4);
                let r = 0;
                const s = Dt(t, 4);
                for (let n = 0; n < s; n++) {
                    if (256 & e) {
                        r += Dt(t, i), i += 4
                    }
                    512 & e && (i += 4), 1024 & e && (i += 4), 2048 & e && (i += 4)
                }
                return r
            }

            function Ht(t, e) {
                const i = new Uint8Array(t.length + e.length);
                return i.set(t), i.set(e, t.length), i
            }

            function Vt(t, e) {
                const i = [],
                    r = e.samples,
                    s = e.timescale,
                    n = e.id;
                let a = !1;
                return xt(r, ["moof"]).map((o => {
                    const l = o.byteOffset - 8;
                    xt(o, ["traf"]).map((o => {
                        const u = xt(o, ["tfdt"]).map((t => {
                            const e = t[0];
                            let i = Dt(t, 4);
                            return 1 === e && (i *= Math.pow(2, 32), i += Dt(t, 8)), i / s
                        }))[0];
                        return void 0 !== u && (t = u), xt(o, ["tfhd"]).map((u => {
                            const c = Dt(u, 4),
                                h = 16777215 & Dt(u, 0);
                            let d = 0;
                            const f = !!(16 & h);
                            let g = 0;
                            const m = !!(32 & h);
                            let p = 8;
                            c === n && (!!(1 & h) && (p += 8), !!(2 & h) && (p += 4), !!(8 & h) && (d = Dt(u, p), p += 4), f && (g = Dt(u, p), p += 4), m && (p += 4), "video" === e.type && (a = function(t) {
                                if (!t) return !1;
                                const e = t.indexOf("."),
                                    i = e < 0 ? t : t.substring(0, e);
                                return "hvc1" === i || "hev1" === i || "dvh1" === i || "dvhe" === i
                            }(e.codec)), xt(o, ["trun"]).map((n => {
                                const o = n[0],
                                    u = 16777215 & Dt(n, 0),
                                    c = !!(1 & u);
                                let h = 0;
                                const f = !!(4 & u),
                                    m = !!(256 & u);
                                let p = 0;
                                const v = !!(512 & u);
                                let y = 0;
                                const T = !!(1024 & u),
                                    E = !!(2048 & u);
                                let S = 0;
                                const b = Dt(n, 4);
                                let A = 8;
                                c && (h = Dt(n, A), A += 4), f && (A += 4);
                                let L = h + l;
                                for (let l = 0; l < b; l++) {
                                    if (m ? (p = Dt(n, A), A += 4) : p = d, v ? (y = Dt(n, A), A += 4) : y = g, T && (A += 4), E && (S = 0 === o ? Dt(n, A) : It(n, A), A += 4), e.type === M) {
                                        let e = 0;
                                        for (; e < y;) {
                                            const n = Dt(r, L);
                                            if (L += 4, Wt(a, r[L])) {
                                                Kt(r.subarray(L, L + n), a ? 2 : 1, t + S / s, i)
                                            }
                                            L += n, e += n + 4
                                        }
                                    }
                                    t += p / s
                                }
                            })))
                        }))
                    }))
                })), i
            }

            function Wt(t, e) {
                if (t) {
                    const t = e >> 1 & 63;
                    return 39 === t || 40 === t
                }
                return 6 === (31 & e)
            }

            function Kt(t, e, i, r) {
                const s = jt(t);
                let n = 0;
                n += e;
                let a = 0,
                    o = 0,
                    l = 0;
                for (; n < s.length;) {
                    a = 0;
                    do {
                        if (n >= s.length) break;
                        l = s[n++], a += l
                    } while (255 === l);
                    o = 0;
                    do {
                        if (n >= s.length) break;
                        l = s[n++], o += l
                    } while (255 === l);
                    const t = s.length - n;
                    let e = n;
                    if (o < t) n += o;
                    else if (o > t) {
                        R.error(`Malformed SEI payload. ${o} is too small, only ${t} bytes left to parse.`);
                        break
                    }
                    if (4 === a) {
                        if (181 === s[e++]) {
                            const t = _t(s, e);
                            if (e += 2, 49 === t) {
                                const t = Dt(s, e);
                                if (e += 4, 1195456820 === t) {
                                    const t = s[e++];
                                    if (3 === t) {
                                        const n = s[e++],
                                            o = 64 & n,
                                            l = o ? 2 + 3 * (31 & n) : 0,
                                            u = new Uint8Array(l);
                                        if (o) {
                                            u[0] = n;
                                            for (let t = 1; t < l; t++) u[t] = s[e++]
                                        }
                                        r.push({
                                            type: t,
                                            payloadType: a,
                                            pts: i,
                                            bytes: u
                                        })
                                    }
                                }
                            }
                        }
                    } else if (5 === a && o > 16) {
                        const t = [];
                        for (let i = 0; i < 16; i++) {
                            const r = s[e++].toString(16);
                            t.push(1 == r.length ? "0" + r : r), 3 !== i && 5 !== i && 7 !== i && 9 !== i || t.push("-")
                        }
                        const n = o - 16,
                            l = new Uint8Array(n);
                        for (let t = 0; t < n; t++) l[t] = s[e++];
                        r.push({
                            payloadType: a,
                            pts: i,
                            uuid: t.join(""),
                            userData: Et(l),
                            userDataBytes: l
                        })
                    }
                }
            }

            function jt(t) {
                const e = t.byteLength,
                    i = [];
                let r = 1;
                for (; r < e - 2;) 0 === t[r] && 0 === t[r + 1] && 3 === t[r + 2] ? (i.push(r + 2), r += 2) : r++;
                if (0 === i.length) return t;
                const s = e - i.length,
                    n = new Uint8Array(s);
                let a = 0;
                for (r = 0; r < s; a++, r++) a === i[0] && (a++, i.shift()), n[r] = t[a];
                return n
            }

            function qt(t, e, i) {
                if (16 !== t.byteLength) throw new RangeError("Invalid system id");
                let r, s, n;
                if (e) {
                    r = 1, s = new Uint8Array(16 * e.length);
                    for (let t = 0; t < e.length; t++) {
                        const i = e[t];
                        if (16 !== i.byteLength) throw new RangeError("Invalid key");
                        s.set(i, 16 * t)
                    }
                } else r = 0, s = new Uint8Array;
                r > 0 ? (n = new Uint8Array(4), e.length > 0 && new DataView(n.buffer).setUint32(0, e.length, !1)) : n = new Uint8Array;
                const a = new Uint8Array(4);
                return i && i.byteLength > 0 && new DataView(a.buffer).setUint32(0, i.byteLength, !1),
                    function(t, ...e) {
                        const i = e.length;
                        let r = 8,
                            s = i;
                        for (; s--;) r += e[s].byteLength;
                        const n = new Uint8Array(r);
                        for (n[0] = r >> 24 & 255, n[1] = r >> 16 & 255, n[2] = r >> 8 & 255, n[3] = 255 & r, n.set(t, 4), s = 0, r = 8; s < i; s++) n.set(e[s], r), r += e[s].byteLength;
                        return n
                    }([112, 115, 115, 104], new Uint8Array([r, 0, 0, 0]), t, n, s, a, i || new Uint8Array)
            }

            function Yt(t) {
                const e = t.getUint32(0),
                    i = t.byteOffset,
                    r = t.byteLength;
                if (r < e) return {
                    offset: i,
                    size: r
                };
                if (1886614376 !== t.getUint32(4)) return {
                    offset: i,
                    size: e
                };
                const s = t.getUint32(8) >>> 24;
                if (0 !== s && 1 !== s) return {
                    offset: i,
                    size: e
                };
                const n = t.buffer,
                    a = At.hexDump(new Uint8Array(n, i + 12, 16)),
                    o = t.getUint32(28);
                let l = null,
                    u = null;
                if (0 === s) {
                    if (e - 32 < o || o < 22) return {
                        offset: i,
                        size: e
                    };
                    u = new Uint8Array(n, i + 32, o)
                } else if (1 === s) {
                    if (!o || r < i + 32 + 16 * o + 16) return {
                        offset: i,
                        size: e
                    };
                    l = [];
                    for (let t = 0; t < o; t++) l.push(new Uint8Array(n, i + 32 + 16 * t, 16))
                }
                return {
                    version: s,
                    systemId: a,
                    kids: l,
                    data: u,
                    offset: i,
                    size: e
                }
            }
            let zt = {};
            class Xt {
                static clearKeyUriToKeyIdMap() {
                    zt = {}
                }
                constructor(t, e, i, r = [1], s = null) {
                    this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = t, this.uri = e, this.keyFormat = i, this.keyFormatVersions = r, this.iv = s, this.encrypted = !!t && "NONE" !== t, this.isCommonEncryption = this.encrypted && "AES-128" !== t
                }
                isSupported() {
                    if (this.method) {
                        if ("AES-128" === this.method || "NONE" === this.method) return !0;
                        if ("identity" === this.keyFormat) return "SAMPLE-AES" === this.method;
                        switch (this.keyFormat) {
                            case j:
                            case Y:
                            case q:
                            case K:
                                return -1 !== ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method)
                        }
                    }
                    return !1
                }
                getDecryptData(t) {
                    if (!this.encrypted || !this.uri) return null;
                    if ("AES-128" === this.method && this.uri && !this.iv) {
                        "number" != typeof t && ("AES-128" !== this.method || this.iv || R.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), t = 0);
                        const e = function(t) {
                            const e = new Uint8Array(16);
                            for (let i = 12; i < 16; i++) e[i] = t >> 8 * (15 - i) & 255;
                            return e
                        }(t);
                        return new Xt(this.method, this.uri, "identity", this.keyFormatVersions, e)
                    }
                    const e = G(this.uri);
                    if (e) switch (this.keyFormat) {
                        case Y:
                            this.pssh = e, e.length >= 22 && (this.keyId = e.subarray(e.length - 22, e.length - 6));
                            break;
                        case q:
                            {
                                const t = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);this.pssh = qt(t, null, e);
                                const i = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2),
                                    r = String.fromCharCode.apply(null, Array.from(i)),
                                    s = r.substring(r.indexOf("<"), r.length),
                                    n = (new DOMParser).parseFromString(s, "text/xml").getElementsByTagName("KID")[0];
                                if (n) {
                                    const t = n.childNodes[0] ? n.childNodes[0].nodeValue : n.getAttribute("VALUE");
                                    if (t) {
                                        const e = $(t).subarray(0, 16);
                                        ! function(t) {
                                            const e = function(t, e, i) {
                                                const r = t[e];
                                                t[e] = t[i], t[i] = r
                                            };
                                            e(t, 0, 3), e(t, 1, 2), e(t, 4, 5), e(t, 6, 7)
                                        }(e), this.keyId = e
                                    }
                                }
                                break
                            }
                        default:
                            {
                                let t = e.subarray(0, 16);
                                if (16 !== t.length) {
                                    const e = new Uint8Array(16);
                                    e.set(t, 16 - t.length), t = e
                                }
                                this.keyId = t;
                                break
                            }
                    }
                    if (!this.keyId || 16 !== this.keyId.byteLength) {
                        let t = zt[this.uri];
                        if (!t) {
                            const e = Object.keys(zt).length % Number.MAX_SAFE_INTEGER;
                            t = new Uint8Array(16);
                            new DataView(t.buffer, 12, 4).setUint32(0, e), zt[this.uri] = t
                        }
                        this.keyId = t
                    }
                    return this
                }
            }
            const Qt = /\{\$([a-zA-Z0-9-_]+)\}/g;

            function Jt(t) {
                return Qt.test(t)
            }

            function Zt(t, e, i) {
                if (null !== t.variableList || t.hasVariableRefs)
                    for (let r = i.length; r--;) {
                        const s = i[r],
                            n = e[s];
                        n && (e[s] = te(t, n))
                    }
            }

            function te(t, e) {
                if (null !== t.variableList || t.hasVariableRefs) {
                    const i = t.variableList;
                    return e.replace(Qt, (e => {
                        const r = e.substring(2, e.length - 1),
                            s = null == i ? void 0 : i[r];
                        return void 0 === s ? (t.playlistParsingError || (t.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${r}"`)), e) : s
                    }))
                }
                return e
            }

            function ee(t, e, i) {
                let r, s, n = t.variableList;
                if (n || (t.variableList = n = {}), "QUERYPARAM" in e) {
                    r = e.QUERYPARAM;
                    try {
                        const t = new self.URL(i).searchParams;
                        if (!t.has(r)) throw new Error(`"${r}" does not match any query parameter in URI: "${i}"`);
                        s = t.get(r)
                    } catch (e) {
                        t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${e.message}`))
                    }
                } else r = e.NAME, s = e.VALUE;
                r in n ? t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${r}"`)) : n[r] = s || ""
            }

            function ie(t, e, i) {
                const r = e.IMPORT;
                if (i && r in i) {
                    let e = t.variableList;
                    e || (t.variableList = e = {}), e[r] = i[r]
                } else t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${r}"`))
            }

            function re(t = !0) {
                if ("undefined" == typeof self) return;
                return (t || !self.MediaSource) && self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource
            }
            const se = {
                audio: {
                    a3ds: 1,
                    "ac-3": .95,
                    "ac-4": 1,
                    alac: .9,
                    alaw: 1,
                    dra1: 1,
                    "dts+": 1,
                    "dts-": 1,
                    dtsc: 1,
                    dtse: 1,
                    dtsh: 1,
                    "ec-3": .9,
                    enca: 1,
                    fLaC: .9,
                    flac: .9,
                    FLAC: .9,
                    g719: 1,
                    g726: 1,
                    m4ae: 1,
                    mha1: 1,
                    mha2: 1,
                    mhm1: 1,
                    mhm2: 1,
                    mlpa: 1,
                    mp4a: 1,
                    "raw ": 1,
                    Opus: 1,
                    opus: 1,
                    samr: 1,
                    sawb: 1,
                    sawp: 1,
                    sevc: 1,
                    sqcp: 1,
                    ssmv: 1,
                    twos: 1,
                    ulaw: 1
                },
                video: {
                    avc1: 1,
                    avc2: 1,
                    avc3: 1,
                    avc4: 1,
                    avcp: 1,
                    av01: .8,
                    drac: 1,
                    dva1: 1,
                    dvav: 1,
                    dvh1: .7,
                    dvhe: .7,
                    encv: 1,
                    hev1: .75,
                    hvc1: .75,
                    mjp2: 1,
                    mp4v: 1,
                    mvc1: 1,
                    mvc2: 1,
                    mvc3: 1,
                    mvc4: 1,
                    resv: 1,
                    rv60: 1,
                    s263: 1,
                    svc1: 1,
                    svc2: 1,
                    "vc-1": 1,
                    vp08: 1,
                    vp09: .9
                },
                text: {
                    stpp: 1,
                    wvtt: 1
                }
            };

            function ne(t, e, i = !0) {
                return !t.split(",").some((t => !ae(t, e, i)))
            }

            function ae(t, e, i = !0) {
                var r;
                const s = re(i);
                return null != (r = null == s ? void 0 : s.isTypeSupported(oe(t, e))) && r
            }

            function oe(t, e) {
                return `${e}/mp4;codecs="${t}"`
            }

            function le(t) {
                if (t) {
                    const e = t.substring(0, 4);
                    return se.video[e]
                }
                return 2
            }

            function ue(t) {
                return t.split(",").reduce(((t, e) => {
                    const i = se.video[e];
                    return i ? (2 * i + t) / (t ? 3 : 2) : (se.audio[e] + t) / (t ? 2 : 1)
                }), 0)
            }
            const ce = {};
            const he = /flac|opus/i;

            function de(t, e = !0) {
                return t.replace(he, (t => function(t, e = !0) {
                    if (ce[t]) return ce[t];
                    const i = {
                        flac: ["flac", "fLaC", "FLAC"],
                        opus: ["opus", "Opus"]
                    }[t];
                    for (let r = 0; r < i.length; r++)
                        if (ae(i[r], "audio", e)) return ce[t] = i[r], i[r];
                    return t
                }(t.toLowerCase(), e)))
            }

            function fe(t, e) {
                return t && "mp4a" !== t ? t : e ? e.split(",")[0] : e
            }
            const ge = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g,
                me = /#EXT-X-MEDIA:(.*)/g,
                pe = /^#EXT(?:INF|-X-TARGETDURATION):/m,
                ve = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[^\r\n]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"), "g"),
                ye = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
            class Te {
                static findGroup(t, e) {
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i];
                        if (r.id === e) return r
                    }
                }
                static resolve(t, e) {
                    return c.buildAbsoluteURL(e, t, {
                        alwaysNormalize: !0
                    })
                }
                static isMediaPlaylist(t) {
                    return pe.test(t)
                }
                static parseMasterPlaylist(t, e) {
                    const i = {
                            contentSteering: null,
                            levels: [],
                            playlistParsingError: null,
                            sessionData: null,
                            sessionKeys: null,
                            startTimeOffset: null,
                            variableList: null,
                            hasVariableRefs: Jt(t)
                        },
                        r = [];
                    let s;
                    for (ge.lastIndex = 0; null != (s = ge.exec(t));)
                        if (s[1]) {
                            var n;
                            const t = new D(s[1]);
                            Zt(i, t, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]);
                            const a = te(i, s[2]),
                                o = {
                                    attrs: t,
                                    bitrate: t.decimalInteger("BANDWIDTH") || t.decimalInteger("AVERAGE-BANDWIDTH"),
                                    name: t.NAME,
                                    url: Te.resolve(a, e)
                                },
                                l = t.decimalResolution("RESOLUTION");
                            l && (o.width = l.width, o.height = l.height), be(t.CODECS, o), null != (n = o.unknownCodecs) && n.length || r.push(o), i.levels.push(o)
                        } else if (s[3]) {
                        const t = s[3],
                            r = s[4];
                        switch (t) {
                            case "SESSION-DATA":
                                {
                                    const t = new D(r);Zt(i, t, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]);
                                    const e = t["DATA-ID"];e && (null === i.sessionData && (i.sessionData = {}), i.sessionData[e] = t);
                                    break
                                }
                            case "SESSION-KEY":
                                {
                                    const t = Ee(r, e, i);t.encrypted && t.isSupported() ? (null === i.sessionKeys && (i.sessionKeys = []), i.sessionKeys.push(t)) : R.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${r}"`);
                                    break
                                }
                            case "DEFINE":
                                {
                                    const t = new D(r);Zt(i, t, ["NAME", "VALUE", "QUERYPARAM"]),
                                    ee(i, t, e)
                                }
                                break;
                            case "CONTENT-STEERING":
                                {
                                    const t = new D(r);Zt(i, t, ["SERVER-URI", "PATHWAY-ID"]),
                                    i.contentSteering = {
                                        uri: Te.resolve(t["SERVER-URI"], e),
                                        pathwayId: t["PATHWAY-ID"] || "."
                                    };
                                    break
                                }
                            case "START":
                                i.startTimeOffset = Se(r)
                        }
                    }
                    const a = r.length > 0 && r.length < i.levels.length;
                    return i.levels = a ? r : i.levels, 0 === i.levels.length && (i.playlistParsingError = new Error("no levels found in manifest")), i
                }
                static parseMasterPlaylistMedia(t, e, i) {
                    let r;
                    const s = {},
                        n = i.levels,
                        a = {
                            AUDIO: n.map((t => ({
                                id: t.attrs.AUDIO,
                                audioCodec: t.audioCodec
                            }))),
                            SUBTITLES: n.map((t => ({
                                id: t.attrs.SUBTITLES,
                                textCodec: t.textCodec
                            }))),
                            "CLOSED-CAPTIONS": []
                        };
                    let o = 0;
                    for (me.lastIndex = 0; null !== (r = me.exec(t));) {
                        const t = new D(r[1]),
                            n = t.TYPE;
                        if (n) {
                            const r = a[n],
                                l = s[n] || [];
                            s[n] = l, Zt(i, t, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]);
                            const u = t.LANGUAGE,
                                c = t["ASSOC-LANGUAGE"],
                                h = t.CHANNELS,
                                d = t.CHARACTERISTICS,
                                f = t["INSTREAM-ID"],
                                g = {
                                    attrs: t,
                                    bitrate: 0,
                                    id: o++,
                                    groupId: t["GROUP-ID"] || "",
                                    name: t.NAME || u || "",
                                    type: n,
                                    default: t.bool("DEFAULT"),
                                    autoselect: t.bool("AUTOSELECT"),
                                    forced: t.bool("FORCED"),
                                    lang: u,
                                    url: t.URI ? Te.resolve(t.URI, e) : ""
                                };
                            if (c && (g.assocLang = c), h && (g.channels = h), d && (g.characteristics = d), f && (g.instreamId = f), null != r && r.length) {
                                const t = Te.findGroup(r, g.groupId) || r[0];
                                Ae(g, t, "audioCodec"), Ae(g, t, "textCodec")
                            }
                            l.push(g)
                        }
                    }
                    return s
                }
                static parseLevelPlaylist(t, e, i, r, s, n) {
                    const a = new U(e),
                        o = a.fragments;
                    let l, u, c, h = null,
                        d = 0,
                        f = 0,
                        g = 0,
                        v = 0,
                        y = null,
                        T = new N(r, e),
                        E = -1,
                        S = !1,
                        b = null;
                    for (ve.lastIndex = 0, a.m3u8 = t, a.hasVariableRefs = Jt(t); null !== (l = ve.exec(t));) {
                        S && (S = !1, T = new N(r, e), T.start = g, T.sn = d, T.cc = v, T.level = i, h && (T.initSegment = h, T.rawProgramDateTime = h.rawProgramDateTime, h.rawProgramDateTime = null, b && (T.setByteRange(b), b = null)));
                        const t = l[1];
                        if (t) {
                            T.duration = parseFloat(t);
                            const e = (" " + l[2]).slice(1);
                            T.title = e || null, T.tagList.push(e ? ["INF", t, e] : ["INF", t])
                        } else if (l[3]) {
                            if (p(T.duration)) {
                                T.start = g, c && Re(T, c, a), T.sn = d, T.level = i, T.cc = v, o.push(T);
                                const t = (" " + l[3]).slice(1);
                                T.relurl = te(a, t), Le(T, y), y = T, g += T.duration, d++, f = 0, S = !0
                            }
                        } else if (l[4]) {
                            const t = (" " + l[4]).slice(1);
                            y ? T.setByteRange(t, y) : T.setByteRange(t)
                        } else if (l[5]) T.rawProgramDateTime = (" " + l[5]).slice(1), T.tagList.push(["PROGRAM-DATE-TIME", T.rawProgramDateTime]), -1 === E && (E = o.length);
                        else {
                            if (l = l[0].match(ye), !l) {
                                R.warn("No matches on slow regex match for level playlist!");
                                continue
                            }
                            for (u = 1; u < l.length && void 0 === l[u]; u++);
                            const t = (" " + l[u]).slice(1),
                                s = (" " + l[u + 1]).slice(1),
                                g = l[u + 2] ? (" " + l[u + 2]).slice(1) : "";
                            switch (t) {
                                case "PLAYLIST-TYPE":
                                    a.type = s.toUpperCase();
                                    break;
                                case "MEDIA-SEQUENCE":
                                    d = a.startSN = parseInt(s);
                                    break;
                                case "SKIP":
                                    {
                                        const t = new D(s);Zt(a, t, ["RECENTLY-REMOVED-DATERANGES"]);
                                        const e = t.decimalInteger("SKIPPED-SEGMENTS");
                                        if (p(e)) {
                                            a.skippedSegments = e;
                                            for (let t = e; t--;) o.unshift(null);
                                            d += e
                                        }
                                        const i = t.enumeratedString("RECENTLY-REMOVED-DATERANGES");i && (a.recentlyRemovedDateranges = i.split("\t"));
                                        break
                                    }
                                case "TARGETDURATION":
                                    a.targetduration = Math.max(parseInt(s), 1);
                                    break;
                                case "VERSION":
                                    a.version = parseInt(s);
                                    break;
                                case "INDEPENDENT-SEGMENTS":
                                case "EXTM3U":
                                    break;
                                case "ENDLIST":
                                    a.live = !1;
                                    break;
                                case "#":
                                    (s || g) && T.tagList.push(g ? [s, g] : [s]);
                                    break;
                                case "DISCONTINUITY":
                                    v++, T.tagList.push(["DIS"]);
                                    break;
                                case "GAP":
                                    T.gap = !0, T.tagList.push([t]);
                                    break;
                                case "BITRATE":
                                    T.tagList.push([t, s]);
                                    break;
                                case "DATERANGE":
                                    {
                                        const t = new D(s);Zt(a, t, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]),
                                        Zt(a, t, t.clientAttrs);
                                        const e = new I(t, a.dateRanges[t.ID]);e.isValid || a.skippedSegments ? a.dateRanges[e.id] = e : R.warn(`Ignoring invalid DATERANGE tag: "${s}"`),
                                        T.tagList.push(["EXT-X-DATERANGE", s]);
                                        break
                                    }
                                case "DEFINE":
                                    {
                                        const t = new D(s);Zt(a, t, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]),
                                        "IMPORT" in t ? ie(a, t, n) : ee(a, t, e)
                                    }
                                    break;
                                case "DISCONTINUITY-SEQUENCE":
                                    v = parseInt(s);
                                    break;
                                case "KEY":
                                    {
                                        const t = Ee(s, e, a);
                                        if (t.isSupported()) {
                                            if ("NONE" === t.method) {
                                                c = void 0;
                                                break
                                            }
                                            c || (c = {}), c[t.keyFormat] && (c = m({}, c)), c[t.keyFormat] = t
                                        } else R.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${s}"`);
                                        break
                                    }
                                case "START":
                                    a.startTimeOffset = Se(s);
                                    break;
                                case "MAP":
                                    {
                                        const t = new D(s);
                                        if (Zt(a, t, ["BYTERANGE", "URI"]), T.duration) {
                                            const s = new N(r, e);
                                            ke(s, t, i, c), h = s, T.initSegment = h, h.rawProgramDateTime && !T.rawProgramDateTime && (T.rawProgramDateTime = h.rawProgramDateTime)
                                        } else {
                                            const e = T.byteRangeEndOffset;
                                            if (e) {
                                                const t = T.byteRangeStartOffset;
                                                b = `${e-t}@${t}`
                                            } else b = null;
                                            ke(T, t, i, c), h = T, S = !0
                                        }
                                        break
                                    }
                                case "SERVER-CONTROL":
                                    {
                                        const t = new D(s);a.canBlockReload = t.bool("CAN-BLOCK-RELOAD"),
                                        a.canSkipUntil = t.optionalFloat("CAN-SKIP-UNTIL", 0),
                                        a.canSkipDateRanges = a.canSkipUntil > 0 && t.bool("CAN-SKIP-DATERANGES"),
                                        a.partHoldBack = t.optionalFloat("PART-HOLD-BACK", 0),
                                        a.holdBack = t.optionalFloat("HOLD-BACK", 0);
                                        break
                                    }
                                case "PART-INF":
                                    {
                                        const t = new D(s);a.partTarget = t.decimalFloatingPoint("PART-TARGET");
                                        break
                                    }
                                case "PART":
                                    {
                                        let t = a.partList;t || (t = a.partList = []);
                                        const i = f > 0 ? t[t.length - 1] : void 0,
                                            r = f++,
                                            n = new D(s);Zt(a, n, ["BYTERANGE", "URI"]);
                                        const o = new B(n, T, e, r, i);t.push(o),
                                        T.duration += o.duration;
                                        break
                                    }
                                case "PRELOAD-HINT":
                                    {
                                        const t = new D(s);Zt(a, t, ["URI"]),
                                        a.preloadHint = t;
                                        break
                                    }
                                case "RENDITION-REPORT":
                                    {
                                        const t = new D(s);Zt(a, t, ["URI"]),
                                        a.renditionReports = a.renditionReports || [],
                                        a.renditionReports.push(t);
                                        break
                                    }
                                default:
                                    R.warn(`line parsed but not handled: ${l}`)
                            }
                        }
                    }
                    y && !y.relurl ? (o.pop(), g -= y.duration, a.partList && (a.fragmentHint = y)) : a.partList && (Le(T, y), T.cc = v, a.fragmentHint = T, c && Re(T, c, a));
                    const A = o.length,
                        L = o[0],
                        k = o[A - 1];
                    if (g += a.skippedSegments * a.targetduration, g > 0 && A && k) {
                        a.averagetargetduration = g / A;
                        const t = k.sn;
                        a.endSN = "initSegment" !== t ? t : 0, a.live || (k.endList = !0), L && (a.startCC = L.cc)
                    } else a.endSN = 0, a.startCC = 0;
                    return a.fragmentHint && (g += a.fragmentHint.duration), a.totalduration = g, a.endCC = v, E > 0 && function(t, e) {
                        let i = t[e];
                        for (let r = e; r--;) {
                            const e = t[r];
                            if (!e) return;
                            e.programDateTime = i.programDateTime - 1e3 * e.duration, i = e
                        }
                    }(o, E), a
                }
            }

            function Ee(t, e, i) {
                var r, s;
                const n = new D(t);
                Zt(i, n, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]);
                const a = null != (r = n.METHOD) ? r : "",
                    o = n.URI,
                    l = n.hexadecimalInteger("IV"),
                    u = n.KEYFORMATVERSIONS,
                    c = null != (s = n.KEYFORMAT) ? s : "identity";
                o && n.IV && !l && R.error(`Invalid IV: ${n.IV}`);
                const h = o ? Te.resolve(o, e) : "",
                    d = (u || "1").split("/").map(Number).filter(Number.isFinite);
                return new Xt(a, h, c, d, l)
            }

            function Se(t) {
                const e = new D(t).decimalFloatingPoint("TIME-OFFSET");
                return p(e) ? e : null
            }

            function be(t, e) {
                let i = (t || "").split(/[ ,]+/).filter((t => t));
                ["video", "audio", "text"].forEach((t => {
                    const r = i.filter((e => function(t, e) {
                        const i = se[e];
                        return !!i && !!i[t.slice(0, 4)]
                    }(e, t)));
                    r.length && (e[`${t}Codec`] = r.join(","), i = i.filter((t => -1 === r.indexOf(t))))
                })), e.unknownCodecs = i
            }

            function Ae(t, e, i) {
                const r = e[i];
                r && (t[i] = r)
            }

            function Le(t, e) {
                t.rawProgramDateTime ? t.programDateTime = Date.parse(t.rawProgramDateTime) : null != e && e.programDateTime && (t.programDateTime = e.endProgramDateTime), p(t.programDateTime) || (t.programDateTime = null, t.rawProgramDateTime = null)
            }

            function ke(t, e, i, r) {
                t.relurl = e.URI, e.BYTERANGE && t.setByteRange(e.BYTERANGE), t.level = i, t.sn = "initSegment", r && (t.levelkeys = r), t.initSegment = null
            }

            function Re(t, e, i) {
                t.levelkeys = e;
                const {
                    encryptedFragments: r
                } = i;
                r.length && r[r.length - 1].levelkeys === e || !Object.keys(e).some((t => e[t].isCommonEncryption)) || r.push(t)
            }
            var we = "manifest",
                _e = "level",
                De = "audioTrack",
                Ce = "subtitleTrack",
                Ie = "main",
                Pe = "audio",
                xe = "subtitle";

            function Me(t) {
                const {
                    type: e
                } = t;
                switch (e) {
                    case De:
                        return Pe;
                    case Ce:
                        return xe;
                    default:
                        return Ie
                }
            }

            function Oe(t, e) {
                let i = t.url;
                return void 0 !== i && 0 !== i.indexOf("data:") || (i = e.url), i
            }
            class Fe {
                constructor(t) {
                    this.hls = void 0, this.loaders = Object.create(null), this.variableList = null, this.hls = t, this.registerListeners()
                }
                startLoad(t) {}
                stopLoad() {
                    this.destroyInternalLoaders()
                }
                registerListeners() {
                    const {
                        hls: t
                    } = this;
                    t.on(T.MANIFEST_LOADING, this.onManifestLoading, this), t.on(T.LEVEL_LOADING, this.onLevelLoading, this), t.on(T.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), t.on(T.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
                }
                unregisterListeners() {
                    const {
                        hls: t
                    } = this;
                    t.off(T.MANIFEST_LOADING, this.onManifestLoading, this), t.off(T.LEVEL_LOADING, this.onLevelLoading, this), t.off(T.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), t.off(T.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
                }
                createInternalLoader(t) {
                    const e = this.hls.config,
                        i = e.pLoader,
                        r = e.loader,
                        s = new(i || r)(e);
                    return this.loaders[t.type] = s, s
                }
                getInternalLoader(t) {
                    return this.loaders[t.type]
                }
                resetInternalLoader(t) {
                    this.loaders[t] && delete this.loaders[t]
                }
                destroyInternalLoaders() {
                    for (const t in this.loaders) {
                        const e = this.loaders[t];
                        e && e.destroy(), this.resetInternalLoader(t)
                    }
                }
                destroy() {
                    this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders()
                }
                onManifestLoading(t, e) {
                    const {
                        url: i
                    } = e;
                    this.variableList = null, this.load({
                        id: null,
                        level: 0,
                        responseType: "text",
                        type: we,
                        url: i,
                        deliveryDirectives: null
                    })
                }
                onLevelLoading(t, e) {
                    const {
                        id: i,
                        level: r,
                        pathwayId: s,
                        url: n,
                        deliveryDirectives: a
                    } = e;
                    this.load({
                        id: i,
                        level: r,
                        pathwayId: s,
                        responseType: "text",
                        type: _e,
                        url: n,
                        deliveryDirectives: a
                    })
                }
                onAudioTrackLoading(t, e) {
                    const {
                        id: i,
                        groupId: r,
                        url: s,
                        deliveryDirectives: n
                    } = e;
                    this.load({
                        id: i,
                        groupId: r,
                        level: null,
                        responseType: "text",
                        type: De,
                        url: s,
                        deliveryDirectives: n
                    })
                }
                onSubtitleTrackLoading(t, e) {
                    const {
                        id: i,
                        groupId: r,
                        url: s,
                        deliveryDirectives: n
                    } = e;
                    this.load({
                        id: i,
                        groupId: r,
                        level: null,
                        responseType: "text",
                        type: Ce,
                        url: s,
                        deliveryDirectives: n
                    })
                }
                load(t) {
                    var e;
                    const i = this.hls.config;
                    let r, s = this.getInternalLoader(t);
                    if (s) {
                        const e = s.context;
                        if (e && e.url === t.url && e.level === t.level) return void R.trace("[playlist-loader]: playlist request ongoing");
                        R.log(`[playlist-loader]: aborting previous loader for type: ${t.type}`), s.abort()
                    }
                    if (r = t.type === we ? i.manifestLoadPolicy.default : m({}, i.playlistLoadPolicy.default, {
                            timeoutRetry: null,
                            errorRetry: null
                        }), s = this.createInternalLoader(t), p(null == (e = t.deliveryDirectives) ? void 0 : e.part)) {
                        let e;
                        if (t.type === _e && null !== t.level ? e = this.hls.levels[t.level].details : t.type === De && null !== t.id ? e = this.hls.audioTracks[t.id].details : t.type === Ce && null !== t.id && (e = this.hls.subtitleTracks[t.id].details), e) {
                            const t = e.partTarget,
                                i = e.targetduration;
                            if (t && i) {
                                const e = 1e3 * Math.max(3 * t, .8 * i);
                                r = m({}, r, {
                                    maxTimeToFirstByteMs: Math.min(e, r.maxTimeToFirstByteMs),
                                    maxLoadTimeMs: Math.min(e, r.maxTimeToFirstByteMs)
                                })
                            }
                        }
                    }
                    const n = r.errorRetry || r.timeoutRetry || {},
                        a = {
                            loadPolicy: r,
                            timeout: r.maxLoadTimeMs,
                            maxRetry: n.maxNumRetry || 0,
                            retryDelay: n.retryDelayMs || 0,
                            maxRetryDelay: n.maxRetryDelayMs || 0
                        },
                        o = {
                            onSuccess: (t, e, i, r) => {
                                const s = this.getInternalLoader(i);
                                this.resetInternalLoader(i.type);
                                const n = t.data;
                                0 === n.indexOf("#EXTM3U") ? (e.parsing.start = performance.now(), Te.isMediaPlaylist(n) ? this.handleTrackOrLevelPlaylist(t, e, i, r || null, s) : this.handleMasterPlaylist(t, e, i, r)) : this.handleManifestParsingError(t, i, new Error("no EXTM3U delimiter"), r || null, e)
                            },
                            onError: (t, e, i, r) => {
                                this.handleNetworkError(e, i, !1, t, r)
                            },
                            onTimeout: (t, e, i) => {
                                this.handleNetworkError(e, i, !0, void 0, t)
                            }
                        };
                    s.load(t, a, o)
                }
                handleMasterPlaylist(t, e, i, r) {
                    const s = this.hls,
                        n = t.data,
                        a = Oe(t, i),
                        o = Te.parseMasterPlaylist(n, a);
                    if (o.playlistParsingError) return void this.handleManifestParsingError(t, i, o.playlistParsingError, r, e);
                    const {
                        contentSteering: l,
                        levels: u,
                        sessionData: c,
                        sessionKeys: h,
                        startTimeOffset: d,
                        variableList: f
                    } = o;
                    this.variableList = f;
                    const {
                        AUDIO: g = [],
                        SUBTITLES: m,
                        "CLOSED-CAPTIONS": p
                    } = Te.parseMasterPlaylistMedia(n, a, o);
                    if (g.length) {
                        g.some((t => !t.url)) || !u[0].audioCodec || u[0].attrs.AUDIO || (R.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), g.unshift({
                            type: "main",
                            name: "main",
                            groupId: "main",
                            default: !1,
                            autoselect: !1,
                            forced: !1,
                            id: -1,
                            attrs: new D({}),
                            bitrate: 0,
                            url: ""
                        }))
                    }
                    s.trigger(T.MANIFEST_LOADED, {
                        levels: u,
                        audioTracks: g,
                        subtitles: m,
                        captions: p,
                        contentSteering: l,
                        url: a,
                        stats: e,
                        networkDetails: r,
                        sessionData: c,
                        sessionKeys: h,
                        startTimeOffset: d,
                        variableList: f
                    })
                }
                handleTrackOrLevelPlaylist(t, e, i, r, s) {
                    const n = this.hls,
                        {
                            id: a,
                            level: o,
                            type: l
                        } = i,
                        u = Oe(t, i),
                        c = p(o) ? o : p(a) ? a : 0,
                        h = Me(i),
                        d = Te.parseLevelPlaylist(t.data, u, c, h, 0, this.variableList);
                    if (l === we) {
                        const t = {
                            attrs: new D({}),
                            bitrate: 0,
                            details: d,
                            name: "",
                            url: u
                        };
                        n.trigger(T.MANIFEST_LOADED, {
                            levels: [t],
                            audioTracks: [],
                            url: u,
                            stats: e,
                            networkDetails: r,
                            sessionData: null,
                            sessionKeys: null,
                            contentSteering: null,
                            startTimeOffset: null,
                            variableList: null
                        })
                    }
                    e.parsing.end = performance.now(), i.levelDetails = d, this.handlePlaylistLoaded(d, t, e, i, r, s)
                }
                handleManifestParsingError(t, e, i, r, s) {
                    this.hls.trigger(T.ERROR, {
                        type: E.NETWORK_ERROR,
                        details: S.MANIFEST_PARSING_ERROR,
                        fatal: e.type === we,
                        url: t.url,
                        err: i,
                        error: i,
                        reason: i.message,
                        response: t,
                        context: e,
                        networkDetails: r,
                        stats: s
                    })
                }
                handleNetworkError(t, e, i = !1, r, s) {
                    let n = `A network ${i?"timeout":"error"+(r?" (status "+r.code+")":"")} occurred while loading ${t.type}`;
                    t.type === _e ? n += `: ${t.level} id: ${t.id}` : t.type !== De && t.type !== Ce || (n += ` id: ${t.id} group-id: "${t.groupId}"`);
                    const a = new Error(n);
                    R.warn(`[playlist-loader]: ${n}`);
                    let o = S.UNKNOWN,
                        l = !1;
                    const u = this.getInternalLoader(t);
                    switch (t.type) {
                        case we:
                            o = i ? S.MANIFEST_LOAD_TIMEOUT : S.MANIFEST_LOAD_ERROR, l = !0;
                            break;
                        case _e:
                            o = i ? S.LEVEL_LOAD_TIMEOUT : S.LEVEL_LOAD_ERROR, l = !1;
                            break;
                        case De:
                            o = i ? S.AUDIO_TRACK_LOAD_TIMEOUT : S.AUDIO_TRACK_LOAD_ERROR, l = !1;
                            break;
                        case Ce:
                            o = i ? S.SUBTITLE_TRACK_LOAD_TIMEOUT : S.SUBTITLE_LOAD_ERROR, l = !1
                    }
                    u && this.resetInternalLoader(t.type);
                    const c = {
                        type: E.NETWORK_ERROR,
                        details: o,
                        fatal: l,
                        url: t.url,
                        loader: u,
                        context: t,
                        error: a,
                        networkDetails: e,
                        stats: s
                    };
                    if (r) {
                        const i = (null == e ? void 0 : e.url) || t.url;
                        c.response = d({
                            url: i,
                            data: void 0
                        }, r)
                    }
                    this.hls.trigger(T.ERROR, c)
                }
                handlePlaylistLoaded(t, e, i, r, s, n) {
                    const a = this.hls,
                        {
                            type: o,
                            level: l,
                            id: u,
                            groupId: c,
                            deliveryDirectives: h
                        } = r,
                        d = Oe(e, r),
                        f = Me(r),
                        g = "number" == typeof r.level && f === Ie ? l : void 0;
                    if (!t.fragments.length) {
                        const t = new Error("No Segments found in Playlist");
                        return void a.trigger(T.ERROR, {
                            type: E.NETWORK_ERROR,
                            details: S.LEVEL_EMPTY_ERROR,
                            fatal: !1,
                            url: d,
                            error: t,
                            reason: t.message,
                            response: e,
                            context: r,
                            level: g,
                            parent: f,
                            networkDetails: s,
                            stats: i
                        })
                    }
                    t.targetduration || (t.playlistParsingError = new Error("Missing Target Duration"));
                    const m = t.playlistParsingError;
                    if (m) a.trigger(T.ERROR, {
                        type: E.NETWORK_ERROR,
                        details: S.LEVEL_PARSING_ERROR,
                        fatal: !1,
                        url: d,
                        error: m,
                        reason: m.message,
                        response: e,
                        context: r,
                        level: g,
                        parent: f,
                        networkDetails: s,
                        stats: i
                    });
                    else switch (t.live && n && (n.getCacheAge && (t.ageHeader = n.getCacheAge() || 0), n.getCacheAge && !isNaN(t.ageHeader) || (t.ageHeader = 0)), o) {
                        case we:
                        case _e:
                            a.trigger(T.LEVEL_LOADED, {
                                details: t,
                                level: g || 0,
                                id: u || 0,
                                stats: i,
                                networkDetails: s,
                                deliveryDirectives: h
                            });
                            break;
                        case De:
                            a.trigger(T.AUDIO_TRACK_LOADED, {
                                details: t,
                                id: u || 0,
                                groupId: c || "",
                                stats: i,
                                networkDetails: s,
                                deliveryDirectives: h
                            });
                            break;
                        case Ce:
                            a.trigger(T.SUBTITLE_TRACK_LOADED, {
                                details: t,
                                id: u || 0,
                                groupId: c || "",
                                stats: i,
                                networkDetails: s,
                                deliveryDirectives: h
                            })
                    }
                }
            }

            function Ne(t, e) {
                let i;
                try {
                    i = new Event("addtrack")
                } catch (t) {
                    i = document.createEvent("Event"), i.initEvent("addtrack", !1, !1)
                }
                i.track = t, e.dispatchEvent(i)
            }

            function Be(t, e) {
                const i = t.mode;
                if ("disabled" === i && (t.mode = "hidden"), t.cues && !t.cues.getCueById(e.id)) try {
                    if (t.addCue(e), !t.cues.getCueById(e.id)) throw new Error(`addCue is failed for: ${e}`)
                } catch (i) {
                    R.debug(`[texttrack-utils]: ${i}`);
                    try {
                        const i = new self.TextTrackCue(e.startTime, e.endTime, e.text);
                        i.id = e.id, t.addCue(i)
                    } catch (t) {
                        R.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${t}`)
                    }
                }
                "disabled" === i && (t.mode = i)
            }

            function Ue(t) {
                const e = t.mode;
                if ("disabled" === e && (t.mode = "hidden"), t.cues)
                    for (let e = t.cues.length; e--;) t.removeCue(t.cues[e]);
                "disabled" === e && (t.mode = e)
            }

            function $e(t, e, i, r) {
                const s = t.mode;
                if ("disabled" === s && (t.mode = "hidden"), t.cues && t.cues.length > 0) {
                    const s = function(t, e, i) {
                        const r = [],
                            s = function(t, e) {
                                if (e < t[0].startTime) return 0;
                                const i = t.length - 1;
                                if (e > t[i].endTime) return -1;
                                let r = 0,
                                    s = i;
                                for (; r <= s;) {
                                    const n = Math.floor((s + r) / 2);
                                    if (e < t[n].startTime) s = n - 1;
                                    else {
                                        if (!(e > t[n].startTime && r < i)) return n;
                                        r = n + 1
                                    }
                                }
                                return t[r].startTime - e < e - t[s].startTime ? r : s
                            }(t, e);
                        if (s > -1)
                            for (let n = s, a = t.length; n < a; n++) {
                                const s = t[n];
                                if (s.startTime >= e && s.endTime <= i) r.push(s);
                                else if (s.startTime > i) return r
                            }
                        return r
                    }(t.cues, e, i);
                    for (let e = 0; e < s.length; e++) r && !r(s[e]) || t.removeCue(s[e])
                }
                "disabled" === s && (t.mode = s)
            }

            function Ge(t) {
                const e = [];
                for (let i = 0; i < t.length; i++) {
                    const r = t[i];
                    "subtitles" !== r.kind && "captions" !== r.kind || !r.label || e.push(t[i])
                }
                return e
            }
            var He = "org.id3",
                Ve = "com.apple.quicktime.HLS",
                We = "https://aomedia.org/emsg/ID3";

            function Ke() {
                if ("undefined" != typeof self) return self.VTTCue || self.TextTrackCue
            }

            function je(t, e, i, r, s) {
                let n = new t(e, i, "");
                try {
                    n.value = r, s && (n.type = s)
                } catch (a) {
                    n = new t(e, i, JSON.stringify(s ? d({
                        type: s
                    }, r) : r))
                }
                return n
            }
            const qe = (() => {
                const t = Ke();
                try {
                    t && new t(0, Number.POSITIVE_INFINITY, "")
                } catch (t) {
                    return Number.MAX_VALUE
                }
                return Number.POSITIVE_INFINITY
            })();

            function Ye(t, e) {
                return t.getTime() / 1e3 - e
            }
            class ze {
                constructor(t) {
                    this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = t, this._registerListeners()
                }
                destroy() {
                    this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null
                }
                _registerListeners() {
                    const {
                        hls: t
                    } = this;
                    t.on(T.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(T.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(T.MANIFEST_LOADING, this.onManifestLoading, this), t.on(T.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), t.on(T.BUFFER_FLUSHING, this.onBufferFlushing, this), t.on(T.LEVEL_UPDATED, this.onLevelUpdated, this)
                }
                _unregisterListeners() {
                    const {
                        hls: t
                    } = this;
                    t.off(T.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(T.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(T.MANIFEST_LOADING, this.onManifestLoading, this), t.off(T.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), t.off(T.BUFFER_FLUSHING, this.onBufferFlushing, this), t.off(T.LEVEL_UPDATED, this.onLevelUpdated, this)
                }
                onMediaAttached(t, e) {
                    this.media = e.media
                }
                onMediaDetaching() {
                    this.id3Track && (Ue(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {})
                }
                onManifestLoading() {
                    this.dateRangeCuesAppended = {}
                }
                createTrack(t) {
                    const e = this.getID3Track(t.textTracks);
                    return e.mode = "hidden", e
                }
                getID3Track(t) {
                    if (this.media) {
                        for (let e = 0; e < t.length; e++) {
                            const i = t[e];
                            if ("metadata" === i.kind && "id3" === i.label) return Ne(i, this.media), i
                        }
                        return this.media.addTextTrack("metadata", "id3")
                    }
                }
                onFragParsingMetadata(t, e) {
                    if (!this.media) return;
                    const {
                        hls: {
                            config: {
                                enableEmsgMetadataCues: i,
                                enableID3MetadataCues: r
                            }
                        }
                    } = this;
                    if (!i && !r) return;
                    const {
                        samples: s
                    } = e;
                    this.id3Track || (this.id3Track = this.createTrack(this.media));
                    const n = Ke();
                    if (n)
                        for (let t = 0; t < s.length; t++) {
                            const e = s[t].type;
                            if (e === We && !i || !r) continue;
                            const a = gt(s[t].data);
                            if (a) {
                                const i = s[t].pts;
                                let r = i + s[t].duration;
                                r > qe && (r = qe);
                                r - i <= 0 && (r = i + .25);
                                for (let t = 0; t < a.length; t++) {
                                    const s = a[t];
                                    if (!dt(s)) {
                                        this.updateId3CueEnds(i, e);
                                        const t = je(n, i, r, s, e);
                                        t && this.id3Track.addCue(t)
                                    }
                                }
                            }
                        }
                }
                updateId3CueEnds(t, e) {
                    var i;
                    const r = null == (i = this.id3Track) ? void 0 : i.cues;
                    if (r)
                        for (let i = r.length; i--;) {
                            const s = r[i];
                            s.type === e && s.startTime < t && s.endTime === qe && (s.endTime = t)
                        }
                }
                onBufferFlushing(t, {
                    startOffset: e,
                    endOffset: i,
                    type: r
                }) {
                    const {
                        id3Track: s,
                        hls: n
                    } = this;
                    if (!n) return;
                    const {
                        config: {
                            enableEmsgMetadataCues: a,
                            enableID3MetadataCues: o
                        }
                    } = n;
                    if (s && (a || o)) {
                        let t;
                        t = "audio" === r ? t => t.type === He && o : "video" === r ? t => t.type === We && a : t => t.type === He && o || t.type === We && a, $e(s, e, i, t)
                    }
                }
                onLevelUpdated(t, {
                    details: e
                }) {
                    if (!this.media || !e.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) return;
                    const {
                        dateRangeCuesAppended: i,
                        id3Track: r
                    } = this, {
                        dateRanges: s
                    } = e, n = Object.keys(s);
                    if (r) {
                        const t = Object.keys(i).filter((t => !n.includes(t)));
                        for (let e = t.length; e--;) {
                            const s = t[e];
                            Object.keys(i[s].cues).forEach((t => {
                                r.removeCue(i[s].cues[t])
                            })), delete i[s]
                        }
                    }
                    const a = e.fragments[e.fragments.length - 1];
                    if (0 === n.length || !p(null == a ? void 0 : a.programDateTime)) return;
                    this.id3Track || (this.id3Track = this.createTrack(this.media));
                    const o = a.programDateTime / 1e3 - a.start,
                        l = Ke();
                    for (let t = 0; t < n.length; t++) {
                        const e = n[t],
                            r = s[e],
                            a = Ye(r.startDate, o),
                            h = i[e],
                            d = (null == h ? void 0 : h.cues) || {};
                        let f = (null == h ? void 0 : h.durationKnown) || !1,
                            g = qe;
                        const m = r.endDate;
                        if (m) g = Ye(m, o), f = !0;
                        else if (r.endOnNext && !f) {
                            const t = n.reduce(((t, e) => {
                                if (e !== r.id) {
                                    const i = s[e];
                                    if (i.class === r.class && i.startDate > r.startDate && (!t || r.startDate < t.startDate)) return i
                                }
                                return t
                            }), null);
                            t && (g = Ye(t.startDate, o), f = !0)
                        }
                        const p = Object.keys(r.attr);
                        for (let t = 0; t < p.length; t++) {
                            const i = p[t];
                            if ("ID" === (c = i) || "CLASS" === c || "START-DATE" === c || "DURATION" === c || "END-DATE" === c || "END-ON-NEXT" === c) continue;
                            const s = d[i];
                            if (s) f && !h.durationKnown && (s.endTime = g);
                            else if (l) {
                                let t = r.attr[i];
                                C(i) && (u = t, t = Uint8Array.from(u.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer);
                                const s = je(l, a, g, {
                                    key: i,
                                    data: t
                                }, Ve);
                                s && (s.id = e, this.id3Track.addCue(s), d[i] = s)
                            }
                        }
                        i[e] = {
                            cues: d,
                            dateRange: r,
                            durationKnown: f
                        }
                    }
                    var u, c
                }
            }
            class Xe {
                constructor(t) {
                    this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = () => this.timeupdate(), this.hls = t, this.config = t.config, this.registerListeners()
                }
                get latency() {
                    return this._latency || 0
                }
                get maxLatency() {
                    const {
                        config: t,
                        levelDetails: e
                    } = this;
                    return void 0 !== t.liveMaxLatencyDuration ? t.liveMaxLatencyDuration : e ? t.liveMaxLatencyDurationCount * e.targetduration : 0
                }
                get targetLatency() {
                    const {
                        levelDetails: t
                    } = this;
                    if (null === t) return null;
                    const {
                        holdBack: e,
                        partHoldBack: i,
                        targetduration: r
                    } = t, {
                        liveSyncDuration: s,
                        liveSyncDurationCount: n,
                        lowLatencyMode: a
                    } = this.config, o = this.hls.userConfig;
                    let l = a && i || e;
                    (o.liveSyncDuration || o.liveSyncDurationCount || 0 === l) && (l = void 0 !== s ? s : n * r);
                    const u = r;
                    return l + Math.min(1 * this.stallCount, u)
                }
                get liveSyncPosition() {
                    const t = this.estimateLiveEdge(),
                        e = this.targetLatency,
                        i = this.levelDetails;
                    if (null === t || null === e || null === i) return null;
                    const r = i.edge,
                        s = t - e - this.edgeStalled,
                        n = r - i.totalduration,
                        a = r - (this.config.lowLatencyMode && i.partTarget || i.targetduration);
                    return Math.min(Math.max(n, s), a)
                }
                get drift() {
                    const {
                        levelDetails: t
                    } = this;
                    return null === t ? 1 : t.drift
                }
                get edgeStalled() {
                    const {
                        levelDetails: t
                    } = this;
                    if (null === t) return 0;
                    const e = 3 * (this.config.lowLatencyMode && t.partTarget || t.targetduration);
                    return Math.max(t.age - e, 0)
                }
                get forwardBufferLength() {
                    const {
                        media: t,
                        levelDetails: e
                    } = this;
                    if (!t || !e) return 0;
                    const i = t.buffered.length;
                    return (i ? t.buffered.end(i - 1) : e.edge) - this.currentTime
                }
                destroy() {
                    this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null
                }
                registerListeners() {
                    this.hls.on(T.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(T.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(T.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(T.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(T.ERROR, this.onError, this)
                }
                unregisterListeners() {
                    this.hls.off(T.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(T.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.off(T.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(T.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.off(T.ERROR, this.onError, this)
                }
                onMediaAttached(t, e) {
                    this.media = e.media, this.media.addEventListener("timeupdate", this.timeupdateHandler)
                }
                onMediaDetaching() {
                    this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null)
                }
                onManifestLoading() {
                    this.levelDetails = null, this._latency = null, this.stallCount = 0
                }
                onLevelUpdated(t, {
                    details: e
                }) {
                    this.levelDetails = e, e.advanced && this.timeupdate(), !e.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler)
                }
                onError(t, e) {
                    var i;
                    e.details === S.BUFFER_STALLED_ERROR && (this.stallCount++, null != (i = this.levelDetails) && i.live && R.warn("[playback-rate-controller]: Stall detected, adjusting target latency"))
                }
                timeupdate() {
                    const {
                        media: t,
                        levelDetails: e
                    } = this;
                    if (!t || !e) return;
                    this.currentTime = t.currentTime;
                    const i = this.computeLatency();
                    if (null === i) return;
                    this._latency = i;
                    const {
                        lowLatencyMode: r,
                        maxLiveSyncPlaybackRate: s
                    } = this.config;
                    if (!r || 1 === s || !e.live) return;
                    const n = this.targetLatency;
                    if (null === n) return;
                    const a = i - n;
                    if (a < Math.min(this.maxLatency, n + e.targetduration) && a > .05 && this.forwardBufferLength > 1) {
                        const e = Math.min(2, Math.max(1, s)),
                            i = Math.round(2 / (1 + Math.exp(-.75 * a - this.edgeStalled)) * 20) / 20;
                        t.playbackRate = Math.min(e, Math.max(1, i))
                    } else 1 !== t.playbackRate && 0 !== t.playbackRate && (t.playbackRate = 1)
                }
                estimateLiveEdge() {
                    const {
                        levelDetails: t
                    } = this;
                    return null === t ? null : t.edge + t.age
                }
                computeLatency() {
                    const t = this.estimateLiveEdge();
                    return null === t ? null : t - this.currentTime
                }
            }
            const Qe = ["NONE", "TYPE-0", "TYPE-1", null];
            const Je = ["SDR", "PQ", "HLG"];
            var Ze = "",
                ti = "YES",
                ei = "v2";

            function ii(t) {
                const {
                    canSkipUntil: e,
                    canSkipDateRanges: i,
                    age: r
                } = t;
                return e && r < e / 2 ? i ? ei : ti : Ze
            }
            class ri {
                constructor(t, e, i) {
                    this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = t, this.part = e, this.skip = i
                }
                addDirectives(t) {
                    const e = new self.URL(t);
                    return void 0 !== this.msn && e.searchParams.set("_HLS_msn", this.msn.toString()), void 0 !== this.part && e.searchParams.set("_HLS_part", this.part.toString()), this.skip && e.searchParams.set("_HLS_skip", this.skip), e.href
                }
            }
            class si {
                constructor(t) {
                    this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.url = void 0, this.frameRate = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.supportedPromise = void 0, this.supportedResult = void 0, this._avgBitrate = 0, this._audioGroups = void 0, this._subtitleGroups = void 0, this._urlId = 0, this.url = [t.url], this._attrs = [t.attrs], this.bitrate = t.bitrate, t.details && (this.details = t.details), this.id = t.id || 0, this.name = t.name, this.width = t.width || 0, this.height = t.height || 0, this.frameRate = t.attrs.optionalFloat("FRAME-RATE", 0), this._avgBitrate = t.attrs.decimalInteger("AVERAGE-BANDWIDTH"), this.audioCodec = t.audioCodec, this.videoCodec = t.videoCodec, this.codecSet = [t.videoCodec, t.audioCodec].filter((t => !!t)).map((t => t.substring(0, 4))).join(","), this.addGroupId("audio", t.attrs.AUDIO), this.addGroupId("text", t.attrs.SUBTITLES)
                }
                get maxBitrate() {
                    return Math.max(this.realBitrate, this.bitrate)
                }
                get averageBitrate() {
                    return this._avgBitrate || this.realBitrate || this.bitrate
                }
                get attrs() {
                    return this._attrs[0]
                }
                get codecs() {
                    return this.attrs.CODECS || ""
                }
                get pathwayId() {
                    return this.attrs["PATHWAY-ID"] || "."
                }
                get videoRange() {
                    return this.attrs["VIDEO-RANGE"] || "SDR"
                }
                get score() {
                    return this.attrs.optionalFloat("SCORE", 0)
                }
                get uri() {
                    return this.url[0] || ""
                }
                hasAudioGroup(t) {
                    return ni(this._audioGroups, t)
                }
                hasSubtitleGroup(t) {
                    return ni(this._subtitleGroups, t)
                }
                get audioGroups() {
                    return this._audioGroups
                }
                get subtitleGroups() {
                    return this._subtitleGroups
                }
                addGroupId(t, e) {
                    if (e)
                        if ("audio" === t) {
                            let t = this._audioGroups;
                            t || (t = this._audioGroups = []), -1 === t.indexOf(e) && t.push(e)
                        } else if ("text" === t) {
                        let t = this._subtitleGroups;
                        t || (t = this._subtitleGroups = []), -1 === t.indexOf(e) && t.push(e)
                    }
                }
                get urlId() {
                    return 0
                }
                set urlId(t) {}
                get audioGroupIds() {
                    return this.audioGroups ? [this.audioGroupId] : void 0
                }
                get textGroupIds() {
                    return this.subtitleGroups ? [this.textGroupId] : void 0
                }
                get audioGroupId() {
                    var t;
                    return null == (t = this.audioGroups) ? void 0 : t[0]
                }
                get textGroupId() {
                    var t;
                    return null == (t = this.subtitleGroups) ? void 0 : t[0]
                }
                addFallback() {}
            }

            function ni(t, e) {
                return !(!e || !t) && -1 !== t.indexOf(e)
            }

            function ai(t, e) {
                const i = e.startPTS;
                if (p(i)) {
                    let r, s = 0;
                    e.sn > t.sn ? (s = i - t.start, r = t) : (s = t.start - i, r = e), r.duration !== s && (r.duration = s)
                } else if (e.sn > t.sn) {
                    t.cc === e.cc && t.minEndPTS ? e.start = t.start + (t.minEndPTS - t.start) : e.start = t.start + t.duration
                } else e.start = Math.max(t.start - e.duration, 0)
            }

            function oi(t, e, i, r, s, n) {
                r - i <= 0 && (R.warn("Fragment should have a positive duration", e), r = i + e.duration, n = s + e.duration);
                let a = i,
                    o = r;
                const l = e.startPTS,
                    u = e.endPTS;
                if (p(l)) {
                    const t = Math.abs(l - i);
                    p(e.deltaPTS) ? e.deltaPTS = Math.max(t, e.deltaPTS) : e.deltaPTS = t, a = Math.max(i, l), i = Math.min(i, l), s = Math.min(s, e.startDTS), o = Math.min(r, u), r = Math.max(r, u), n = Math.max(n, e.endDTS)
                }
                const c = i - e.start;
                0 !== e.start && (e.start = i), e.duration = r - e.start, e.startPTS = i, e.maxStartPTS = a, e.startDTS = s, e.endPTS = r, e.minEndPTS = o, e.endDTS = n;
                const h = e.sn;
                if (!t || h < t.startSN || h > t.endSN) return 0;
                let d;
                const f = h - t.startSN,
                    g = t.fragments;
                for (g[f] = e, d = f; d > 0; d--) ai(g[d], g[d - 1]);
                for (d = f; d < g.length - 1; d++) ai(g[d], g[d + 1]);
                return t.fragmentHint && ai(g[g.length - 1], t.fragmentHint), t.PTSKnown = t.alignedSliding = !0, c
            }

            function li(t, e) {
                let i = null;
                const r = t.fragments;
                for (let t = r.length - 1; t >= 0; t--) {
                    const e = r[t].initSegment;
                    if (e) {
                        i = e;
                        break
                    }
                }
                t.fragmentHint && delete t.fragmentHint.endPTS;
                let s, n = 0;
                if (function(t, e, i) {
                        const r = e.skippedSegments,
                            s = Math.max(t.startSN, e.startSN) - e.startSN,
                            n = (t.fragmentHint ? 1 : 0) + (r ? e.endSN : Math.min(t.endSN, e.endSN)) - e.startSN,
                            a = e.startSN - t.startSN,
                            o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments,
                            l = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments;
                        for (let t = s; t <= n; t++) {
                            const s = l[a + t];
                            let n = o[t];
                            r && !n && t < r && (n = e.fragments[t] = s), s && n && i(s, n)
                        }
                    }(t, e, ((t, r) => {
                        t.relurl && (n = t.cc - r.cc), p(t.startPTS) && p(t.endPTS) && (r.start = r.startPTS = t.startPTS, r.startDTS = t.startDTS, r.maxStartPTS = t.maxStartPTS, r.endPTS = t.endPTS, r.endDTS = t.endDTS, r.minEndPTS = t.minEndPTS, r.duration = t.endPTS - t.startPTS, r.duration && (s = r), e.PTSKnown = e.alignedSliding = !0), r.elementaryStreams = t.elementaryStreams, r.loader = t.loader, r.stats = t.stats, t.initSegment && (r.initSegment = t.initSegment, i = t.initSegment)
                    })), i) {
                    (e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments).forEach((t => {
                        var e;
                        !t || t.initSegment && t.initSegment.relurl !== (null == (e = i) ? void 0 : e.relurl) || (t.initSegment = i)
                    }))
                }
                if (e.skippedSegments)
                    if (e.deltaUpdateFailed = e.fragments.some((t => !t)), e.deltaUpdateFailed) {
                        R.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
                        for (let t = e.skippedSegments; t--;) e.fragments.shift();
                        e.startSN = e.fragments[0].sn, e.startCC = e.fragments[0].cc
                    } else e.canSkipDateRanges && (e.dateRanges = function(t, e, i) {
                        const r = m({}, t);
                        i && i.forEach((t => {
                            delete r[t]
                        }));
                        return Object.keys(e).forEach((t => {
                            const i = new I(e[t].attr, r[t]);
                            i.isValid ? r[t] = i : R.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(e[t].attr)}"`)
                        })), r
                    }(t.dateRanges, e.dateRanges, e.recentlyRemovedDateranges));
                const a = e.fragments;
                if (n) {
                    R.warn("discontinuity sliding from playlist, take drift into account");
                    for (let t = 0; t < a.length; t++) a[t].cc += n
                }
                e.skippedSegments && (e.startCC = e.fragments[0].cc),
                    function(t, e, i) {
                        if (t && e) {
                            let r = 0;
                            for (let s = 0, n = t.length; s <= n; s++) {
                                const n = t[s],
                                    a = e[s + r];
                                n && a && n.index === a.index && n.fragment.sn === a.fragment.sn ? i(n, a) : r--
                            }
                        }
                    }(t.partList, e.partList, ((t, e) => {
                        e.elementaryStreams = t.elementaryStreams, e.stats = t.stats
                    })), s ? oi(e, s, s.startPTS, s.endPTS, s.startDTS, s.endDTS) : ui(t, e), a.length && (e.totalduration = e.edge - a[0].start), e.driftStartTime = t.driftStartTime, e.driftStart = t.driftStart;
                const o = e.advancedDateTime;
                if (e.advanced && o) {
                    const t = e.edge;
                    e.driftStart || (e.driftStartTime = o, e.driftStart = t), e.driftEndTime = o, e.driftEnd = t
                } else e.driftEndTime = t.driftEndTime, e.driftEnd = t.driftEnd, e.advancedDateTime = t.advancedDateTime
            }

            function ui(t, e) {
                const i = e.startSN + e.skippedSegments - t.startSN,
                    r = t.fragments;
                i < 0 || i >= r.length || ci(e, r[i].start)
            }

            function ci(t, e) {
                if (e) {
                    const i = t.fragments;
                    for (let r = t.skippedSegments; r < i.length; r++) i[r].start += e;
                    t.fragmentHint && (t.fragmentHint.start += e)
                }
            }

            function hi(t, e, i) {
                var r;
                return null != t && t.details ? di(null == (r = t.details) ? void 0 : r.partList, e, i) : null
            }

            function di(t, e, i) {
                if (t)
                    for (let r = t.length; r--;) {
                        const s = t[r];
                        if (s.index === i && s.fragment.sn === e) return s
                    }
                return null
            }

            function fi(t) {
                t.forEach(((t, e) => {
                    const {
                        details: i
                    } = t;
                    null != i && i.fragments && i.fragments.forEach((t => {
                        t.level = e
                    }))
                }))
            }

            function gi(t) {
                switch (t.details) {
                    case S.FRAG_LOAD_TIMEOUT:
                    case S.KEY_LOAD_TIMEOUT:
                    case S.LEVEL_LOAD_TIMEOUT:
                    case S.MANIFEST_LOAD_TIMEOUT:
                        return !0
                }
                return !1
            }

            function mi(t, e) {
                const i = gi(e);
                return t.default[(i ? "timeout" : "error") + "Retry"]
            }

            function pi(t, e) {
                const i = "linear" === t.backoff ? 1 : Math.pow(2, e);
                return Math.min(i * t.retryDelayMs, t.maxRetryDelayMs)
            }

            function vi(t) {
                return d(d({}, t), {
                    errorRetry: null,
                    timeoutRetry: null
                })
            }

            function yi(t, e, i, r) {
                if (!t) return !1;
                const s = null == r ? void 0 : r.code,
                    n = e < t.maxNumRetry && (function(t) {
                        return 0 === t && !1 === navigator.onLine || !!t && (t < 400 || t > 499)
                    }(s) || !!i);
                return t.shouldRetry ? t.shouldRetry(t, e, i, r, n) : n
            }
            const Ti = function(t, e) {
                let i = 0,
                    r = t.length - 1,
                    s = null,
                    n = null;
                for (; i <= r;) {
                    s = (i + r) / 2 | 0, n = t[s];
                    const a = e(n);
                    if (a > 0) i = s + 1;
                    else {
                        if (!(a < 0)) return n;
                        r = s - 1
                    }
                }
                return null
            };

            function Ei(t, e, i = 0, r = 0, s = .005) {
                let n = null;
                if (t) {
                    n = e[t.sn - e[0].sn + 1] || null;
                    const r = t.endDTS - i;
                    r > 0 && r < 15e-7 && (i += 15e-7)
                } else 0 === i && 0 === e[0].start && (n = e[0]);
                if (n && ((!t || t.level === n.level) && 0 === Si(i, r, n) || function(t, e, i) {
                        if (e && 0 === e.start && e.level < t.level && (e.endPTS || 0) > 0) {
                            const r = e.tagList.reduce(((t, e) => ("INF" === e[0] && (t += parseFloat(e[1])), t)), i);
                            return t.start <= r
                        }
                        return !1
                    }(n, t, Math.min(s, r)))) return n;
                const a = Ti(e, Si.bind(null, i, r));
                return !a || a === t && n ? n : a
            }

            function Si(t = 0, e = 0, i) {
                if (i.start <= t && i.start + i.duration > t) return 0;
                const r = Math.min(e, i.duration + (i.deltaPTS ? i.deltaPTS : 0));
                return i.start + i.duration - r <= t ? 1 : i.start - r > t && i.start ? -1 : 0
            }

            function bi(t, e, i) {
                const r = 1e3 * Math.min(e, i.duration + (i.deltaPTS ? i.deltaPTS : 0));
                return (i.endProgramDateTime || 0) - r > t
            }
            var Ai = 0,
                Li = 2,
                ki = 3,
                Ri = 5,
                wi = 0,
                _i = 1,
                Di = 2;
            class Ci {
                constructor(t, e) {
                    this.hls = void 0, this.timer = -1, this.requestScheduled = -1, this.canLoad = !1, this.log = void 0, this.warn = void 0, this.log = R.log.bind(R, `${e}:`), this.warn = R.warn.bind(R, `${e}:`), this.hls = t
                }
                destroy() {
                    this.clearTimer(), this.hls = this.log = this.warn = null
                }
                clearTimer() {
                    -1 !== this.timer && (self.clearTimeout(this.timer), this.timer = -1)
                }
                startLoad() {
                    this.canLoad = !0, this.requestScheduled = -1, this.loadPlaylist()
                }
                stopLoad() {
                    this.canLoad = !1, this.clearTimer()
                }
                switchParams(t, e, i) {
                    const r = null == e ? void 0 : e.renditionReports;
                    if (r) {
                        let s = -1;
                        for (let i = 0; i < r.length; i++) {
                            const n = r[i];
                            let a;
                            try {
                                a = new self.URL(n.URI, e.url).href
                            } catch (t) {
                                R.warn(`Could not construct new URL for Rendition Report: ${t}`), a = n.URI || ""
                            }
                            if (a === t) {
                                s = i;
                                break
                            }
                            a === t.substring(0, a.length) && (s = i)
                        }
                        if (-1 !== s) {
                            const t = r[s],
                                n = parseInt(t["LAST-MSN"]) || (null == e ? void 0 : e.lastPartSn);
                            let a = parseInt(t["LAST-PART"]) || (null == e ? void 0 : e.lastPartIndex);
                            if (this.hls.config.lowLatencyMode) {
                                const t = Math.min(e.age - e.partTarget, e.targetduration);
                                a >= 0 && t > e.partTarget && (a += 1)
                            }
                            const o = i && ii(i);
                            return new ri(n, a >= 0 ? a : void 0, o)
                        }
                    }
                }
                loadPlaylist(t) {
                    -1 === this.requestScheduled && (this.requestScheduled = self.performance.now())
                }
                shouldLoadPlaylist(t) {
                    return this.canLoad && !!t && !!t.url && (!t.details || t.details.live)
                }
                shouldReloadPlaylist(t) {
                    return -1 === this.timer && -1 === this.requestScheduled && this.shouldLoadPlaylist(t)
                }
                playlistLoaded(t, e, i) {
                    const {
                        details: r,
                        stats: s
                    } = e, n = self.performance.now(), a = s.loading.first ? Math.max(0, n - s.loading.first) : 0;
                    if (r.advancedDateTime = Date.now() - a, r.live || null != i && i.live) {
                        if (r.reloaded(i), i && this.log(`live playlist ${t} ${r.advanced?"REFRESHED "+r.lastPartSn+"-"+r.lastPartIndex:r.updated?"UPDATED":"MISSED"}`), i && r.fragments.length > 0 && li(i, r), !this.canLoad || !r.live) return;
                        let a, o, l;
                        if (r.canBlockReload && r.endSN && r.advanced) {
                            const t = this.hls.config.lowLatencyMode,
                                s = r.lastPartSn,
                                n = r.endSN,
                                u = r.lastPartIndex,
                                c = s === n; - 1 !== u ? (o = c ? n + 1 : s, l = c ? t ? 0 : u : u + 1) : o = n + 1;
                            const h = r.age,
                                d = h + r.ageHeader;
                            let f = Math.min(d - r.partTarget, 1.5 * r.targetduration);
                            if (f > 0) {
                                if (i && f > i.tuneInGoal) this.warn(`CDN Tune-in goal increased from: ${i.tuneInGoal} to: ${f} with playlist age: ${r.age}`), f = 0;
                                else {
                                    const t = Math.floor(f / r.targetduration);
                                    if (o += t, void 0 !== l) {
                                        l += Math.round(f % r.targetduration / r.partTarget)
                                    }
                                    this.log(`CDN Tune-in age: ${r.ageHeader}s last advanced ${h.toFixed(2)}s goal: ${f} skip sn ${t} to part ${l}`)
                                }
                                r.tuneInGoal = f
                            }
                            if (a = this.getDeliveryDirectives(r, e.deliveryDirectives, o, l), t || !c) return void this.loadPlaylist(a)
                        } else(r.canBlockReload || r.canSkipUntil) && (a = this.getDeliveryDirectives(r, e.deliveryDirectives, o, l));
                        const u = this.hls.mainForwardBufferInfo,
                            c = u ? u.end - u.len : 0,
                            h = function(t, e = Infinity) {
                                let i = 1e3 * t.targetduration;
                                if (t.updated) {
                                    const r = t.fragments,
                                        s = 4;
                                    if (r.length && i * s > e) {
                                        const t = 1e3 * r[r.length - 1].duration;
                                        t < i && (i = t)
                                    }
                                } else i /= 2;
                                return Math.round(i)
                            }(r, 1e3 * (r.edge - c));
                        r.updated && n > this.requestScheduled + h && (this.requestScheduled = s.loading.start), void 0 !== o && r.canBlockReload ? this.requestScheduled = s.loading.first + h - (1e3 * r.partTarget || 1e3) : -1 === this.requestScheduled || this.requestScheduled + h < n ? this.requestScheduled = n : this.requestScheduled - n <= 0 && (this.requestScheduled += h);
                        let d = this.requestScheduled - n;
                        d = Math.max(0, d), this.log(`reload live playlist ${t} in ${Math.round(d)} ms`), this.timer = self.setTimeout((() => this.loadPlaylist(a)), d)
                    } else this.clearTimer()
                }
                getDeliveryDirectives(t, e, i, r) {
                    let s = ii(t);
                    return null != e && e.skip && t.deltaUpdateFailed && (i = e.msn, r = e.part, s = Ze), new ri(i, r, s)
                }
                checkRetry(t) {
                    const e = t.details,
                        i = gi(t),
                        r = t.errorAction,
                        {
                            action: s,
                            retryCount: n = 0,
                            retryConfig: a
                        } = r || {},
                        o = !!r && !!a && (s === Ri || !r.resolved && s === Li);
                    if (o) {
                        var l;
                        if (this.requestScheduled = -1, n >= a.maxNumRetry) return !1;
                        if (i && null != (l = t.context) && l.deliveryDirectives) this.warn(`Retrying playlist loading ${n+1}/${a.maxNumRetry} after "${e}" without delivery-directives`), this.loadPlaylist();
                        else {
                            const t = pi(a, n);
                            this.timer = self.setTimeout((() => this.loadPlaylist()), t), this.warn(`Retrying playlist loading ${n+1}/${a.maxNumRetry} after "${e}" in ${t}ms`)
                        }
                        t.levelRetry = !0, r.resolved = !0
                    }
                    return o
                }
            }
            class Ii {
                constructor(t, e = 0, i = 0) {
                    this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = t, this.alpha_ = t ? Math.exp(Math.log(.5) / t) : 0, this.estimate_ = e, this.totalWeight_ = i
                }
                sample(t, e) {
                    const i = Math.pow(this.alpha_, t);
                    this.estimate_ = e * (1 - i) + i * this.estimate_, this.totalWeight_ += t
                }
                getTotalWeight() {
                    return this.totalWeight_
                }
                getEstimate() {
                    if (this.alpha_) {
                        const t = 1 - Math.pow(this.alpha_, this.totalWeight_);
                        if (t) return this.estimate_ / t
                    }
                    return this.estimate_
                }
            }
            class Pi {
                constructor(t, e, i, r = 100) {
                    this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = i, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new Ii(t), this.fast_ = new Ii(e), this.defaultTTFB_ = r, this.ttfb_ = new Ii(t)
                }
                update(t, e) {
                    const {
                        slow_: i,
                        fast_: r,
                        ttfb_: s
                    } = this;
                    i.halfLife !== t && (this.slow_ = new Ii(t, i.getEstimate(), i.getTotalWeight())), r.halfLife !== e && (this.fast_ = new Ii(e, r.getEstimate(), r.getTotalWeight())), s.halfLife !== t && (this.ttfb_ = new Ii(t, s.getEstimate(), s.getTotalWeight()))
                }
                sample(t, e) {
                    const i = (t = Math.max(t, this.minDelayMs_)) / 1e3,
                        r = 8 * e / i;
                    this.fast_.sample(i, r), this.slow_.sample(i, r)
                }
                sampleTTFB(t) {
                    const e = t / 1e3,
                        i = Math.sqrt(2) * Math.exp(-Math.pow(e, 2) / 2);
                    this.ttfb_.sample(i, Math.max(t, 5))
                }
                canEstimate() {
                    return this.fast_.getTotalWeight() >= this.minWeight_
                }
                getEstimate() {
                    return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
                }
                getEstimateTTFB() {
                    return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_
                }
                destroy() {}
            }
            const xi = {
                    supported: !0,
                    configurations: [],
                    decodingInfoResults: [{
                        supported: !0,
                        powerEfficient: !0,
                        smooth: !0
                    }]
                },
                Mi = {};

            function Oi(t, e, i, r, s, n) {
                const a = t.audioCodec ? t.audioGroups : null,
                    o = null == n ? void 0 : n.audioCodec,
                    l = null == n ? void 0 : n.channels,
                    u = l ? parseInt(l) : o ? Infinity : 2;
                let c = null;
                if (null != a && a.length) try {
                    c = 1 === a.length && a[0] ? e.groups[a[0]].channels : a.reduce(((t, i) => {
                        if (i) {
                            const r = e.groups[i];
                            if (!r) throw new Error(`Audio track group ${i} not found`);
                            Object.keys(r.channels).forEach((e => {
                                t[e] = (t[e] || 0) + r.channels[e]
                            }))
                        }
                        return t
                    }), {
                        2: 0
                    })
                } catch (t) {
                    return !0
                }
                return void 0 !== t.videoCodec && (t.width > 1920 && t.height > 1088 || t.height > 1920 && t.width > 1088 || t.frameRate > Math.max(r, 30) || "SDR" !== t.videoRange && t.videoRange !== i || t.bitrate > Math.max(s, 8e6)) || !!c && p(u) && Object.keys(c).some((t => parseInt(t) > u))
            }

            function Fi(t, e, i) {
                const r = t.videoCodec,
                    s = t.audioCodec;
                if (!r || !s || !i) return Promise.resolve(xi);
                const n = {
                        width: t.width,
                        height: t.height,
                        bitrate: Math.ceil(Math.max(.9 * t.bitrate, t.averageBitrate)),
                        framerate: t.frameRate || 30
                    },
                    a = t.videoRange;
                "SDR" !== a && (n.transferFunction = a.toLowerCase());
                const o = r.split(",").map((t => ({
                    type: "media-source",
                    video: d(d({}, n), {}, {
                        contentType: oe(t, "video")
                    })
                })));
                return s && t.audioGroups && t.audioGroups.forEach((t => {
                    var i;
                    t && (null == (i = e.groups[t]) || i.tracks.forEach((e => {
                        if (e.groupId === t) {
                            const t = e.channels || "",
                                i = parseFloat(t);
                            p(i) && i > 2 && o.push.apply(o, s.split(",").map((t => ({
                                type: "media-source",
                                audio: {
                                    contentType: oe(t, "audio"),
                                    channels: "" + i
                                }
                            }))))
                        }
                    })))
                })), Promise.all(o.map((t => {
                    const e = function(t) {
                        const {
                            audio: e,
                            video: i
                        } = t, r = i || e;
                        if (r) {
                            const t = r.contentType.split('"')[1];
                            if (i) return `r${i.height}x${i.width}f${Math.ceil(i.framerate)}${i.transferFunction||"sd"}_${t}_${Math.ceil(i.bitrate/1e5)}`;
                            if (e) return `c${e.channels}${e.spatialRendering?"s":"n"}_${t}`
                        }
                        return ""
                    }(t);
                    return Mi[e] || (Mi[e] = i.decodingInfo(t))
                }))).then((t => ({
                    supported: !t.some((t => !t.supported)),
                    configurations: o,
                    decodingInfoResults: t
                }))).catch((t => ({
                    supported: !1,
                    configurations: o,
                    decodingInfoResults: [],
                    error: t
                })))
            }

            function Ni(t, e) {
                let i = !1,
                    r = [];
                return t && (i = "SDR" !== t, r = [t]), e && (r = e.allowedVideoRanges || Je.slice(0), i = void 0 !== e.preferHDR ? e.preferHDR : function() {
                    if ("function" == typeof matchMedia) {
                        const t = matchMedia("(dynamic-range: high)"),
                            e = matchMedia("bad query");
                        if (t.media !== e.media) return !0 === t.matches
                    }
                    return !1
                }(), r = i ? r.filter((t => "SDR" !== t)) : ["SDR"]), {
                    preferHDR: i,
                    allowedVideoRanges: r
                }
            }

            function Bi(t, e) {
                R.log(`[abr] start candidates with "${t}" ignored because ${e}`)
            }

            function Ui(t, e, i) {
                if ("attrs" in t) {
                    const i = e.indexOf(t);
                    if (-1 !== i) return i
                }
                for (let r = 0; r < e.length; r++) {
                    if ($i(t, e[r], i)) return r
                }
                return -1
            }

            function $i(t, e, i) {
                const {
                    groupId: r,
                    name: s,
                    lang: n,
                    assocLang: a,
                    characteristics: o,
                    default: l
                } = t, u = t.forced;
                return (void 0 === r || e.groupId === r) && (void 0 === s || e.name === s) && (void 0 === n || e.lang === n) && (void 0 === n || e.assocLang === a) && (void 0 === l || e.default === l) && (void 0 === u || e.forced === u) && (void 0 === o || function(t, e = "") {
                    const i = t.split(","),
                        r = e.split(",");
                    return i.length === r.length && !i.some((t => -1 === r.indexOf(t)))
                }(o, e.characteristics)) && (void 0 === i || i(t, e))
            }

            function Gi(t, e) {
                const {
                    audioCodec: i,
                    channels: r
                } = t;
                return !(void 0 !== i && (e.audioCodec || "").substring(0, 4) !== i.substring(0, 4) || void 0 !== r && r !== (e.channels || "2"))
            }

            function Hi(t, e, i) {
                for (let r = e; r; r--)
                    if (i(t[r])) return r;
                for (let r = e + 1; r < t.length; r++)
                    if (i(t[r])) return r;
                return -1
            }
            class Vi {
                constructor() {
                    this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this)
                }
                destroy() {
                    this.onHandlerDestroying(), this.onHandlerDestroyed()
                }
                onHandlerDestroying() {
                    this.clearNextTick(), this.clearInterval()
                }
                onHandlerDestroyed() {}
                hasInterval() {
                    return !!this._tickInterval
                }
                hasNextTick() {
                    return !!this._tickTimer
                }
                setInterval(t) {
                    return !this._tickInterval && (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, t), !0)
                }
                clearInterval() {
                    return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, !0)
                }
                clearNextTick() {
                    return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0)
                }
                tick() {
                    this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0)
                }
                tickImmediate() {
                    this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0)
                }
                doTick() {}
            }
            var Wi = "NOT_LOADED",
                Ki = "APPENDING",
                ji = "PARTIAL",
                qi = "OK";
            class Yi {
                constructor(t) {
                    this.activePartLists = Object.create(null), this.endListFragments = Object.create(null), this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hasGaps = !1, this.hls = t, this._registerListeners()
                }
                _registerListeners() {
                    const {
                        hls: t
                    } = this;
                    t.on(T.BUFFER_APPENDED, this.onBufferAppended, this), t.on(T.FRAG_BUFFERED, this.onFragBuffered, this), t.on(T.FRAG_LOADED, this.onFragLoaded, this)
                }
                _unregisterListeners() {
                    const {
                        hls: t
                    } = this;
                    t.off(T.BUFFER_APPENDED, this.onBufferAppended, this), t.off(T.FRAG_BUFFERED, this.onFragBuffered, this), t.off(T.FRAG_LOADED, this.onFragLoaded, this)
                }
                destroy() {
                    this._unregisterListeners(), this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null
                }
                getAppendedFrag(t, e) {
                    const i = this.activePartLists[e];
                    if (i)
                        for (let e = i.length; e--;) {
                            const r = i[e];
                            if (!r) break;
                            const s = r.end;
                            if (r.start <= t && null !== s && t <= s) return r
                        }
                    return this.getBufferedFrag(t, e)
                }
                getBufferedFrag(t, e) {
                    const {
                        fragments: i
                    } = this, r = Object.keys(i);
                    for (let s = r.length; s--;) {
                        const n = i[r[s]];
                        if ((null == n ? void 0 : n.body.type) === e && n.buffered) {
                            const e = n.body;
                            if (e.start <= t && t <= e.end) return e
                        }
                    }
                    return null
                }
                detectEvictedFragments(t, e, i, r) {
                    this.timeRanges && (this.timeRanges[t] = e);
                    const s = (null == r ? void 0 : r.fragment.sn) || -1;
                    Object.keys(this.fragments).forEach((r => {
                        const n = this.fragments[r];
                        if (!n) return;
                        if (s >= n.body.sn) return;
                        if (!n.buffered && !n.loaded) return void(n.body.type === i && this.removeFragment(n.body));
                        const a = n.range[t];
                        a && a.time.some((t => {
                            const i = !this.isTimeBuffered(t.startPTS, t.endPTS, e);
                            return i && this.removeFragment(n.body), i
                        }))
                    }))
                }
                detectPartialFragments(t) {
                    const e = this.timeRanges,
                        {
                            frag: i,
                            part: r
                        } = t;
                    if (!e || "initSegment" === i.sn) return;
                    const s = Xi(i),
                        n = this.fragments[s];
                    if (!n || n.buffered && i.gap) return;
                    const a = !i.relurl;
                    if (Object.keys(e).forEach((t => {
                            const s = i.elementaryStreams[t];
                            if (!s) return;
                            const o = e[t],
                                l = a || !0 === s.partial;
                            n.range[t] = this.getBufferedTimes(i, r, l, o)
                        })), n.loaded = null, Object.keys(n.range).length) {
                        n.buffered = !0;
                        (n.body.endList = i.endList || n.body.endList) && (this.endListFragments[n.body.type] = n), zi(n) || this.removeParts(i.sn - 1, i.type)
                    } else this.removeFragment(n.body)
                }
                removeParts(t, e) {
                    const i = this.activePartLists[e];
                    i && (this.activePartLists[e] = i.filter((e => e.fragment.sn >= t)))
                }
                fragBuffered(t, e) {
                    const i = Xi(t);
                    let r = this.fragments[i];
                    !r && e && (r = this.fragments[i] = {
                        body: t,
                        appendedPTS: null,
                        loaded: null,
                        buffered: !1,
                        range: Object.create(null)
                    }, t.gap && (this.hasGaps = !0)), r && (r.loaded = null, r.buffered = !0)
                }
                getBufferedTimes(t, e, i, r) {
                    const s = {
                            time: [],
                            partial: i
                        },
                        n = t.start,
                        a = t.end,
                        o = t.minEndPTS || a,
                        l = t.maxStartPTS || n;
                    for (let t = 0; t < r.length; t++) {
                        const e = r.start(t) - this.bufferPadding,
                            i = r.end(t) + this.bufferPadding;
                        if (l >= e && o <= i) {
                            s.time.push({
                                startPTS: Math.max(n, r.start(t)),
                                endPTS: Math.min(a, r.end(t))
                            });
                            break
                        }
                        if (n < i && a > e) {
                            const e = Math.max(n, r.start(t)),
                                i = Math.min(a, r.end(t));
                            i > e && (s.partial = !0, s.time.push({
                                startPTS: e,
                                endPTS: i
                            }))
                        } else if (a <= e) break
                    }
                    return s
                }
                getPartialFragment(t) {
                    let e, i, r, s = null,
                        n = 0;
                    const {
                        bufferPadding: a,
                        fragments: o
                    } = this;
                    return Object.keys(o).forEach((l => {
                        const u = o[l];
                        u && zi(u) && (i = u.body.start - a, r = u.body.end + a, t >= i && t <= r && (e = Math.min(t - i, r - t), n <= e && (s = u.body, n = e)))
                    })), s
                }
                isEndListAppended(t) {
                    const e = this.endListFragments[t];
                    return void 0 !== e && (e.buffered || zi(e))
                }
                getState(t) {
                    const e = Xi(t),
                        i = this.fragments[e];
                    return i ? i.buffered ? zi(i) ? ji : qi : Ki : Wi
                }
                isTimeBuffered(t, e, i) {
                    let r, s;
                    for (let n = 0; n < i.length; n++) {
                        if (r = i.start(n) - this.bufferPadding, s = i.end(n) + this.bufferPadding, t >= r && e <= s) return !0;
                        if (e <= r) return !1
                    }
                    return !1
                }
                onFragLoaded(t, e) {
                    const {
                        frag: i,
                        part: r
                    } = e;
                    if ("initSegment" === i.sn || i.bitrateTest) return;
                    const s = r ? null : e,
                        n = Xi(i);
                    this.fragments[n] = {
                        body: i,
                        appendedPTS: null,
                        loaded: s,
                        buffered: !1,
                        range: Object.create(null)
                    }
                }
                onBufferAppended(t, e) {
                    const {
                        frag: i,
                        part: r,
                        timeRanges: s
                    } = e;
                    if ("initSegment" === i.sn) return;
                    const n = i.type;
                    if (r) {
                        let t = this.activePartLists[n];
                        t || (this.activePartLists[n] = t = []), t.push(r)
                    }
                    this.timeRanges = s, Object.keys(s).forEach((t => {
                        const e = s[t];
                        this.detectEvictedFragments(t, e, n, r)
                    }))
                }
                onFragBuffered(t, e) {
                    this.detectPartialFragments(e)
                }
                hasFragment(t) {
                    const e = Xi(t);
                    return !!this.fragments[e]
                }
                hasParts(t) {
                    var e;
                    return !(null == (e = this.activePartLists[t]) || !e.length)
                }
                removeFragmentsInRange(t, e, i, r, s) {
                    r && !this.hasGaps || Object.keys(this.fragments).forEach((n => {
                        const a = this.fragments[n];
                        if (!a) return;
                        const o = a.body;
                        o.type !== i || r && !o.gap || o.start < e && o.end > t && (a.buffered || s) && this.removeFragment(o)
                    }))
                }
                removeFragment(t) {
                    const e = Xi(t);
                    t.stats.loaded = 0, t.clearElementaryStreamInfo();
                    const i = this.activePartLists[t.type];
                    if (i) {
                        const e = t.sn;
                        this.activePartLists[t.type] = i.filter((t => t.fragment.sn !== e))
                    }
                    delete this.fragments[e], t.endList && delete this.endListFragments[t.type]
                }
                removeAllFragments() {
                    this.fragments = Object.create(null), this.endListFragments = Object.create(null), this.activePartLists = Object.create(null), this.hasGaps = !1
                }
            }

            function zi(t) {
                var e, i, r;
                return t.buffered && (t.body.gap || (null == (e = t.range.video) ? void 0 : e.partial) || (null == (i = t.range.audio) ? void 0 : i.partial) || (null == (r = t.range.audiovideo) ? void 0 : r.partial))
            }

            function Xi(t) {
                return `${t.type}_${t.level}_${t.sn}`
            }
            const Qi = {
                length: 0,
                start: () => 0,
                end: () => 0
            };
            class Ji {
                static isBuffered(t, e) {
                    try {
                        if (t) {
                            const i = Ji.getBuffered(t);
                            for (let t = 0; t < i.length; t++)
                                if (e >= i.start(t) && e <= i.end(t)) return !0
                        }
                    } catch (t) {}
                    return !1
                }
                static bufferInfo(t, e, i) {
                    try {
                        if (t) {
                            const r = Ji.getBuffered(t),
                                s = [];
                            let n;
                            for (n = 0; n < r.length; n++) s.push({
                                start: r.start(n),
                                end: r.end(n)
                            });
                            return this.bufferedInfo(s, e, i)
                        }
                    } catch (t) {}
                    return {
                        len: 0,
                        start: e,
                        end: e,
                        nextStart: void 0
                    }
                }
                static bufferedInfo(t, e, i) {
                    e = Math.max(0, e), t.sort((function(t, e) {
                        const i = t.start - e.start;
                        return i || e.end - t.end
                    }));
                    let r = [];
                    if (i)
                        for (let e = 0; e < t.length; e++) {
                            const s = r.length;
                            if (s) {
                                const n = r[s - 1].end;
                                t[e].start - n < i ? t[e].end > n && (r[s - 1].end = t[e].end) : r.push(t[e])
                            } else r.push(t[e])
                        } else r = t;
                    let s, n = 0,
                        a = e,
                        o = e;
                    for (let t = 0; t < r.length; t++) {
                        const l = r[t].start,
                            u = r[t].end;
                        if (e + i >= l && e < u) a = l, o = u, n = o - e;
                        else if (e + i < l) {
                            s = l;
                            break
                        }
                    }
                    return {
                        len: n,
                        start: a || 0,
                        end: o || 0,
                        nextStart: s
                    }
                }
                static getBuffered(t) {
                    try {
                        return t.buffered
                    } catch (t) {
                        return R.log("failed to get media.buffered", t), Qi
                    }
                }
            }
            class Zi {
                constructor(t, e, i, r = 0, s = -1, n = !1) {
                    this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = {
                        start: 0,
                        executeStart: 0,
                        executeEnd: 0,
                        end: 0
                    }, this.buffering = {
                        audio: {
                            start: 0,
                            executeStart: 0,
                            executeEnd: 0,
                            end: 0
                        },
                        video: {
                            start: 0,
                            executeStart: 0,
                            executeEnd: 0,
                            end: 0
                        },
                        audiovideo: {
                            start: 0,
                            executeStart: 0,
                            executeEnd: 0,
                            end: 0
                        }
                    }, this.level = t, this.sn = e, this.id = i, this.size = r, this.part = s, this.partial = n
                }
            }

            function tr(t, e) {
                for (let r = 0, s = t.length; r < s; r++) {
                    var i;
                    if ((null == (i = t[r]) ? void 0 : i.cc) === e) return t[r]
                }
                return null
            }

            function er(t, e) {
                if (t) {
                    const i = t.start + e;
                    t.start = t.startPTS = i, t.endPTS = i + t.duration
                }
            }

            function ir(t, e) {
                const i = e.fragments;
                for (let e = 0, r = i.length; e < r; e++) er(i[e], t);
                e.fragmentHint && er(e.fragmentHint, t), e.alignedSliding = !0
            }

            function rr(t, e, i) {
                e && (! function(t, e, i) {
                    if (function(t, e, i) {
                            return !(!e || !(i.endCC > i.startCC || t && t.cc < i.startCC))
                        }(t, i, e)) {
                        const t = function(t, e) {
                            const i = t.fragments,
                                r = e.fragments;
                            if (!r.length || !i.length) return void R.log("No fragments to align");
                            const s = tr(i, r[0].cc);
                            if (s && (!s || s.startPTS)) return s;
                            R.log("No frag in previous level to align on")
                        }(i, e);
                        t && p(t.start) && (R.log(`Adjusting PTS using last level due to CC increase within current level ${e.url}`), ir(t.start, e))
                    }
                }(t, i, e), !i.alignedSliding && e && sr(i, e), i.alignedSliding || !e || i.skippedSegments || ui(e, i))
            }

            function sr(t, e) {
                if (!t.hasProgramDateTime || !e.hasProgramDateTime) return;
                const i = t.fragments,
                    r = e.fragments;
                if (!i.length || !r.length) return;
                let s, n;
                const a = Math.min(e.endCC, t.endCC);
                e.startCC < a && t.startCC < a && (s = tr(r, a), n = tr(i, a)), s && n || (s = r[Math.floor(r.length / 2)], n = tr(i, s.cc) || i[Math.floor(i.length / 2)]);
                const o = s.programDateTime,
                    l = n.programDateTime;
                if (!o || !l) return;
                ir((l - o) / 1e3 - (n.start - s.start), t)
            }
            const nr = Math.pow(2, 17);
            class ar {
                constructor(t) {
                    this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = t
                }
                destroy() {
                    this.loader && (this.loader.destroy(), this.loader = null)
                }
                abort() {
                    this.loader && this.loader.abort()
                }
                load(t, e) {
                    const i = t.url;
                    if (!i) return Promise.reject(new ur({
                        type: E.NETWORK_ERROR,
                        details: S.FRAG_LOAD_ERROR,
                        fatal: !1,
                        frag: t,
                        error: new Error("Fragment does not have a " + (i ? "part list" : "url")),
                        networkDetails: null
                    }));
                    this.abort();
                    const r = this.config,
                        s = r.fLoader,
                        n = r.loader;
                    return new Promise(((a, o) => {
                        if (this.loader && this.loader.destroy(), t.gap) {
                            if (t.tagList.some((t => "GAP" === t[0]))) return void o(lr(t));
                            t.gap = !1
                        }
                        const l = this.loader = t.loader = s ? new s(r) : new n(r),
                            u = or(t),
                            c = vi(r.fragLoadPolicy.default),
                            h = {
                                loadPolicy: c,
                                timeout: c.maxLoadTimeMs,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: 0,
                                highWaterMark: "initSegment" === t.sn ? Infinity : nr
                            };
                        t.stats = l.stats, l.load(u, h, {
                            onSuccess: (e, i, r, s) => {
                                this.resetLoader(t, l);
                                let n = e.data;
                                r.resetIV && t.decryptdata && (t.decryptdata.iv = new Uint8Array(n.slice(0, 16)), n = n.slice(16)), a({
                                    frag: t,
                                    part: null,
                                    payload: n,
                                    networkDetails: s
                                })
                            },
                            onError: (e, r, s, n) => {
                                this.resetLoader(t, l), o(new ur({
                                    type: E.NETWORK_ERROR,
                                    details: S.FRAG_LOAD_ERROR,
                                    fatal: !1,
                                    frag: t,
                                    response: d({
                                        url: i,
                                        data: void 0
                                    }, e),
                                    error: new Error(`HTTP Error ${e.code} ${e.text}`),
                                    networkDetails: s,
                                    stats: n
                                }))
                            },
                            onAbort: (e, i, r) => {
                                this.resetLoader(t, l), o(new ur({
                                    type: E.NETWORK_ERROR,
                                    details: S.INTERNAL_ABORTED,
                                    fatal: !1,
                                    frag: t,
                                    error: new Error("Aborted"),
                                    networkDetails: r,
                                    stats: e
                                }))
                            },
                            onTimeout: (e, i, r) => {
                                this.resetLoader(t, l), o(new ur({
                                    type: E.NETWORK_ERROR,
                                    details: S.FRAG_LOAD_TIMEOUT,
                                    fatal: !1,
                                    frag: t,
                                    error: new Error(`Timeout after ${h.timeout}ms`),
                                    networkDetails: r,
                                    stats: e
                                }))
                            },
                            onProgress: (i, r, s, n) => {
                                e && e({
                                    frag: t,
                                    part: null,
                                    payload: s,
                                    networkDetails: n
                                })
                            }
                        })
                    }))
                }
                loadPart(t, e, i) {
                    this.abort();
                    const r = this.config,
                        s = r.fLoader,
                        n = r.loader;
                    return new Promise(((a, o) => {
                        if (this.loader && this.loader.destroy(), t.gap || e.gap) return void o(lr(t, e));
                        const l = this.loader = t.loader = s ? new s(r) : new n(r),
                            u = or(t, e),
                            c = vi(r.fragLoadPolicy.default),
                            h = {
                                loadPolicy: c,
                                timeout: c.maxLoadTimeMs,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: 0,
                                highWaterMark: nr
                            };
                        e.stats = l.stats, l.load(u, h, {
                            onSuccess: (r, s, n, o) => {
                                this.resetLoader(t, l), this.updateStatsFromPart(t, e);
                                const u = {
                                    frag: t,
                                    part: e,
                                    payload: r.data,
                                    networkDetails: o
                                };
                                i(u), a(u)
                            },
                            onError: (i, r, s, n) => {
                                this.resetLoader(t, l), o(new ur({
                                    type: E.NETWORK_ERROR,
                                    details: S.FRAG_LOAD_ERROR,
                                    fatal: !1,
                                    frag: t,
                                    part: e,
                                    response: d({
                                        url: u.url,
                                        data: void 0
                                    }, i),
                                    error: new Error(`HTTP Error ${i.code} ${i.text}`),
                                    networkDetails: s,
                                    stats: n
                                }))
                            },
                            onAbort: (i, r, s) => {
                                t.stats.aborted = e.stats.aborted, this.resetLoader(t, l), o(new ur({
                                    type: E.NETWORK_ERROR,
                                    details: S.INTERNAL_ABORTED,
                                    fatal: !1,
                                    frag: t,
                                    part: e,
                                    error: new Error("Aborted"),
                                    networkDetails: s,
                                    stats: i
                                }))
                            },
                            onTimeout: (i, r, s) => {
                                this.resetLoader(t, l), o(new ur({
                                    type: E.NETWORK_ERROR,
                                    details: S.FRAG_LOAD_TIMEOUT,
                                    fatal: !1,
                                    frag: t,
                                    part: e,
                                    error: new Error(`Timeout after ${h.timeout}ms`),
                                    networkDetails: s,
                                    stats: i
                                }))
                            }
                        })
                    }))
                }
                updateStatsFromPart(t, e) {
                    const i = t.stats,
                        r = e.stats,
                        s = r.total;
                    if (i.loaded += r.loaded, s) {
                        const r = Math.round(t.duration / e.duration),
                            n = Math.min(Math.round(i.loaded / s), r),
                            a = (r - n) * Math.round(i.loaded / n);
                        i.total = i.loaded + a
                    } else i.total = Math.max(i.loaded, i.total);
                    const n = i.loading,
                        a = r.loading;
                    n.start ? n.first += a.first - a.start : (n.start = a.start, n.first = a.first), n.end = a.end
                }
                resetLoader(t, e) {
                    t.loader = null, this.loader === e && (self.clearTimeout(this.partLoadTimeout), this.loader = null), e.destroy()
                }
            }

            function or(t, e = null) {
                const i = e || t,
                    r = {
                        frag: t,
                        part: e,
                        responseType: "arraybuffer",
                        url: i.url,
                        headers: {},
                        rangeStart: 0,
                        rangeEnd: 0
                    },
                    s = i.byteRangeStartOffset,
                    n = i.byteRangeEndOffset;
                if (p(s) && p(n)) {
                    var a;
                    let e = s,
                        i = n;
                    if ("initSegment" === t.sn && "AES-128" === (null == (a = t.decryptdata) ? void 0 : a.method)) {
                        const t = n - s;
                        t % 16 && (i = n + (16 - t % 16)), 0 !== s && (r.resetIV = !0, e = s - 16)
                    }
                    r.rangeStart = e, r.rangeEnd = i
                }
                return r
            }

            function lr(t, e) {
                const i = new Error(`GAP ${t.gap?"tag":"attribute"} found`),
                    r = {
                        type: E.MEDIA_ERROR,
                        details: S.FRAG_GAP,
                        fatal: !1,
                        frag: t,
                        error: i,
                        networkDetails: null
                    };
                return e && (r.part = e), (e || t).stats.aborted = !0, new ur(r)
            }
            class ur extends Error {
                constructor(t) {
                    super(t.error.message), this.data = void 0, this.data = t
                }
            }
            class cr {
                constructor(t, e) {
                    this.subtle = void 0, this.aesIV = void 0, this.subtle = t, this.aesIV = e
                }
                decrypt(t, e) {
                    return this.subtle.decrypt({
                        name: "AES-CBC",
                        iv: this.aesIV
                    }, e, t)
                }
            }
            class hr {
                constructor(t, e) {
                    this.subtle = void 0, this.key = void 0, this.subtle = t, this.key = e
                }
                expandKey() {
                    return this.subtle.importKey("raw", this.key, {
                        name: "AES-CBC"
                    }, !1, ["encrypt", "decrypt"])
                }
            }
            class dr {
                constructor() {
                    this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable()
                }
                uint8ArrayToUint32Array_(t) {
                    const e = new DataView(t),
                        i = new Uint32Array(4);
                    for (let t = 0; t < 4; t++) i[t] = e.getUint32(4 * t);
                    return i
                }
                initTable() {
                    const t = this.sBox,
                        e = this.invSBox,
                        i = this.subMix,
                        r = i[0],
                        s = i[1],
                        n = i[2],
                        a = i[3],
                        o = this.invSubMix,
                        l = o[0],
                        u = o[1],
                        c = o[2],
                        h = o[3],
                        d = new Uint32Array(256);
                    let f = 0,
                        g = 0,
                        m = 0;
                    for (m = 0; m < 256; m++) d[m] = m < 128 ? m << 1 : m << 1 ^ 283;
                    for (m = 0; m < 256; m++) {
                        let i = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4;
                        i = i >>> 8 ^ 255 & i ^ 99, t[f] = i, e[i] = f;
                        const o = d[f],
                            m = d[o],
                            p = d[m];
                        let v = 257 * d[i] ^ 16843008 * i;
                        r[f] = v << 24 | v >>> 8, s[f] = v << 16 | v >>> 16, n[f] = v << 8 | v >>> 24, a[f] = v, v = 16843009 * p ^ 65537 * m ^ 257 * o ^ 16843008 * f, l[i] = v << 24 | v >>> 8, u[i] = v << 16 | v >>> 16, c[i] = v << 8 | v >>> 24, h[i] = v, f ? (f = o ^ d[d[d[p ^ o]]], g ^= d[d[g]]) : f = g = 1
                    }
                }
                expandKey(t) {
                    const e = this.uint8ArrayToUint32Array_(t);
                    let i = !0,
                        r = 0;
                    for (; r < e.length && i;) i = e[r] === this.key[r], r++;
                    if (i) return;
                    this.key = e;
                    const s = this.keySize = e.length;
                    if (4 !== s && 6 !== s && 8 !== s) throw new Error("Invalid aes key size=" + s);
                    const n = this.ksRows = 4 * (s + 6 + 1);
                    let a, o;
                    const l = this.keySchedule = new Uint32Array(n),
                        u = this.invKeySchedule = new Uint32Array(n),
                        c = this.sBox,
                        h = this.rcon,
                        d = this.invSubMix,
                        f = d[0],
                        g = d[1],
                        m = d[2],
                        p = d[3];
                    let v, y;
                    for (a = 0; a < n; a++) a < s ? v = l[a] = e[a] : (y = v, a % s == 0 ? (y = y << 8 | y >>> 24, y = c[y >>> 24] << 24 | c[y >>> 16 & 255] << 16 | c[y >>> 8 & 255] << 8 | c[255 & y], y ^= h[a / s | 0] << 24) : s > 6 && a % s == 4 && (y = c[y >>> 24] << 24 | c[y >>> 16 & 255] << 16 | c[y >>> 8 & 255] << 8 | c[255 & y]), l[a] = v = (l[a - s] ^ y) >>> 0);
                    for (o = 0; o < n; o++) a = n - o, y = 3 & o ? l[a] : l[a - 4], u[o] = o < 4 || a <= 4 ? y : f[c[y >>> 24]] ^ g[c[y >>> 16 & 255]] ^ m[c[y >>> 8 & 255]] ^ p[c[255 & y]], u[o] = u[o] >>> 0
                }
                networkToHostOrderSwap(t) {
                    return t << 24 | (65280 & t) << 8 | (16711680 & t) >> 8 | t >>> 24
                }
                decrypt(t, e, i) {
                    const r = this.keySize + 6,
                        s = this.invKeySchedule,
                        n = this.invSBox,
                        a = this.invSubMix,
                        o = a[0],
                        l = a[1],
                        u = a[2],
                        c = a[3],
                        h = this.uint8ArrayToUint32Array_(i);
                    let d = h[0],
                        f = h[1],
                        g = h[2],
                        m = h[3];
                    const p = new Int32Array(t),
                        v = new Int32Array(p.length);
                    let y, T, E, S, b, A, L, k, R, w, _, D, C, I;
                    const P = this.networkToHostOrderSwap;
                    for (; e < p.length;) {
                        for (R = P(p[e]), w = P(p[e + 1]), _ = P(p[e + 2]), D = P(p[e + 3]), b = R ^ s[0], A = D ^ s[1], L = _ ^ s[2], k = w ^ s[3], C = 4, I = 1; I < r; I++) y = o[b >>> 24] ^ l[A >> 16 & 255] ^ u[L >> 8 & 255] ^ c[255 & k] ^ s[C], T = o[A >>> 24] ^ l[L >> 16 & 255] ^ u[k >> 8 & 255] ^ c[255 & b] ^ s[C + 1], E = o[L >>> 24] ^ l[k >> 16 & 255] ^ u[b >> 8 & 255] ^ c[255 & A] ^ s[C + 2], S = o[k >>> 24] ^ l[b >> 16 & 255] ^ u[A >> 8 & 255] ^ c[255 & L] ^ s[C + 3], b = y, A = T, L = E, k = S, C += 4;
                        y = n[b >>> 24] << 24 ^ n[A >> 16 & 255] << 16 ^ n[L >> 8 & 255] << 8 ^ n[255 & k] ^ s[C], T = n[A >>> 24] << 24 ^ n[L >> 16 & 255] << 16 ^ n[k >> 8 & 255] << 8 ^ n[255 & b] ^ s[C + 1], E = n[L >>> 24] << 24 ^ n[k >> 16 & 255] << 16 ^ n[b >> 8 & 255] << 8 ^ n[255 & A] ^ s[C + 2], S = n[k >>> 24] << 24 ^ n[b >> 16 & 255] << 16 ^ n[A >> 8 & 255] << 8 ^ n[255 & L] ^ s[C + 3], v[e] = P(y ^ d), v[e + 1] = P(S ^ f), v[e + 2] = P(E ^ g), v[e + 3] = P(T ^ m), d = R, f = w, g = _, m = D, e += 4
                    }
                    return v.buffer
                }
            }
            class fr {
                constructor(t, {
                    removePKCS7Padding: e = !0
                } = {}) {
                    if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.useSoftware = t.enableSoftwareAES, this.removePKCS7Padding = e, e) try {
                        const t = self.crypto;
                        t && (this.subtle = t.subtle || t.webkitSubtle)
                    } catch (t) {}
                    this.useSoftware = !this.subtle
                }
                destroy() {
                    this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null
                }
                isSync() {
                    return this.useSoftware
                }
                flush() {
                    const {
                        currentResult: t,
                        remainderData: e
                    } = this;
                    if (!t || e) return this.reset(), null;
                    const i = new Uint8Array(t);
                    return this.reset(), this.removePKCS7Padding ? function(t) {
                        const e = t.byteLength,
                            i = e && new DataView(t.buffer).getUint8(e - 1);
                        return i ? nt(t, 0, e - i) : t
                    }(i) : i
                }
                reset() {
                    this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null)
                }
                decrypt(t, e, i) {
                    return this.useSoftware ? new Promise(((r, s) => {
                        this.softwareDecrypt(new Uint8Array(t), e, i);
                        const n = this.flush();
                        n ? r(n.buffer) : s(new Error("[softwareDecrypt] Failed to decrypt data"))
                    })) : this.webCryptoDecrypt(new Uint8Array(t), e, i)
                }
                softwareDecrypt(t, e, i) {
                    const {
                        currentIV: r,
                        currentResult: s,
                        remainderData: n
                    } = this;
                    this.logOnce("JS AES decrypt"), n && (t = Ht(n, t), this.remainderData = null);
                    const a = this.getValidChunk(t);
                    if (!a.length) return null;
                    r && (i = r);
                    let o = this.softwareDecrypter;
                    o || (o = this.softwareDecrypter = new dr), o.expandKey(e);
                    const l = s;
                    return this.currentResult = o.decrypt(a.buffer, 0, i), this.currentIV = nt(a, -16).buffer, l || null
                }
                webCryptoDecrypt(t, e, i) {
                    if (this.key !== e || !this.fastAesKey) {
                        if (!this.subtle) return Promise.resolve(this.onWebCryptoError(t, e, i));
                        this.key = e, this.fastAesKey = new hr(this.subtle, e)
                    }
                    return this.fastAesKey.expandKey().then((e => {
                        if (!this.subtle) return Promise.reject(new Error("web crypto not initialized"));
                        this.logOnce("WebCrypto AES decrypt");
                        return new cr(this.subtle, new Uint8Array(i)).decrypt(t.buffer, e)
                    })).catch((r => (R.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${r.name}: ${r.message}`), this.onWebCryptoError(t, e, i))))
                }
                onWebCryptoError(t, e, i) {
                    this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(t, e, i);
                    const r = this.flush();
                    if (r) return r.buffer;
                    throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data")
                }
                getValidChunk(t) {
                    let e = t;
                    const i = t.length - t.length % 16;
                    return i !== t.length && (e = nt(t, 0, i), this.remainderData = nt(t, i)), e
                }
                logOnce(t) {
                    this.logEnabled && (R.log(`[decrypter]: ${t}`), this.logEnabled = !1)
                }
            }
            const gr = function(t) {
                    let e = "";
                    const i = t.length;
                    for (let r = 0; r < i; r++) e += `[${t.start(r).toFixed(3)}-${t.end(r).toFixed(3)}]`;
                    return e
                },
                mr = "STOPPED",
                pr = "IDLE",
                vr = "KEY_LOADING",
                yr = "FRAG_LOADING",
                Tr = "FRAG_LOADING_WAITING_RETRY",
                Er = "WAITING_TRACK",
                Sr = "PARSING",
                br = "PARSED",
                Ar = "ENDED",
                Lr = "ERROR",
                kr = "WAITING_INIT_PTS",
                Rr = "WAITING_LEVEL";
            class wr extends Vi {
                constructor(t, e, i, r, s) {
                    super(), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = mr, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.loadedmetadata = !1, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.onvseeking = null, this.onvended = null, this.logPrefix = "", this.log = void 0, this.warn = void 0, this.playlistType = s, this.logPrefix = r, this.log = R.log.bind(R, `${r}:`), this.warn = R.warn.bind(R, `${r}:`), this.hls = t, this.fragmentLoader = new ar(t.config), this.keyLoader = i, this.fragmentTracker = e, this.config = t.config, this.decrypter = new fr(t.config), t.on(T.MANIFEST_LOADED, this.onManifestLoaded, this)
                }
                doTick() {
                    this.onTickEnd()
                }
                onTickEnd() {}
                startLoad(t) {}
                stopLoad() {
                    this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);
                    const t = this.fragCurrent;
                    null != t && t.loader && (t.abortRequests(), this.fragmentTracker.removeFragment(t)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = mr
                }
                _streamEnded(t, e) {
                    if (e.live || t.nextStart || !t.end || !this.media) return !1;
                    const i = e.partList;
                    if (null != i && i.length) {
                        const t = i[i.length - 1];
                        return Ji.isBuffered(this.media, t.start + t.duration / 2)
                    }
                    const r = e.fragments[e.fragments.length - 1].type;
                    return this.fragmentTracker.isEndListAppended(r)
                }
                getLevelDetails() {
                    var t;
                    if (this.levels && null !== this.levelLastLoaded) return null == (t = this.levelLastLoaded) ? void 0 : t.details
                }
                onMediaAttached(t, e) {
                    const i = this.media = this.mediaBuffer = e.media;
                    this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), i.addEventListener("seeking", this.onvseeking), i.addEventListener("ended", this.onvended);
                    const r = this.config;
                    this.levels && r.autoStartLoad && this.state === mr && this.startLoad(r.startPosition)
                }
                onMediaDetaching() {
                    const t = this.media;
                    null != t && t.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), t && this.onvseeking && this.onvended && (t.removeEventListener("seeking", this.onvseeking), t.removeEventListener("ended", this.onvended), this.onvseeking = this.onvended = null), this.keyLoader && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad()
                }
                onMediaSeeking() {
                    const {
                        config: t,
                        fragCurrent: e,
                        media: i,
                        mediaBuffer: r,
                        state: s
                    } = this, n = i ? i.currentTime : 0, a = Ji.bufferInfo(r || i, n, t.maxBufferHole);
                    if (this.log(`media seeking to ${p(n)?n.toFixed(3):n}, state: ${s}`), this.state === Ar) this.resetLoadingState();
                    else if (e) {
                        const i = t.maxFragLookUpTolerance,
                            r = e.start - i,
                            s = e.start + e.duration + i;
                        if (!a.len || s < a.start || r > a.end) {
                            const t = n > s;
                            (n < r || t) && (t && e.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), e.abortRequests(), this.resetLoadingState()), this.fragPrevious = null)
                        }
                    }
                    i && (this.fragmentTracker.removeFragmentsInRange(n, Infinity, this.playlistType, !0), this.lastCurrentTime = n), this.loadedmetadata || a.len || (this.nextLoadPosition = this.startPosition = n), this.tickImmediate()
                }
                onMediaEnded() {
                    this.startPosition = this.lastCurrentTime = 0
                }
                onManifestLoaded(t, e) {
                    this.startTimeOffset = e.startTimeOffset, this.initPTS = []
                }
                onHandlerDestroying() {
                    this.hls.off(T.MANIFEST_LOADED, this.onManifestLoaded, this), this.stopLoad(), super.onHandlerDestroying(), this.hls = null
                }
                onHandlerDestroyed() {
                    this.state = mr, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed()
                }
                loadFragment(t, e, i) {
                    this._loadFragForPlayback(t, e, i)
                }
                _loadFragForPlayback(t, e, i) {
                    this._doFragLoad(t, e, i, (e => {
                        if (this.fragContextChanged(t)) return this.warn(`Fragment ${t.sn}${e.part?" p: "+e.part.index:""} of level ${t.level} was dropped during download.`), void this.fragmentTracker.removeFragment(t);
                        t.stats.chunkCount++, this._handleFragmentLoadProgress(e)
                    })).then((e => {
                        if (!e) return;
                        const i = this.state;
                        this.fragContextChanged(t) ? (i === yr || !this.fragCurrent && i === Sr) && (this.fragmentTracker.removeFragment(t), this.state = pr) : ("payload" in e && (this.log(`Loaded fragment ${t.sn} of level ${t.level}`), this.hls.trigger(T.FRAG_LOADED, e)), this._handleFragmentLoadComplete(e))
                    })).catch((e => {
                        this.state !== mr && this.state !== Lr && (this.warn(`Frag error: ${(null==e?void 0:e.message)||e}`), this.resetFragmentLoading(t))
                    }))
                }
                clearTrackerIfNeeded(t) {
                    var e;
                    const {
                        fragmentTracker: i
                    } = this;
                    if (i.getState(t) === Ki) {
                        const e = t.type,
                            r = this.getFwdBufferInfo(this.mediaBuffer, e),
                            s = Math.max(t.duration, r ? r.len : this.config.maxBufferLength),
                            n = this.backtrackFragment;
                        (1 === (n ? t.sn - n.sn : 0) || this.reduceMaxBufferLength(s, t.duration)) && i.removeFragment(t)
                    } else 0 === (null == (e = this.mediaBuffer) ? void 0 : e.buffered.length) ? i.removeAllFragments() : i.hasParts(t.type) && (i.detectPartialFragments({
                        frag: t,
                        part: null,
                        stats: t.stats,
                        id: t.type
                    }), i.getState(t) === ji && i.removeFragment(t))
                }
                checkLiveUpdate(t) {
                    if (t.updated && !t.live) {
                        const e = t.fragments[t.fragments.length - 1];
                        this.fragmentTracker.detectPartialFragments({
                            frag: e,
                            part: null,
                            stats: e.stats,
                            id: e.type
                        })
                    }
                    t.fragments[0] || (t.deltaUpdateFailed = !0)
                }
                flushMainBuffer(t, e, i = null) {
                    if (!(t - e)) return;
                    const r = {
                        startOffset: t,
                        endOffset: e,
                        type: i
                    };
                    this.hls.trigger(T.BUFFER_FLUSHING, r)
                }
                _loadInitSegment(t, e) {
                    this._doFragLoad(t, e).then((e => {
                        if (!e || this.fragContextChanged(t) || !this.levels) throw new Error("init load aborted");
                        return e
                    })).then((e => {
                        const {
                            hls: i
                        } = this, {
                            payload: r
                        } = e, s = t.decryptdata;
                        if (r && r.byteLength > 0 && null != s && s.key && s.iv && "AES-128" === s.method) {
                            const n = self.performance.now();
                            return this.decrypter.decrypt(new Uint8Array(r), s.key.buffer, s.iv.buffer).catch((e => {
                                throw i.trigger(T.ERROR, {
                                    type: E.MEDIA_ERROR,
                                    details: S.FRAG_DECRYPT_ERROR,
                                    fatal: !1,
                                    error: e,
                                    reason: e.message,
                                    frag: t
                                }), e
                            })).then((r => {
                                const s = self.performance.now();
                                return i.trigger(T.FRAG_DECRYPTED, {
                                    frag: t,
                                    payload: r,
                                    stats: {
                                        tstart: n,
                                        tdecrypt: s
                                    }
                                }), e.payload = r, this.completeInitSegmentLoad(e)
                            }))
                        }
                        return this.completeInitSegmentLoad(e)
                    })).catch((e => {
                        this.state !== mr && this.state !== Lr && (this.warn(e), this.resetFragmentLoading(t))
                    }))
                }
                completeInitSegmentLoad(t) {
                    const {
                        levels: e
                    } = this;
                    if (!e) throw new Error("init load aborted, missing levels");
                    const i = t.frag.stats;
                    this.state = pr, t.frag.data = new Uint8Array(t.payload), i.parsing.start = i.buffering.start = self.performance.now(), i.parsing.end = i.buffering.end = self.performance.now(), this.tick()
                }
                fragContextChanged(t) {
                    const {
                        fragCurrent: e
                    } = this;
                    return !t || !e || t.sn !== e.sn || t.level !== e.level
                }
                fragBufferedComplete(t, e) {
                    var i, r, s, n;
                    const a = this.mediaBuffer ? this.mediaBuffer : this.media;
                    if (this.log(`Buffered ${t.type} sn: ${t.sn}${e?" part: "+e.index:""} of ${this.playlistType===Ie?"level":"track"} ${t.level} (frag:[${(null!=(i=t.startPTS)?i:NaN).toFixed(3)}-${(null!=(r=t.endPTS)?r:NaN).toFixed(3)}] > buffer:${a?gr(Ji.getBuffered(a)):"(detached)"})`), "initSegment" !== t.sn) {
                        var o;
                        if (t.type !== xe) {
                            const e = t.elementaryStreams;
                            if (!Object.keys(e).some((t => !!e[t]))) return void(this.state = pr)
                        }
                        const e = null == (o = this.levels) ? void 0 : o[t.level];
                        null != e && e.fragmentError && (this.log(`Resetting level fragment error count of ${e.fragmentError} on frag buffered`), e.fragmentError = 0)
                    }
                    this.state = pr, a && (!this.loadedmetadata && t.type == Ie && a.buffered.length && (null == (s = this.fragCurrent) ? void 0 : s.sn) === (null == (n = this.fragPrevious) ? void 0 : n.sn) && (this.loadedmetadata = !0, this.seekToStartPos()), this.tick())
                }
                seekToStartPos() {}
                _handleFragmentLoadComplete(t) {
                    const {
                        transmuxer: e
                    } = this;
                    if (!e) return;
                    const {
                        frag: i,
                        part: r,
                        partsLoaded: s
                    } = t, n = !s || 0 === s.length || s.some((t => !t)), a = new Zi(i.level, i.sn, i.stats.chunkCount + 1, 0, r ? r.index : -1, !n);
                    e.flush(a)
                }
                _handleFragmentLoadProgress(t) {}
                _doFragLoad(t, e, i = null, r) {
                    var s;
                    const n = null == e ? void 0 : e.details;
                    if (!this.levels || !n) throw new Error(`frag load aborted, missing level${n?"":" detail"}s`);
                    let a = null;
                    if (!t.encrypted || null != (s = t.decryptdata) && s.key ? !t.encrypted && n.encryptedFragments.length && this.keyLoader.loadClear(t, n.encryptedFragments) : (this.log(`Loading key for ${t.sn} of [${n.startSN}-${n.endSN}], ${"[stream-controller]"===this.logPrefix?"level":"track"} ${t.level}`), this.state = vr, this.fragCurrent = t, a = this.keyLoader.load(t).then((t => {
                            if (!this.fragContextChanged(t.frag)) return this.hls.trigger(T.KEY_LOADED, t), this.state === vr && (this.state = pr), t
                        })), this.hls.trigger(T.KEY_LOADING, {
                            frag: t
                        }), null === this.fragCurrent && (a = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING")))), i = Math.max(t.start, i || 0), this.config.lowLatencyMode && "initSegment" !== t.sn) {
                        const s = n.partList;
                        if (s && r) {
                            i > t.end && n.fragmentHint && (t = n.fragmentHint);
                            const o = this.getNextPart(s, t, i);
                            if (o > -1) {
                                const l = s[o];
                                let u;
                                return this.log(`Loading part sn: ${t.sn} p: ${l.index} cc: ${t.cc} of playlist [${n.startSN}-${n.endSN}] parts [0-${o}-${s.length-1}] ${"[stream-controller]"===this.logPrefix?"level":"track"}: ${t.level}, target: ${parseFloat(i.toFixed(3))}`), this.nextLoadPosition = l.start + l.duration, this.state = yr, u = a ? a.then((i => !i || this.fragContextChanged(i.frag) ? null : this.doFragPartsLoad(t, l, e, r))).catch((t => this.handleFragLoadError(t))) : this.doFragPartsLoad(t, l, e, r).catch((t => this.handleFragLoadError(t))), this.hls.trigger(T.FRAG_LOADING, {
                                    frag: t,
                                    part: l,
                                    targetBufferTime: i
                                }), null === this.fragCurrent ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : u
                            }
                            if (!t.url || this.loadedEndOfParts(s, i)) return Promise.resolve(null)
                        }
                    }
                    this.log(`Loading fragment ${t.sn} cc: ${t.cc} ${n?"of ["+n.startSN+"-"+n.endSN+"] ":""}${"[stream-controller]"===this.logPrefix?"level":"track"}: ${t.level}, target: ${parseFloat(i.toFixed(3))}`), p(t.sn) && !this.bitrateTest && (this.nextLoadPosition = t.start + t.duration), this.state = yr;
                    const o = this.config.progressive;
                    let l;
                    return l = o && a ? a.then((e => !e || this.fragContextChanged(null == e ? void 0 : e.frag) ? null : this.fragmentLoader.load(t, r))).catch((t => this.handleFragLoadError(t))) : Promise.all([this.fragmentLoader.load(t, o ? r : void 0), a]).then((([t]) => (!o && t && r && r(t), t))).catch((t => this.handleFragLoadError(t))), this.hls.trigger(T.FRAG_LOADING, {
                        frag: t,
                        targetBufferTime: i
                    }), null === this.fragCurrent ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : l
                }
                doFragPartsLoad(t, e, i, r) {
                    return new Promise(((s, n) => {
                        var a;
                        const o = [],
                            l = null == (a = i.details) ? void 0 : a.partList,
                            u = e => {
                                this.fragmentLoader.loadPart(t, e, r).then((r => {
                                    o[e.index] = r;
                                    const n = r.part;
                                    this.hls.trigger(T.FRAG_LOADED, r);
                                    const a = hi(i, t.sn, e.index + 1) || di(l, t.sn, e.index + 1);
                                    if (!a) return s({
                                        frag: t,
                                        part: n,
                                        partsLoaded: o
                                    });
                                    u(a)
                                })).catch(n)
                            };
                        u(e)
                    }))
                }
                handleFragLoadError(t) {
                    if ("data" in t) {
                        const e = t.data;
                        t.data && e.details === S.INTERNAL_ABORTED ? this.handleFragLoadAborted(e.frag, e.part) : this.hls.trigger(T.ERROR, e)
                    } else this.hls.trigger(T.ERROR, {
                        type: E.OTHER_ERROR,
                        details: S.INTERNAL_EXCEPTION,
                        err: t,
                        error: t,
                        fatal: !0
                    });
                    return null
                }
                _handleTransmuxerFlush(t) {
                    const e = this.getCurrentContext(t);
                    if (!e || this.state !== Sr) return void(this.fragCurrent || this.state === mr || this.state === Lr || (this.state = pr));
                    const {
                        frag: i,
                        part: r,
                        level: s
                    } = e, n = self.performance.now();
                    i.stats.parsing.end = n, r && (r.stats.parsing.end = n), this.updateLevelTiming(i, r, s, t.partial)
                }
                getCurrentContext(t) {
                    const {
                        levels: e,
                        fragCurrent: i
                    } = this, {
                        level: r,
                        sn: s,
                        part: n
                    } = t;
                    if (null == e || !e[r]) return this.warn(`Levels object was unset while buffering fragment ${s} of level ${r}. The current chunk will not be buffered.`), null;
                    const a = e[r],
                        o = n > -1 ? hi(a, s, n) : null,
                        l = o ? o.fragment : function(t, e, i) {
                            if (null == t || !t.details) return null;
                            const r = t.details;
                            let s = r.fragments[e - r.startSN];
                            return s || (s = r.fragmentHint, s && s.sn === e ? s : e < r.startSN && i && i.sn === e ? i : null)
                        }(a, s, i);
                    return l ? (i && i !== l && (l.stats = i.stats), {
                        frag: l,
                        part: o,
                        level: a
                    }) : null
                }
                bufferFragmentData(t, e, i, r, s) {
                    var n;
                    if (!t || this.state !== Sr) return;
                    const {
                        data1: a,
                        data2: o
                    } = t;
                    let l = a;
                    if (a && o && (l = Ht(a, o)), null == (n = l) || !n.length) return;
                    const u = {
                        type: t.type,
                        frag: e,
                        part: i,
                        chunkMeta: r,
                        parent: e.type,
                        data: l
                    };
                    if (this.hls.trigger(T.BUFFER_APPENDING, u), t.dropped && t.independent && !i) {
                        if (s) return;
                        this.flushBufferGap(e)
                    }
                }
                flushBufferGap(t) {
                    const e = this.media;
                    if (!e) return;
                    if (!Ji.isBuffered(e, e.currentTime)) return void this.flushMainBuffer(0, t.start);
                    const i = e.currentTime,
                        r = Ji.bufferInfo(e, i, 0),
                        s = t.duration,
                        n = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * s),
                        a = Math.max(Math.min(t.start - n, r.end - n), i + n);
                    t.start - a > n && this.flushMainBuffer(a, t.start)
                }
                getFwdBufferInfo(t, e) {
                    const i = this.getLoadPosition();
                    return p(i) ? this.getFwdBufferInfoAtPos(t, i, e) : null
                }
                getFwdBufferInfoAtPos(t, e, i) {
                    const {
                        config: {
                            maxBufferHole: r
                        }
                    } = this, s = Ji.bufferInfo(t, e, r);
                    if (0 === s.len && void 0 !== s.nextStart) {
                        const n = this.fragmentTracker.getBufferedFrag(e, i);
                        if (n && s.nextStart < n.end) return Ji.bufferInfo(t, e, Math.max(s.nextStart, r))
                    }
                    return s
                }
                getMaxBufferLength(t) {
                    const {
                        config: e
                    } = this;
                    let i;
                    return i = t ? Math.max(8 * e.maxBufferSize / t, e.maxBufferLength) : e.maxBufferLength, Math.min(i, e.maxMaxBufferLength)
                }
                reduceMaxBufferLength(t, e) {
                    const i = this.config,
                        r = Math.max(Math.min(t - e, i.maxBufferLength), e),
                        s = Math.max(t - 3 * e, i.maxMaxBufferLength / 2, r);
                    return s >= r && (i.maxMaxBufferLength = s, this.warn(`Reduce max buffer length to ${s}s`), !0)
                }
                getAppendedFrag(t, e = Ie) {
                    const i = this.fragmentTracker.getAppendedFrag(t, Ie);
                    return i && "fragment" in i ? i.fragment : i
                }
                getNextFragment(t, e) {
                    const i = e.fragments,
                        r = i.length;
                    if (!r) return null;
                    const {
                        config: s
                    } = this, n = i[0].start;
                    let a;
                    if (e.live) {
                        const o = s.initialLiveManifestSize;
                        if (r < o) return this.warn(`Not enough fragments to start playback (have: ${r}, need: ${o})`), null;
                        (!e.PTSKnown && !this.startFragRequested && -1 === this.startPosition || t < n) && (a = this.getInitialLiveFragment(e, i), this.startPosition = this.nextLoadPosition = a ? this.hls.liveSyncPosition || a.start : t)
                    } else t <= n && (a = i[0]);
                    if (!a) {
                        const i = s.lowLatencyMode ? e.partEnd : e.fragmentEnd;
                        a = this.getFragmentAtPosition(t, i, e)
                    }
                    return this.mapToInitFragWhenRequired(a)
                }
                isLoopLoading(t, e) {
                    const i = this.fragmentTracker.getState(t);
                    return (i === qi || i === ji && !!t.gap) && this.nextLoadPosition > e
                }
                getNextFragmentLoopLoading(t, e, i, r, s) {
                    const n = t.gap,
                        a = this.getNextFragment(this.nextLoadPosition, e);
                    if (null === a) return a;
                    if (t = a, n && t && !t.gap && i.nextStart) {
                        const e = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, i.nextStart, r);
                        if (null !== e && i.len + e.len >= s) return this.log(`buffer full after gaps in "${r}" playlist starting at sn: ${t.sn}`), null
                    }
                    return t
                }
                mapToInitFragWhenRequired(t) {
                    return null == t || !t.initSegment || null != t && t.initSegment.data || this.bitrateTest ? t : t.initSegment
                }
                getNextPart(t, e, i) {
                    let r = -1,
                        s = !1,
                        n = !0;
                    for (let a = 0, o = t.length; a < o; a++) {
                        const o = t[a];
                        if (n = n && !o.independent, r > -1 && i < o.start) break;
                        const l = o.loaded;
                        l ? r = -1 : (s || o.independent || n) && o.fragment === e && (r = a), s = l
                    }
                    return r
                }
                loadedEndOfParts(t, e) {
                    const i = t[t.length - 1];
                    return i && e > i.start && i.loaded
                }
                getInitialLiveFragment(t, e) {
                    const i = this.fragPrevious;
                    let r = null;
                    if (i) {
                        if (t.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${i.programDateTime}`), r = function(t, e, i) {
                                if (null === e || !Array.isArray(t) || !t.length || !p(e)) return null;
                                if (e < (t[0].programDateTime || 0)) return null;
                                if (e >= (t[t.length - 1].endProgramDateTime || 0)) return null;
                                i = i || 0;
                                for (let r = 0; r < t.length; ++r) {
                                    const s = t[r];
                                    if (bi(e, i, s)) return s
                                }
                                return null
                            }(e, i.endProgramDateTime, this.config.maxFragLookUpTolerance)), !r) {
                            const s = i.sn + 1;
                            if (s >= t.startSN && s <= t.endSN) {
                                const n = e[s - t.startSN];
                                i.cc === n.cc && (r = n, this.log(`Live playlist, switching playlist, load frag with next SN: ${r.sn}`))
                            }
                            r || (r = function(t, e) {
                                return Ti(t, (t => t.cc < e ? 1 : t.cc > e ? -1 : 0))
                            }(e, i.cc), r && this.log(`Live playlist, switching playlist, load frag with same CC: ${r.sn}`))
                        }
                    } else {
                        const e = this.hls.liveSyncPosition;
                        null !== e && (r = this.getFragmentAtPosition(e, this.bitrateTest ? t.fragmentEnd : t.edge, t))
                    }
                    return r
                }
                getFragmentAtPosition(t, e, i) {
                    const {
                        config: r
                    } = this;
                    let {
                        fragPrevious: s
                    } = this, {
                        fragments: n,
                        endSN: a
                    } = i;
                    const {
                        fragmentHint: o
                    } = i, {
                        maxFragLookUpTolerance: l
                    } = r, u = i.partList, c = !!(r.lowLatencyMode && null != u && u.length && o);
                    let h;
                    if (c && o && !this.bitrateTest && (n = n.concat(o), a = o.sn), t < e) {
                        h = Ei(s, n, t, t > e - l ? 0 : l)
                    } else h = n[n.length - 1];
                    if (h) {
                        const t = h.sn - i.startSN,
                            e = this.fragmentTracker.getState(h);
                        if ((e === qi || e === ji && h.gap) && (s = h), s && h.sn === s.sn && (!c || u[0].fragment.sn > h.sn)) {
                            if (s && h.level === s.level) {
                                const e = n[t + 1];
                                h = h.sn < a && this.fragmentTracker.getState(e) !== qi ? e : null
                            }
                        }
                    }
                    return h
                }
                synchronizeToLiveEdge(t) {
                    const {
                        config: e,
                        media: i
                    } = this;
                    if (!i) return;
                    const r = this.hls.liveSyncPosition,
                        s = i.currentTime,
                        n = t.fragments[0].start,
                        a = t.edge,
                        o = s >= n - e.maxFragLookUpTolerance && s <= a;
                    if (null !== r && i.duration > r && (s < r || !o)) {
                        const n = void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : e.liveMaxLatencyDurationCount * t.targetduration;
                        (!o && i.readyState < 4 || s < a - n) && (this.loadedmetadata || (this.nextLoadPosition = r), i.readyState && (this.warn(`Playback: ${s.toFixed(3)} is located too far from the end of live sliding playlist: ${a}, reset currentTime to : ${r.toFixed(3)}`), i.currentTime = r))
                    }
                }
                alignPlaylists(t, e, i) {
                    const r = t.fragments.length;
                    if (!r) return this.warn("No fragments in live playlist"), 0;
                    const s = t.fragments[0].start,
                        n = !e,
                        a = t.alignedSliding && p(s);
                    if (n || !a && !s) {
                        const {
                            fragPrevious: s
                        } = this;
                        rr(s, i, t);
                        const n = t.fragments[0].start;
                        return this.log(`Live playlist sliding: ${n.toFixed(2)} start-sn: ${e?e.startSN:"na"}->${t.startSN} prev-sn: ${s?s.sn:"na"} fragments: ${r}`), n
                    }
                    return s
                }
                waitForCdnTuneIn(t) {
                    return t.live && t.canBlockReload && t.partTarget && t.tuneInGoal > Math.max(t.partHoldBack, 3 * t.partTarget)
                }
                setStartPosition(t, e) {
                    let i = this.startPosition;
                    if (i < e && (i = -1), -1 === i || -1 === this.lastCurrentTime) {
                        const r = null !== this.startTimeOffset,
                            s = r ? this.startTimeOffset : t.startTimeOffset;
                        null !== s && p(s) ? (i = e + s, s < 0 && (i += t.totalduration), i = Math.min(Math.max(e, i), e + t.totalduration), this.log(`Start time offset ${s} found in ${r?"multivariant":"media"} playlist, adjust startPosition to ${i}`), this.startPosition = i) : t.live ? i = this.hls.liveSyncPosition || e : this.startPosition = i = 0, this.lastCurrentTime = i
                    }
                    this.nextLoadPosition = i
                }
                getLoadPosition() {
                    const {
                        media: t
                    } = this;
                    let e = 0;
                    return this.loadedmetadata && t ? e = t.currentTime : this.nextLoadPosition && (e = this.nextLoadPosition), e
                }
                handleFragLoadAborted(t, e) {
                    this.transmuxer && "initSegment" !== t.sn && t.stats.aborted && (this.warn(`Fragment ${t.sn}${e?" part "+e.index:""} of level ${t.level} was aborted`), this.resetFragmentLoading(t))
                }
                resetFragmentLoading(t) {
                    this.fragCurrent && (this.fragContextChanged(t) || this.state === Tr) || (this.state = pr)
                }
                onFragmentOrKeyLoadError(t, e) {
                    if (e.chunkMeta && !e.frag) {
                        const t = this.getCurrentContext(e.chunkMeta);
                        t && (e.frag = t.frag)
                    }
                    const i = e.frag;
                    if (!i || i.type !== t || !this.levels) return;
                    var r;
                    if (this.fragContextChanged(i)) return void this.warn(`Frag load error must match current frag to retry ${i.url} > ${null==(r=this.fragCurrent)?void 0:r.url}`);
                    const s = e.details === S.FRAG_GAP;
                    s && this.fragmentTracker.fragBuffered(i, !0);
                    const n = e.errorAction,
                        {
                            action: a,
                            retryCount: o = 0,
                            retryConfig: l
                        } = n || {};
                    if (n && a === Ri && l) {
                        this.resetStartWhenNotLoaded(this.levelLastLoaded);
                        const r = pi(l, o);
                        this.warn(`Fragment ${i.sn} of ${t} ${i.level} errored with ${e.details}, retrying loading ${o+1}/${l.maxNumRetry} in ${r}ms`), n.resolved = !0, this.retryDate = self.performance.now() + r, this.state = Tr
                    } else if (l && n) {
                        if (this.resetFragmentErrors(t), !(o < l.maxNumRetry)) return void R.warn(`${e.details} reached or exceeded max retry (${o})`);
                        s || a === ki || (n.resolved = !0)
                    } else(null == n ? void 0 : n.action) === Li ? this.state = Rr : this.state = Lr;
                    this.tickImmediate()
                }
                reduceLengthAndFlushBuffer(t) {
                    if (this.state === Sr || this.state === br) {
                        const e = t.frag,
                            i = t.parent,
                            r = this.getFwdBufferInfo(this.mediaBuffer, i),
                            s = r && r.len > .5;
                        s && this.reduceMaxBufferLength(r.len, (null == e ? void 0 : e.duration) || 10);
                        const n = !s;
                        return n && this.warn(`Buffer full error while media.currentTime is not buffered, flush ${i} buffer`), e && (this.fragmentTracker.removeFragment(e), this.nextLoadPosition = e.start), this.resetLoadingState(), n
                    }
                    return !1
                }
                resetFragmentErrors(t) {
                    t === Pe && (this.fragCurrent = null), this.loadedmetadata || (this.startFragRequested = !1), this.state !== mr && (this.state = pr)
                }
                afterBufferFlushed(t, e, i) {
                    if (!t) return;
                    const r = Ji.getBuffered(t);
                    this.fragmentTracker.detectEvictedFragments(e, r, i), this.state === Ar && this.resetLoadingState()
                }
                resetLoadingState() {
                    this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state = pr
                }
                resetStartWhenNotLoaded(t) {
                    if (!this.loadedmetadata) {
                        this.startFragRequested = !1;
                        const e = t ? t.details : null;
                        null != e && e.live ? (this.startPosition = -1, this.setStartPosition(e, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition
                    }
                }
                resetWhenMissingContext(t) {
                    this.warn(`The loading context changed while buffering fragment ${t.sn} of level ${t.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState()
                }
                removeUnbufferedFrags(t = 0) {
                    this.fragmentTracker.removeFragmentsInRange(t, Infinity, this.playlistType, !1, !0)
                }
                updateLevelTiming(t, e, i, r) {
                    var s;
                    const n = i.details;
                    if (!n) return void this.warn("level.details undefined");
                    if (!Object.keys(t.elementaryStreams).reduce(((e, s) => {
                            const a = t.elementaryStreams[s];
                            if (a) {
                                const o = a.endPTS - a.startPTS;
                                if (o <= 0) return this.warn(`Could not parse fragment ${t.sn} ${s} duration reliably (${o})`), e || !1;
                                const l = r ? 0 : oi(n, t, a.startPTS, a.endPTS, a.startDTS, a.endDTS);
                                return this.hls.trigger(T.LEVEL_PTS_UPDATED, {
                                    details: n,
                                    level: i,
                                    drift: l,
                                    type: s,
                                    frag: t,
                                    start: a.startPTS,
                                    end: a.endPTS
                                }), !0
                            }
                            return e
                        }), !1) && null === (null == (s = this.transmuxer) ? void 0 : s.error)) {
                        const e = new Error(`Found no media in fragment ${t.sn} of level ${t.level} resetting transmuxer to fallback to playlist timing`);
                        if (0 === i.fragmentError && (i.fragmentError++, t.gap = !0, this.fragmentTracker.removeFragment(t), this.fragmentTracker.fragBuffered(t, !0)), this.warn(e.message), this.hls.trigger(T.ERROR, {
                                type: E.MEDIA_ERROR,
                                details: S.FRAG_PARSING_ERROR,
                                fatal: !1,
                                error: e,
                                frag: t,
                                reason: `Found no media in msn ${t.sn} of level "${i.url}"`
                            }), !this.hls) return;
                        this.resetTransmuxer()
                    }
                    this.state = br, this.hls.trigger(T.FRAG_PARSED, {
                        frag: t,
                        part: e
                    })
                }
                resetTransmuxer() {
                    this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null)
                }
                recoverWorkerError(t) {
                    "demuxerWorker" === t.event && (this.fragmentTracker.removeAllFragments(), this.resetTransmuxer(), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState())
                }
                set state(t) {
                    const e = this._state;
                    e !== t && (this._state = t, this.log(`${e}->${t}`))
                }
                get state() {
                    return this._state
                }
            }
            class _r {
                constructor() {
                    this.chunks = [], this.dataLength = 0
                }
                push(t) {
                    this.chunks.push(t), this.dataLength += t.length
                }
                flush() {
                    const {
                        chunks: t,
                        dataLength: e
                    } = this;
                    let i;
                    return t.length ? (i = 1 === t.length ? t[0] : function(t, e) {
                        const i = new Uint8Array(e);
                        let r = 0;
                        for (let e = 0; e < t.length; e++) {
                            const s = t[e];
                            i.set(s, r), r += s.length
                        }
                        return i
                    }(t, e), this.reset(), i) : new Uint8Array(0)
                }
                reset() {
                    this.chunks.length = 0, this.dataLength = 0
                }
            }

            function Dr(t = "", e = 9e4) {
                return {
                    type: t,
                    id: -1,
                    pid: -1,
                    inputTimeScale: e,
                    sequenceNumber: -1,
                    samples: [],
                    dropped: 0
                }
            }
            class Cr {
                constructor() {
                    this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null
                }
                resetInitSegment(t, e, i, r) {
                    this._id3Track = {
                        type: "id3",
                        id: 3,
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: 0,
                        samples: [],
                        dropped: 0
                    }
                }
                resetTimeStamp(t) {
                    this.initPTS = t, this.resetContiguity()
                }
                resetContiguity() {
                    this.basePTS = null, this.lastPTS = null, this.frameIndex = 0
                }
                canParse(t, e) {
                    return !1
                }
                appendFrame(t, e, i) {}
                demux(t, e) {
                    this.cachedData && (t = Ht(this.cachedData, t), this.cachedData = null);
                    let i, r = lt(t, 0),
                        s = r ? r.length : 0;
                    const n = this._audioTrack,
                        a = this._id3Track,
                        o = r ? ht(r) : void 0,
                        l = t.length;
                    for ((null === this.basePTS || 0 === this.frameIndex && p(o)) && (this.basePTS = Ir(o, e, this.initPTS), this.lastPTS = this.basePTS), null === this.lastPTS && (this.lastPTS = this.basePTS), r && r.length > 0 && a.samples.push({
                            pts: this.lastPTS,
                            dts: this.lastPTS,
                            data: r,
                            type: He,
                            duration: Number.POSITIVE_INFINITY
                        }); s < l;) {
                        if (this.canParse(t, s)) {
                            const e = this.appendFrame(n, t, s);
                            e ? (this.frameIndex++, this.lastPTS = e.sample.pts, s += e.length, i = s) : s = l
                        } else ct(t, s) ? (r = lt(t, s), a.samples.push({
                            pts: this.lastPTS,
                            dts: this.lastPTS,
                            data: r,
                            type: He,
                            duration: Number.POSITIVE_INFINITY
                        }), s += r.length, i = s) : s++;
                        if (s === l && i !== l) {
                            const e = nt(t, i);
                            this.cachedData ? this.cachedData = Ht(this.cachedData, e) : this.cachedData = e
                        }
                    }
                    return {
                        audioTrack: n,
                        videoTrack: Dr(),
                        id3Track: a,
                        textTrack: Dr()
                    }
                }
                demuxSampleAes(t, e, i) {
                    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`))
                }
                flush(t) {
                    const e = this.cachedData;
                    return e && (this.cachedData = null, this.demux(e, 0)), {
                        audioTrack: this._audioTrack,
                        videoTrack: Dr(),
                        id3Track: this._id3Track,
                        textTrack: Dr()
                    }
                }
                destroy() {}
            }
            const Ir = (t, e, i) => {
                if (p(t)) return 90 * t;
                return 9e4 * e + (i ? 9e4 * i.baseTime / i.timescale : 0)
            };

            function Pr(t, e) {
                return 255 === t[e] && 240 == (246 & t[e + 1])
            }

            function xr(t, e) {
                return 1 & t[e + 1] ? 7 : 9
            }

            function Mr(t, e) {
                return (3 & t[e + 3]) << 11 | t[e + 4] << 3 | (224 & t[e + 5]) >>> 5
            }

            function Or(t, e) {
                return e + 1 < t.length && Pr(t, e)
            }

            function Fr(t, e) {
                if (Or(t, e)) {
                    const i = xr(t, e);
                    if (e + i >= t.length) return !1;
                    const r = Mr(t, e);
                    if (r <= i) return !1;
                    const s = e + r;
                    return s === t.length || Or(t, s)
                }
                return !1
            }

            function Nr(t, e, i, r, s) {
                if (!t.samplerate) {
                    const n = function(t, e, i, r) {
                        let s, n, a, o;
                        const l = navigator.userAgent.toLowerCase(),
                            u = r,
                            c = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
                        s = 1 + ((192 & e[i + 2]) >>> 6);
                        const h = (60 & e[i + 2]) >>> 2;
                        if (!(h > c.length - 1)) return a = (1 & e[i + 2]) << 2, a |= (192 & e[i + 3]) >>> 6, R.log(`manifest codec:${r}, ADTS type:${s}, samplingIndex:${h}`), /firefox/i.test(l) ? h >= 6 ? (s = 5, o = new Array(4), n = h - 3) : (s = 2, o = new Array(2), n = h) : -1 !== l.indexOf("android") ? (s = 2, o = new Array(2), n = h) : (s = 5, o = new Array(4), r && (-1 !== r.indexOf("mp4a.40.29") || -1 !== r.indexOf("mp4a.40.5")) || !r && h >= 6 ? n = h - 3 : ((r && -1 !== r.indexOf("mp4a.40.2") && (h >= 6 && 1 === a || /vivaldi/i.test(l)) || !r && 1 === a) && (s = 2, o = new Array(2)), n = h)), o[0] = s << 3, o[0] |= (14 & h) >> 1, o[1] |= (1 & h) << 7, o[1] |= a << 3, 5 === s && (o[1] |= (14 & n) >> 1, o[2] = (1 & n) << 7, o[2] |= 8, o[3] = 0), {
                            config: o,
                            samplerate: c[h],
                            channelCount: a,
                            codec: "mp4a.40." + s,
                            manifestCodec: u
                        }; {
                            const e = new Error(`invalid ADTS sampling index:${h}`);
                            t.emit(T.ERROR, T.ERROR, {
                                type: E.MEDIA_ERROR,
                                details: S.FRAG_PARSING_ERROR,
                                fatal: !0,
                                error: e,
                                reason: e.message
                            })
                        }
                    }(e, i, r, s);
                    if (!n) return;
                    t.config = n.config, t.samplerate = n.samplerate, t.channelCount = n.channelCount, t.codec = n.codec, t.manifestCodec = n.manifestCodec, R.log(`parsed codec:${t.codec}, rate:${n.samplerate}, channels:${n.channelCount}`)
                }
            }

            function Br(t) {
                return 9216e4 / t
            }

            function Ur(t, e, i, r, s) {
                const n = r + s * Br(t.samplerate),
                    a = function(t, e) {
                        const i = xr(t, e);
                        if (e + i <= t.length) {
                            const r = Mr(t, e) - i;
                            if (r > 0) return {
                                headerLength: i,
                                frameLength: r
                            }
                        }
                    }(e, i);
                let o;
                if (a) {
                    const {
                        frameLength: r,
                        headerLength: s
                    } = a, l = s + r, u = Math.max(0, i + l - e.length);
                    u ? (o = new Uint8Array(l - s), o.set(e.subarray(i + s, e.length), 0)) : o = e.subarray(i + s, i + l);
                    const c = {
                        unit: o,
                        pts: n
                    };
                    return u || t.samples.push(c), {
                        sample: c,
                        length: l,
                        missing: u
                    }
                }
                const l = e.length - i;
                o = new Uint8Array(l), o.set(e.subarray(i, e.length), 0);
                return {
                    sample: {
                        unit: o,
                        pts: n
                    },
                    length: l,
                    missing: -1
                }
            }
            let $r = null;
            const Gr = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
                Hr = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
                Vr = [
                    [0, 72, 144, 12],
                    [0, 0, 0, 0],
                    [0, 72, 144, 12],
                    [0, 144, 144, 12]
                ],
                Wr = [0, 1, 1, 4];

            function Kr(t, e, i, r, s) {
                if (i + 24 > e.length) return;
                const n = jr(e, i);
                if (n && i + n.frameLength <= e.length) {
                    const a = r + s * (9e4 * n.samplesPerFrame / n.sampleRate),
                        o = {
                            unit: e.subarray(i, i + n.frameLength),
                            pts: a,
                            dts: a
                        };
                    return t.config = [], t.channelCount = n.channelCount, t.samplerate = n.sampleRate, t.samples.push(o), {
                        sample: o,
                        length: n.frameLength,
                        missing: 0
                    }
                }
            }

            function jr(t, e) {
                const i = t[e + 1] >> 3 & 3,
                    r = t[e + 1] >> 1 & 3,
                    s = t[e + 2] >> 4 & 15,
                    n = t[e + 2] >> 2 & 3;
                if (1 !== i && 0 !== s && 15 !== s && 3 !== n) {
                    const a = t[e + 2] >> 1 & 1,
                        o = t[e + 3] >> 6,
                        l = 1e3 * Gr[14 * (3 === i ? 3 - r : 3 === r ? 3 : 4) + s - 1],
                        u = Hr[3 * (3 === i ? 0 : 2 === i ? 1 : 2) + n],
                        c = 3 === o ? 1 : 2,
                        h = Vr[i][r],
                        d = Wr[r],
                        f = 8 * h * d,
                        g = Math.floor(h * l / u + a) * d;
                    if (null === $r) {
                        const t = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
                        $r = t ? parseInt(t[1]) : 0
                    }
                    return !!$r && $r <= 87 && 2 === r && l >= 224e3 && 0 === o && (t[e + 3] = 128 | t[e + 3]), {
                        sampleRate: u,
                        channelCount: c,
                        frameLength: g,
                        samplesPerFrame: f
                    }
                }
            }

            function qr(t, e) {
                return !(255 !== t[e] || 224 & ~t[e + 1] || !(6 & t[e + 1]))
            }

            function Yr(t, e) {
                return e + 1 < t.length && qr(t, e)
            }

            function zr(t, e) {
                if (e + 1 < t.length && qr(t, e)) {
                    const i = 4,
                        r = jr(t, e);
                    let s = i;
                    null != r && r.frameLength && (s = r.frameLength);
                    const n = e + s;
                    return n === t.length || Yr(t, n)
                }
                return !1
            }
            const Xr = /\/emsg[-/]ID3/i;
            const Qr = (t, e) => {
                let i = 0,
                    r = 5;
                e += r;
                const s = new Uint32Array(1),
                    n = new Uint32Array(1),
                    a = new Uint8Array(1);
                for (; r > 0;) {
                    a[0] = t[e];
                    const o = Math.min(r, 8),
                        l = 8 - o;
                    n[0] = 4278190080 >>> 24 + l << l, s[0] = (a[0] & n[0]) >> l, i = i ? i << o | s[0] : s[0], e += 1, r -= o
                }
                return i
            };
            class Jr extends Cr {
                constructor(t) {
                    super(), this.observer = void 0, this.observer = t
                }
                resetInitSegment(t, e, i, r) {
                    super.resetInitSegment(t, e, i, r), this._audioTrack = {
                        container: "audio/ac-3",
                        type: "audio",
                        id: 2,
                        pid: -1,
                        sequenceNumber: 0,
                        segmentCodec: "ac3",
                        samples: [],
                        manifestCodec: e,
                        duration: r,
                        inputTimeScale: 9e4,
                        dropped: 0
                    }
                }
                canParse(t, e) {
                    return e + 64 < t.length
                }
                appendFrame(t, e, i) {
                    const r = Zr(t, e, i, this.basePTS, this.frameIndex);
                    if (-1 !== r) {
                        return {
                            sample: t.samples[t.samples.length - 1],
                            length: r,
                            missing: 0
                        }
                    }
                }
                static probe(t) {
                    if (!t) return !1;
                    const e = lt(t, 0);
                    if (!e) return !1;
                    const i = e.length;
                    return 11 === t[i] && 119 === t[i + 1] && void 0 !== ht(e) && Qr(t, i) < 16
                }
            }

            function Zr(t, e, i, r, s) {
                if (i + 8 > e.length) return -1;
                if (11 !== e[i] || 119 !== e[i + 1]) return -1;
                const n = e[i + 4] >> 6;
                if (n >= 3) return -1;
                const a = [48e3, 44100, 32e3][n],
                    o = 63 & e[i + 4],
                    l = 2 * [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920][3 * o + n];
                if (i + l > e.length) return -1;
                const u = e[i + 6] >> 5;
                let c = 0;
                2 === u ? c += 2 : (1 & u && 1 !== u && (c += 2), 4 & u && (c += 2));
                const h = (e[i + 6] << 8 | e[i + 7]) >> 12 - c & 1,
                    d = [2, 1, 2, 3, 3, 4, 4, 5][u] + h,
                    f = e[i + 5] >> 3,
                    g = 7 & e[i + 5],
                    m = new Uint8Array([n << 6 | f << 1 | g >> 2, (3 & g) << 6 | u << 3 | h << 2 | o >> 4, o << 4 & 224]),
                    p = r + s * (1536 / a * 9e4),
                    v = e.subarray(i, i + l);
                return t.config = m, t.channelCount = d, t.samplerate = a, t.samples.push({
                    unit: v,
                    pts: p
                }), l
            }
            class ts {
                constructor() {
                    this.VideoSample = null
                }
                createVideoSample(t, e, i, r) {
                    return {
                        key: t,
                        frame: !1,
                        pts: e,
                        dts: i,
                        units: [],
                        debug: r,
                        length: 0
                    }
                }
                getLastNalUnit(t) {
                    var e;
                    let i, r = this.VideoSample;
                    if (r && 0 !== r.units.length || (r = t[t.length - 1]), null != (e = r) && e.units) {
                        const t = r.units;
                        i = t[t.length - 1]
                    }
                    return i
                }
                pushAccessUnit(t, e) {
                    if (t.units.length && t.frame) {
                        if (void 0 === t.pts) {
                            const i = e.samples,
                                r = i.length;
                            if (!r) return void e.dropped++; {
                                const e = i[r - 1];
                                t.pts = e.pts, t.dts = e.dts
                            }
                        }
                        e.samples.push(t)
                    }
                    t.debug.length && R.log(t.pts + "/" + t.dts + ":" + t.debug)
                }
            }
            class es {
                constructor(t) {
                    this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = t, this.bytesAvailable = t.byteLength, this.word = 0, this.bitsAvailable = 0
                }
                loadWord() {
                    const t = this.data,
                        e = this.bytesAvailable,
                        i = t.byteLength - e,
                        r = new Uint8Array(4),
                        s = Math.min(4, e);
                    if (0 === s) throw new Error("no bytes available");
                    r.set(t.subarray(i, i + s)), this.word = new DataView(r.buffer).getUint32(0), this.bitsAvailable = 8 * s, this.bytesAvailable -= s
                }
                skipBits(t) {
                    let e;
                    t = Math.min(t, 8 * this.bytesAvailable + this.bitsAvailable), this.bitsAvailable > t ? (this.word <<= t, this.bitsAvailable -= t) : (e = (t -= this.bitsAvailable) >> 3, t -= e << 3, this.bytesAvailable -= e, this.loadWord(), this.word <<= t, this.bitsAvailable -= t)
                }
                readBits(t) {
                    let e = Math.min(this.bitsAvailable, t);
                    const i = this.word >>> 32 - e;
                    if (t > 32 && R.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= e, this.bitsAvailable > 0) this.word <<= e;
                    else {
                        if (!(this.bytesAvailable > 0)) throw new Error("no bits available");
                        this.loadWord()
                    }
                    return e = t - e, e > 0 && this.bitsAvailable ? i << e | this.readBits(e) : i
                }
                skipLZ() {
                    let t;
                    for (t = 0; t < this.bitsAvailable; ++t)
                        if (this.word & 2147483648 >>> t) return this.word <<= t, this.bitsAvailable -= t, t;
                    return this.loadWord(), t + this.skipLZ()
                }
                skipUEG() {
                    this.skipBits(1 + this.skipLZ())
                }
                skipEG() {
                    this.skipBits(1 + this.skipLZ())
                }
                readUEG() {
                    const t = this.skipLZ();
                    return this.readBits(t + 1) - 1
                }
                readEG() {
                    const t = this.readUEG();
                    return 1 & t ? 1 + t >>> 1 : -1 * (t >>> 1)
                }
                readBoolean() {
                    return 1 === this.readBits(1)
                }
                readUByte() {
                    return this.readBits(8)
                }
                readUShort() {
                    return this.readBits(16)
                }
                readUInt() {
                    return this.readBits(32)
                }
                skipScalingList(t) {
                    let e, i = 8,
                        r = 8;
                    for (let s = 0; s < t; s++) 0 !== r && (e = this.readEG(), r = (i + e + 256) % 256), i = 0 === r ? i : r
                }
                readSPS() {
                    let t, e, i, r = 0,
                        s = 0,
                        n = 0,
                        a = 0;
                    const o = this.readUByte.bind(this),
                        l = this.readBits.bind(this),
                        u = this.readUEG.bind(this),
                        c = this.readBoolean.bind(this),
                        h = this.skipBits.bind(this),
                        d = this.skipEG.bind(this),
                        f = this.skipUEG.bind(this),
                        g = this.skipScalingList.bind(this);
                    o();
                    const m = o();
                    if (l(5), h(3), o(), f(), 100 === m || 110 === m || 122 === m || 244 === m || 44 === m || 83 === m || 86 === m || 118 === m || 128 === m) {
                        const t = u();
                        if (3 === t && h(1), f(), f(), h(1), c())
                            for (e = 3 !== t ? 8 : 12, i = 0; i < e; i++) c() && g(i < 6 ? 16 : 64)
                    }
                    f();
                    const p = u();
                    if (0 === p) u();
                    else if (1 === p)
                        for (h(1), d(), d(), t = u(), i = 0; i < t; i++) d();
                    f(), h(1);
                    const v = u(),
                        y = u(),
                        T = l(1);
                    0 === T && h(1), h(1), c() && (r = u(), s = u(), n = u(), a = u());
                    let E = [1, 1];
                    if (c() && c()) {
                        switch (o()) {
                            case 1:
                                E = [1, 1];
                                break;
                            case 2:
                                E = [12, 11];
                                break;
                            case 3:
                                E = [10, 11];
                                break;
                            case 4:
                                E = [16, 11];
                                break;
                            case 5:
                                E = [40, 33];
                                break;
                            case 6:
                                E = [24, 11];
                                break;
                            case 7:
                                E = [20, 11];
                                break;
                            case 8:
                                E = [32, 11];
                                break;
                            case 9:
                                E = [80, 33];
                                break;
                            case 10:
                                E = [18, 11];
                                break;
                            case 11:
                                E = [15, 11];
                                break;
                            case 12:
                                E = [64, 33];
                                break;
                            case 13:
                                E = [160, 99];
                                break;
                            case 14:
                                E = [4, 3];
                                break;
                            case 15:
                                E = [3, 2];
                                break;
                            case 16:
                                E = [2, 1];
                                break;
                            case 255:
                                E = [o() << 8 | o(), o() << 8 | o()]
                        }
                    }
                    return {
                        width: Math.ceil(16 * (v + 1) - 2 * r - 2 * s),
                        height: (2 - T) * (y + 1) * 16 - (T ? 2 : 4) * (n + a),
                        pixelRatio: E
                    }
                }
                readSliceType() {
                    return this.readUByte(), this.readUEG(), this.readUEG()
                }
            }
            class is extends ts {
                parseAVCPES(t, e, i, r, s) {
                    const n = this.parseAVCNALu(t, i.data);
                    let a, o = this.VideoSample,
                        l = !1;
                    i.data = null, o && n.length && !t.audFound && (this.pushAccessUnit(o, t), o = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts, "")), n.forEach((r => {
                        var n;
                        switch (r.type) {
                            case 1:
                                {
                                    let e = !1;a = !0;
                                    const s = r.data;
                                    if (l && s.length > 4) {
                                        const t = new es(s).readSliceType();
                                        2 !== t && 4 !== t && 7 !== t && 9 !== t || (e = !0)
                                    }
                                    var u;
                                    if (e) null != (u = o) && u.frame && !o.key && (this.pushAccessUnit(o, t), o = this.VideoSample = null);o || (o = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts, "")),
                                    o.frame = !0,
                                    o.key = e;
                                    break
                                }
                            case 5:
                                a = !0, null != (n = o) && n.frame && !o.key && (this.pushAccessUnit(o, t), o = this.VideoSample = null), o || (o = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts, "")), o.key = !0, o.frame = !0;
                                break;
                            case 6:
                                a = !0, Kt(r.data, 1, i.pts, e.samples);
                                break;
                            case 7:
                                {
                                    var c, h;a = !0,
                                    l = !0;
                                    const e = r.data,
                                        i = new es(e).readSPS();
                                    if (!t.sps || t.width !== i.width || t.height !== i.height || (null == (c = t.pixelRatio) ? void 0 : c[0]) !== i.pixelRatio[0] || (null == (h = t.pixelRatio) ? void 0 : h[1]) !== i.pixelRatio[1]) {
                                        t.width = i.width, t.height = i.height, t.pixelRatio = i.pixelRatio, t.sps = [e], t.duration = s;
                                        const r = e.subarray(1, 4);
                                        let n = "avc1.";
                                        for (let t = 0; t < 3; t++) {
                                            let e = r[t].toString(16);
                                            e.length < 2 && (e = "0" + e), n += e
                                        }
                                        t.codec = n
                                    }
                                    break
                                }
                            case 8:
                                a = !0, t.pps = [r.data];
                                break;
                            case 9:
                                a = !0, t.audFound = !0, o && this.pushAccessUnit(o, t), o = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts, "");
                                break;
                            case 12:
                                a = !0;
                                break;
                            default:
                                a = !1, o && (o.debug += "unknown NAL " + r.type + " ")
                        }
                        if (o && a) {
                            o.units.push(r)
                        }
                    })), r && o && (this.pushAccessUnit(o, t), this.VideoSample = null)
                }
                parseAVCNALu(t, e) {
                    const i = e.byteLength;
                    let r = t.naluState || 0;
                    const s = r,
                        n = [];
                    let a, o, l, u = 0,
                        c = -1,
                        h = 0;
                    for (-1 === r && (c = 0, h = 31 & e[0], r = 0, u = 1); u < i;)
                        if (a = e[u++], r)
                            if (1 !== r)
                                if (a)
                                    if (1 === a) {
                                        if (o = u - r - 1, c >= 0) {
                                            const t = {
                                                data: e.subarray(c, o),
                                                type: h
                                            };
                                            n.push(t)
                                        } else {
                                            const i = this.getLastNalUnit(t.samples);
                                            i && (s && u <= 4 - s && i.state && (i.data = i.data.subarray(0, i.data.byteLength - s)), o > 0 && (i.data = Ht(i.data, e.subarray(0, o)), i.state = 0))
                                        }
                                        u < i ? (l = 31 & e[u], c = u, h = l, r = 0) : r = -1
                                    } else r = 0;
                    else r = 3;
                    else r = a ? 0 : 2;
                    else r = a ? 0 : 1;
                    if (c >= 0 && r >= 0) {
                        const t = {
                            data: e.subarray(c, i),
                            type: h,
                            state: r
                        };
                        n.push(t)
                    }
                    if (0 === n.length) {
                        const i = this.getLastNalUnit(t.samples);
                        i && (i.data = Ht(i.data, e))
                    }
                    return t.naluState = r, n
                }
            }
            class rs {
                constructor(t, e, i) {
                    this.keyData = void 0, this.decrypter = void 0, this.keyData = i, this.decrypter = new fr(e, {
                        removePKCS7Padding: !1
                    })
                }
                decryptBuffer(t) {
                    return this.decrypter.decrypt(t, this.keyData.key.buffer, this.keyData.iv.buffer)
                }
                decryptAacSample(t, e, i) {
                    const r = t[e].unit;
                    if (r.length <= 16) return;
                    const s = r.subarray(16, r.length - r.length % 16),
                        n = s.buffer.slice(s.byteOffset, s.byteOffset + s.length);
                    this.decryptBuffer(n).then((s => {
                        const n = new Uint8Array(s);
                        r.set(n, 16), this.decrypter.isSync() || this.decryptAacSamples(t, e + 1, i)
                    }))
                }
                decryptAacSamples(t, e, i) {
                    for (;; e++) {
                        if (e >= t.length) return void i();
                        if (!(t[e].unit.length < 32) && (this.decryptAacSample(t, e, i), !this.decrypter.isSync())) return
                    }
                }
                getAvcEncryptedData(t) {
                    const e = 16 * Math.floor((t.length - 48) / 160) + 16,
                        i = new Int8Array(e);
                    let r = 0;
                    for (let e = 32; e < t.length - 16; e += 160, r += 16) i.set(t.subarray(e, e + 16), r);
                    return i
                }
                getAvcDecryptedUnit(t, e) {
                    const i = new Uint8Array(e);
                    let r = 0;
                    for (let e = 32; e < t.length - 16; e += 160, r += 16) t.set(i.subarray(r, r + 16), e);
                    return t
                }
                decryptAvcSample(t, e, i, r, s) {
                    const n = jt(s.data),
                        a = this.getAvcEncryptedData(n);
                    this.decryptBuffer(a.buffer).then((a => {
                        s.data = this.getAvcDecryptedUnit(n, a), this.decrypter.isSync() || this.decryptAvcSamples(t, e, i + 1, r)
                    }))
                }
                decryptAvcSamples(t, e, i, r) {
                    if (t instanceof Uint8Array) throw new Error("Cannot decrypt samples of type Uint8Array");
                    for (;; e++, i = 0) {
                        if (e >= t.length) return void r();
                        const s = t[e].units;
                        for (; !(i >= s.length); i++) {
                            const n = s[i];
                            if (!(n.data.length <= 48 || 1 !== n.type && 5 !== n.type || (this.decryptAvcSample(t, e, i, r, n), this.decrypter.isSync()))) return
                        }
                    }
                }
            }
            const ss = 188;
            class ns {
                constructor(t, e, i) {
                    this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._videoTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.remainderData = null, this.videoParser = void 0, this.observer = t, this.config = e, this.typeSupported = i, this.videoParser = new is
                }
                static probe(t) {
                    const e = ns.syncOffset(t);
                    return e > 0 && R.warn(`MPEG2-TS detected but first sync word found @ offset ${e}`), -1 !== e
                }
                static syncOffset(t) {
                    const e = t.length;
                    let i = Math.min(940, e - ss) + 1,
                        r = 0;
                    for (; r < i;) {
                        let s = !1,
                            n = -1,
                            a = 0;
                        for (let o = r; o < e; o += ss) {
                            if (71 !== t[o] || e - o !== ss && 71 !== t[o + ss]) {
                                if (a) return -1;
                                break
                            }
                            if (a++, -1 === n && (n = o, 0 !== n && (i = Math.min(n + 18612, t.length - ss) + 1)), s || (s = 0 === as(t, o)), s && a > 1 && (0 === n && a > 2 || o + ss > i)) return n
                        }
                        r++
                    }
                    return -1
                }
                static createTrack(t, e) {
                    return {
                        container: "video" === t || "audio" === t ? "video/mp2t" : void 0,
                        type: t,
                        id: Rt[t],
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: 0,
                        samples: [],
                        dropped: 0,
                        duration: "audio" === t ? e : void 0
                    }
                }
                resetInitSegment(t, e, i, r) {
                    this.pmtParsed = !1, this._pmtId = -1, this._videoTrack = ns.createTrack("video"), this._audioTrack = ns.createTrack("audio", r), this._id3Track = ns.createTrack("id3"), this._txtTrack = ns.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.remainderData = null, this.audioCodec = e, this.videoCodec = i, this._duration = r
                }
                resetTimeStamp() {}
                resetContiguity() {
                    const {
                        _audioTrack: t,
                        _videoTrack: e,
                        _id3Track: i
                    } = this;
                    t && (t.pesData = null), e && (e.pesData = null), i && (i.pesData = null), this.aacOverFlow = null, this.remainderData = null
                }
                demux(t, e, i = !1, r = !1) {
                    let s;
                    i || (this.sampleAes = null);
                    const n = this._videoTrack,
                        a = this._audioTrack,
                        o = this._id3Track,
                        l = this._txtTrack;
                    let u = n.pid,
                        c = n.pesData,
                        h = a.pid,
                        d = o.pid,
                        f = a.pesData,
                        g = o.pesData,
                        m = null,
                        p = this.pmtParsed,
                        v = this._pmtId,
                        y = t.length;
                    if (this.remainderData && (y = (t = Ht(this.remainderData, t)).length, this.remainderData = null), y < ss && !r) return this.remainderData = t, {
                        audioTrack: a,
                        videoTrack: n,
                        id3Track: o,
                        textTrack: l
                    };
                    const T = Math.max(0, ns.syncOffset(t));
                    y -= (y - T) % ss, y < t.byteLength && !r && (this.remainderData = new Uint8Array(t.buffer, y, t.buffer.byteLength - y));
                    let E = 0;
                    for (let e = T; e < y; e += ss)
                        if (71 === t[e]) {
                            const r = !!(64 & t[e + 1]),
                                y = as(t, e);
                            let E;
                            if ((48 & t[e + 3]) >> 4 > 1) {
                                if (E = e + 5 + t[e + 4], E === e + ss) continue
                            } else E = e + 4;
                            switch (y) {
                                case u:
                                    r && (c && (s = hs(c)) && this.videoParser.parseAVCPES(n, l, s, !1, this._duration), c = {
                                        data: [],
                                        size: 0
                                    }), c && (c.data.push(t.subarray(E, e + ss)), c.size += e + ss - E);
                                    break;
                                case h:
                                    if (r) {
                                        if (f && (s = hs(f))) switch (a.segmentCodec) {
                                            case "aac":
                                                this.parseAACPES(a, s);
                                                break;
                                            case "mp3":
                                                this.parseMPEGPES(a, s);
                                                break;
                                            case "ac3":
                                                this.parseAC3PES(a, s)
                                        }
                                        f = {
                                            data: [],
                                            size: 0
                                        }
                                    }
                                    f && (f.data.push(t.subarray(E, e + ss)), f.size += e + ss - E);
                                    break;
                                case d:
                                    r && (g && (s = hs(g)) && this.parseID3PES(o, s), g = {
                                        data: [],
                                        size: 0
                                    }), g && (g.data.push(t.subarray(E, e + ss)), g.size += e + ss - E);
                                    break;
                                case 0:
                                    r && (E += t[E] + 1), v = this._pmtId = os(t, E);
                                    break;
                                case v:
                                    {
                                        r && (E += t[E] + 1);
                                        const s = ls(t, E, this.typeSupported, i, this.observer);u = s.videoPid,
                                        u > 0 && (n.pid = u, n.segmentCodec = s.segmentVideoCodec),
                                        h = s.audioPid,
                                        h > 0 && (a.pid = h, a.segmentCodec = s.segmentAudioCodec),
                                        d = s.id3Pid,
                                        d > 0 && (o.pid = d),
                                        null === m || p || (R.warn(`MPEG-TS PMT found at ${e} after unknown PID '${m}'. Backtracking to sync byte @${T} to parse all TS packets.`), m = null, e = T - 188),
                                        p = this.pmtParsed = !0;
                                        break
                                    }
                                case 17:
                                case 8191:
                                    break;
                                default:
                                    m = y
                            }
                        } else E++;
                    E > 0 && us(this.observer, new Error(`Found ${E} TS packet/s that do not start with 0x47`)), n.pesData = c, a.pesData = f, o.pesData = g;
                    const S = {
                        audioTrack: a,
                        videoTrack: n,
                        id3Track: o,
                        textTrack: l
                    };
                    return r && this.extractRemainingSamples(S), S
                }
                flush() {
                    const {
                        remainderData: t
                    } = this;
                    let e;
                    return this.remainderData = null, e = t ? this.demux(t, -1, !1, !0) : {
                        videoTrack: this._videoTrack,
                        audioTrack: this._audioTrack,
                        id3Track: this._id3Track,
                        textTrack: this._txtTrack
                    }, this.extractRemainingSamples(e), this.sampleAes ? this.decrypt(e, this.sampleAes) : e
                }
                extractRemainingSamples(t) {
                    const {
                        audioTrack: e,
                        videoTrack: i,
                        id3Track: r,
                        textTrack: s
                    } = t, n = i.pesData, a = e.pesData, o = r.pesData;
                    let l;
                    if (n && (l = hs(n)) ? (this.videoParser.parseAVCPES(i, s, l, !0, this._duration), i.pesData = null) : i.pesData = n, a && (l = hs(a))) {
                        switch (e.segmentCodec) {
                            case "aac":
                                this.parseAACPES(e, l);
                                break;
                            case "mp3":
                                this.parseMPEGPES(e, l);
                                break;
                            case "ac3":
                                this.parseAC3PES(e, l)
                        }
                        e.pesData = null
                    } else null != a && a.size && R.log("last AAC PES packet truncated,might overlap between fragments"), e.pesData = a;
                    o && (l = hs(o)) ? (this.parseID3PES(r, l), r.pesData = null) : r.pesData = o
                }
                demuxSampleAes(t, e, i) {
                    const r = this.demux(t, i, !0, !this.config.progressive),
                        s = this.sampleAes = new rs(this.observer, this.config, e);
                    return this.decrypt(r, s)
                }
                decrypt(t, e) {
                    return new Promise((i => {
                        const {
                            audioTrack: r,
                            videoTrack: s
                        } = t;
                        r.samples && "aac" === r.segmentCodec ? e.decryptAacSamples(r.samples, 0, (() => {
                            s.samples ? e.decryptAvcSamples(s.samples, 0, 0, (() => {
                                i(t)
                            })) : i(t)
                        })) : s.samples && e.decryptAvcSamples(s.samples, 0, 0, (() => {
                            i(t)
                        }))
                    }))
                }
                destroy() {
                    this._duration = 0
                }
                parseAACPES(t, e) {
                    let i = 0;
                    const r = this.aacOverFlow;
                    let s, n, a, o = e.data;
                    if (r) {
                        this.aacOverFlow = null;
                        const e = r.missing,
                            s = r.sample.unit.byteLength;
                        if (-1 === e) o = Ht(r.sample.unit, o);
                        else {
                            const n = s - e;
                            r.sample.unit.set(o.subarray(0, e), n), t.samples.push(r.sample), i = r.missing
                        }
                    }
                    for (s = i, n = o.length; s < n - 1 && !Or(o, s); s++);
                    if (s !== i) {
                        let t;
                        const e = s < n - 1;
                        if (t = e ? `AAC PES did not start with ADTS header,offset:${s}` : "No ADTS header found in AAC PES", us(this.observer, new Error(t), e), !e) return
                    }
                    if (Nr(t, this.observer, o, s, this.audioCodec), void 0 !== e.pts) a = e.pts;
                    else {
                        if (!r) return void R.warn("[tsdemuxer]: AAC PES unknown PTS"); {
                            const e = Br(t.samplerate);
                            a = r.sample.pts + e
                        }
                    }
                    let l, u = 0;
                    for (; s < n;) {
                        if (l = Ur(t, o, s, a, u), s += l.length, l.missing) {
                            this.aacOverFlow = l;
                            break
                        }
                        for (u++; s < n - 1 && !Or(o, s); s++);
                    }
                }
                parseMPEGPES(t, e) {
                    const i = e.data,
                        r = i.length;
                    let s = 0,
                        n = 0;
                    const a = e.pts;
                    if (void 0 !== a)
                        for (; n < r;)
                            if (Yr(i, n)) {
                                const e = Kr(t, i, n, a, s);
                                if (!e) break;
                                n += e.length, s++
                            } else n++;
                    else R.warn("[tsdemuxer]: MPEG PES unknown PTS")
                }
                parseAC3PES(t, e) {
                    {
                        const i = e.data,
                            r = e.pts;
                        if (void 0 === r) return void R.warn("[tsdemuxer]: AC3 PES unknown PTS");
                        const s = i.length;
                        let n, a = 0,
                            o = 0;
                        for (; o < s && (n = Zr(t, i, o, r, a++)) > 0;) o += n
                    }
                }
                parseID3PES(t, e) {
                    if (void 0 === e.pts) return void R.warn("[tsdemuxer]: ID3 PES unknown PTS");
                    const i = m({}, e, {
                        type: this._videoTrack ? We : He,
                        duration: Number.POSITIVE_INFINITY
                    });
                    t.samples.push(i)
                }
            }

            function as(t, e) {
                return ((31 & t[e + 1]) << 8) + t[e + 2]
            }

            function os(t, e) {
                return (31 & t[e + 10]) << 8 | t[e + 11]
            }

            function ls(t, e, i, r, s) {
                const n = {
                        audioPid: -1,
                        videoPid: -1,
                        id3Pid: -1,
                        segmentVideoCodec: "avc",
                        segmentAudioCodec: "aac"
                    },
                    a = e + 3 + ((15 & t[e + 1]) << 8 | t[e + 2]) - 4;
                for (e += 12 + ((15 & t[e + 10]) << 8 | t[e + 11]); e < a;) {
                    const a = as(t, e),
                        o = (15 & t[e + 3]) << 8 | t[e + 4];
                    switch (t[e]) {
                        case 207:
                            if (!r) {
                                cs("ADTS AAC");
                                break
                            }
                        case 15:
                            -1 === n.audioPid && (n.audioPid = a);
                            break;
                        case 21:
                            -1 === n.id3Pid && (n.id3Pid = a);
                            break;
                        case 219:
                            if (!r) {
                                cs("H.264");
                                break
                            }
                        case 27:
                            -1 === n.videoPid && (n.videoPid = a, n.segmentVideoCodec = "avc");
                            break;
                        case 3:
                        case 4:
                            i.mpeg || i.mp3 ? -1 === n.audioPid && (n.audioPid = a, n.segmentAudioCodec = "mp3") : R.log("MPEG audio found, not supported in this browser");
                            break;
                        case 193:
                            if (!r) {
                                cs("AC-3");
                                break
                            }
                        case 129:
                            i.ac3 ? -1 === n.audioPid && (n.audioPid = a, n.segmentAudioCodec = "ac3") : R.log("AC-3 audio found, not supported in this browser");
                            break;
                        case 6:
                            if (-1 === n.audioPid && o > 0) {
                                let r = e + 5,
                                    s = o;
                                for (; s > 2;) {
                                    if (106 === t[r]) !0 !== i.ac3 ? R.log("AC-3 audio found, not supported in this browser for now") : (n.audioPid = a, n.segmentAudioCodec = "ac3");
                                    const e = t[r + 1] + 2;
                                    r += e, s -= e
                                }
                            }
                            break;
                        case 194:
                        case 135:
                            return us(s, new Error("Unsupported EC-3 in M2TS found")), n;
                        case 36:
                            return us(s, new Error("Unsupported HEVC in M2TS found")), n
                    }
                    e += o + 5
                }
                return n
            }

            function us(t, e, i) {
                R.warn(`parsing error: ${e.message}`), t.emit(T.ERROR, T.ERROR, {
                    type: E.MEDIA_ERROR,
                    details: S.FRAG_PARSING_ERROR,
                    fatal: !1,
                    levelRetry: i,
                    error: e,
                    reason: e.message
                })
            }

            function cs(t) {
                R.log(`${t} with AES-128-CBC encryption found in unencrypted stream`)
            }

            function hs(t) {
                let e, i, r, s, n, a = 0;
                const o = t.data;
                if (!t || 0 === t.size) return null;
                for (; o[0].length < 19 && o.length > 1;) o[0] = Ht(o[0], o[1]), o.splice(1, 1);
                e = o[0];
                if (1 === (e[0] << 16) + (e[1] << 8) + e[2]) {
                    if (i = (e[4] << 8) + e[5], i && i > t.size - 6) return null;
                    const l = e[7];
                    192 & l && (s = 536870912 * (14 & e[9]) + 4194304 * (255 & e[10]) + 16384 * (254 & e[11]) + 128 * (255 & e[12]) + (254 & e[13]) / 2, 64 & l ? (n = 536870912 * (14 & e[14]) + 4194304 * (255 & e[15]) + 16384 * (254 & e[16]) + 128 * (255 & e[17]) + (254 & e[18]) / 2, s - n > 54e5 && (R.warn(`${Math.round((s-n)/9e4)}s delta between PTS and DTS, align them`), s = n)) : n = s), r = e[8];
                    let u = r + 9;
                    if (t.size <= u) return null;
                    t.size -= u;
                    const c = new Uint8Array(t.size);
                    for (let t = 0, i = o.length; t < i; t++) {
                        e = o[t];
                        let i = e.byteLength;
                        if (u) {
                            if (u > i) {
                                u -= i;
                                continue
                            }
                            e = e.subarray(u), i -= u, u = 0
                        }
                        c.set(e, a), a += i
                    }
                    return i && (i -= r + 3), {
                        data: c,
                        pts: s,
                        dts: n,
                        len: i
                    }
                }
                return null
            }
            class ds {
                static getSilentFrame(t, e) {
                    if ("mp4a.40.2" === t) {
                        if (1 === e) return new Uint8Array([0, 200, 0, 128, 35, 128]);
                        if (2 === e) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                        if (3 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                        if (4 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                        if (5 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                        if (6 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224])
                    } else {
                        if (1 === e) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                        if (2 === e) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                        if (3 === e) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94])
                    }
                }
            }
            const fs = Math.pow(2, 32) - 1;
            class gs {
                static init() {
                    let t;
                    for (t in gs.types = {
                            avc1: [],
                            avcC: [],
                            btrt: [],
                            dinf: [],
                            dref: [],
                            esds: [],
                            ftyp: [],
                            hdlr: [],
                            mdat: [],
                            mdhd: [],
                            mdia: [],
                            mfhd: [],
                            minf: [],
                            moof: [],
                            moov: [],
                            mp4a: [],
                            ".mp3": [],
                            dac3: [],
                            "ac-3": [],
                            mvex: [],
                            mvhd: [],
                            pasp: [],
                            sdtp: [],
                            stbl: [],
                            stco: [],
                            stsc: [],
                            stsd: [],
                            stsz: [],
                            stts: [],
                            tfdt: [],
                            tfhd: [],
                            traf: [],
                            trak: [],
                            trun: [],
                            trex: [],
                            tkhd: [],
                            vmhd: [],
                            smhd: []
                        }, gs.types) gs.types.hasOwnProperty(t) && (gs.types[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);
                    const e = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
                        i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
                    gs.HDLR_TYPES = {
                        video: e,
                        audio: i
                    };
                    const r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
                        s = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
                    gs.STTS = gs.STSC = gs.STCO = s, gs.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), gs.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), gs.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), gs.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
                    const n = new Uint8Array([105, 115, 111, 109]),
                        a = new Uint8Array([97, 118, 99, 49]),
                        o = new Uint8Array([0, 0, 0, 1]);
                    gs.FTYP = gs.box(gs.types.ftyp, n, o, n, a), gs.DINF = gs.box(gs.types.dinf, gs.box(gs.types.dref, r))
                }
                static box(t, ...e) {
                    let i = 8,
                        r = e.length;
                    const s = r;
                    for (; r--;) i += e[r].byteLength;
                    const n = new Uint8Array(i);
                    for (n[0] = i >> 24 & 255, n[1] = i >> 16 & 255, n[2] = i >> 8 & 255, n[3] = 255 & i, n.set(t, 4), r = 0, i = 8; r < s; r++) n.set(e[r], i), i += e[r].byteLength;
                    return n
                }
                static hdlr(t) {
                    return gs.box(gs.types.hdlr, gs.HDLR_TYPES[t])
                }
                static mdat(t) {
                    return gs.box(gs.types.mdat, t)
                }
                static mdhd(t, e) {
                    e *= t;
                    const i = Math.floor(e / (fs + 1)),
                        r = Math.floor(e % (fs + 1));
                    return gs.box(gs.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 85, 196, 0, 0]))
                }
                static mdia(t) {
                    return gs.box(gs.types.mdia, gs.mdhd(t.timescale, t.duration), gs.hdlr(t.type), gs.minf(t))
                }
                static mfhd(t) {
                    return gs.box(gs.types.mfhd, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t]))
                }
                static minf(t) {
                    return "audio" === t.type ? gs.box(gs.types.minf, gs.box(gs.types.smhd, gs.SMHD), gs.DINF, gs.stbl(t)) : gs.box(gs.types.minf, gs.box(gs.types.vmhd, gs.VMHD), gs.DINF, gs.stbl(t))
                }
                static moof(t, e, i) {
                    return gs.box(gs.types.moof, gs.mfhd(t), gs.traf(i, e))
                }
                static moov(t) {
                    let e = t.length;
                    const i = [];
                    for (; e--;) i[e] = gs.trak(t[e]);
                    return gs.box.apply(null, [gs.types.moov, gs.mvhd(t[0].timescale, t[0].duration)].concat(i).concat(gs.mvex(t)))
                }
                static mvex(t) {
                    let e = t.length;
                    const i = [];
                    for (; e--;) i[e] = gs.trex(t[e]);
                    return gs.box.apply(null, [gs.types.mvex, ...i])
                }
                static mvhd(t, e) {
                    e *= t;
                    const i = Math.floor(e / (fs + 1)),
                        r = Math.floor(e % (fs + 1)),
                        s = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
                    return gs.box(gs.types.mvhd, s)
                }
                static sdtp(t) {
                    const e = t.samples || [],
                        i = new Uint8Array(4 + e.length);
                    let r, s;
                    for (r = 0; r < e.length; r++) s = e[r].flags, i[r + 4] = s.dependsOn << 4 | s.isDependedOn << 2 | s.hasRedundancy;
                    return gs.box(gs.types.sdtp, i)
                }
                static stbl(t) {
                    return gs.box(gs.types.stbl, gs.stsd(t), gs.box(gs.types.stts, gs.STTS), gs.box(gs.types.stsc, gs.STSC), gs.box(gs.types.stsz, gs.STSZ), gs.box(gs.types.stco, gs.STCO))
                }
                static avc1(t) {
                    let e, i, r, s = [],
                        n = [];
                    for (e = 0; e < t.sps.length; e++) i = t.sps[e], r = i.byteLength, s.push(r >>> 8 & 255), s.push(255 & r), s = s.concat(Array.prototype.slice.call(i));
                    for (e = 0; e < t.pps.length; e++) i = t.pps[e], r = i.byteLength, n.push(r >>> 8 & 255), n.push(255 & r), n = n.concat(Array.prototype.slice.call(i));
                    const a = gs.box(gs.types.avcC, new Uint8Array([1, s[3], s[4], s[5], 255, 224 | t.sps.length].concat(s).concat([t.pps.length]).concat(n))),
                        o = t.width,
                        l = t.height,
                        u = t.pixelRatio[0],
                        c = t.pixelRatio[1];
                    return gs.box(gs.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, o >> 8 & 255, 255 & o, l >> 8 & 255, 255 & l, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), a, gs.box(gs.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), gs.box(gs.types.pasp, new Uint8Array([u >> 24, u >> 16 & 255, u >> 8 & 255, 255 & u, c >> 24, c >> 16 & 255, c >> 8 & 255, 255 & c])))
                }
                static esds(t) {
                    const e = t.config.length;
                    return new Uint8Array([0, 0, 0, 0, 3, 23 + e, 0, 1, 0, 4, 15 + e, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([e]).concat(t.config).concat([6, 1, 2]))
                }
                static audioStsd(t) {
                    const e = t.samplerate;
                    return new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, e >> 8 & 255, 255 & e, 0, 0])
                }
                static mp4a(t) {
                    return gs.box(gs.types.mp4a, gs.audioStsd(t), gs.box(gs.types.esds, gs.esds(t)))
                }
                static mp3(t) {
                    return gs.box(gs.types[".mp3"], gs.audioStsd(t))
                }
                static ac3(t) {
                    return gs.box(gs.types["ac-3"], gs.audioStsd(t), gs.box(gs.types.dac3, t.config))
                }
                static stsd(t) {
                    return "audio" === t.type ? "mp3" === t.segmentCodec && "mp3" === t.codec ? gs.box(gs.types.stsd, gs.STSD, gs.mp3(t)) : "ac3" === t.segmentCodec ? gs.box(gs.types.stsd, gs.STSD, gs.ac3(t)) : gs.box(gs.types.stsd, gs.STSD, gs.mp4a(t)) : gs.box(gs.types.stsd, gs.STSD, gs.avc1(t))
                }
                static tkhd(t) {
                    const e = t.id,
                        i = t.duration * t.timescale,
                        r = t.width,
                        s = t.height,
                        n = Math.floor(i / (fs + 1)),
                        a = Math.floor(i % (fs + 1));
                    return gs.box(gs.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, 0, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0, s >> 8 & 255, 255 & s, 0, 0]))
                }
                static traf(t, e) {
                    const i = gs.sdtp(t),
                        r = t.id,
                        s = Math.floor(e / (fs + 1)),
                        n = Math.floor(e % (fs + 1));
                    return gs.box(gs.types.traf, gs.box(gs.types.tfhd, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r])), gs.box(gs.types.tfdt, new Uint8Array([1, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n])), gs.trun(t, i.length + 16 + 20 + 8 + 16 + 8 + 8), i)
                }
                static trak(t) {
                    return t.duration = t.duration || 4294967295, gs.box(gs.types.trak, gs.tkhd(t), gs.mdia(t))
                }
                static trex(t) {
                    const e = t.id;
                    return gs.box(gs.types.trex, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
                }
                static trun(t, e) {
                    const i = t.samples || [],
                        r = i.length,
                        s = 12 + 16 * r,
                        n = new Uint8Array(s);
                    let a, o, l, u, c, h;
                    for (e += 8 + s, n.set(["video" === t.type ? 1 : 0, 0, 15, 1, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e], 0), a = 0; a < r; a++) o = i[a], l = o.duration, u = o.size, c = o.flags, h = o.cts, n.set([l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l, u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, 255 & u, c.isLeading << 2 | c.dependsOn, c.isDependedOn << 6 | c.hasRedundancy << 4 | c.paddingValue << 1 | c.isNonSync, 61440 & c.degradPrio, 15 & c.degradPrio, h >>> 24 & 255, h >>> 16 & 255, h >>> 8 & 255, 255 & h], 12 + 16 * a);
                    return gs.box(gs.types.trun, n)
                }
                static initSegment(t) {
                    gs.types || gs.init();
                    const e = gs.moov(t);
                    return Ht(gs.FTYP, e)
                }
            }
            gs.types = void 0, gs.HDLR_TYPES = void 0, gs.STTS = void 0, gs.STSC = void 0, gs.STCO = void 0, gs.STSZ = void 0, gs.VMHD = void 0, gs.SMHD = void 0, gs.STSD = void 0, gs.FTYP = void 0, gs.DINF = void 0;
            const ms = 9e4;

            function ps(t, e, i = 1, r = !1) {
                const s = t * e * i;
                return r ? Math.round(s) : s
            }

            function vs(t, e = !1) {
                return ps(t, 1e3, 1 / ms, e)
            }
            let ys, Ts = null,
                Es = null;
            class Ss {
                constructor(t, e, i, r = "") {
                    if (this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.videoTrackConfig = void 0, this.observer = t, this.config = e, this.typeSupported = i, this.ISGenerated = !1, null === Ts) {
                        const t = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
                        Ts = t ? parseInt(t[1]) : 0
                    }
                    if (null === Es) {
                        const t = navigator.userAgent.match(/Safari\/(\d+)/i);
                        Es = t ? parseInt(t[1]) : 0
                    }
                }
                destroy() {
                    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null
                }
                resetTimeStamp(t) {
                    R.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = t
                }
                resetNextTimestamp() {
                    R.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1
                }
                resetInitSegment() {
                    R.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1, this.videoTrackConfig = void 0
                }
                getVideoStartPts(t) {
                    let e = !1;
                    const i = t.reduce(((t, i) => {
                        const r = i.pts - t;
                        return r < -4294967296 ? (e = !0, bs(t, i.pts)) : r > 0 ? t : i.pts
                    }), t[0].pts);
                    return e && R.debug("PTS rollover detected"), i
                }
                remux(t, e, i, r, s, n, a, o) {
                    let l, u, c, h, d, f, g = s,
                        m = s;
                    const p = t.pid > -1,
                        v = e.pid > -1,
                        y = e.samples.length,
                        T = t.samples.length > 0,
                        E = a && y > 0 || y > 1;
                    if ((!p || T) && (!v || E) || this.ISGenerated || a) {
                        if (this.ISGenerated) {
                            var S, b, A, L;
                            const t = this.videoTrackConfig;
                            !t || e.width === t.width && e.height === t.height && (null == (S = e.pixelRatio) ? void 0 : S[0]) === (null == (b = t.pixelRatio) ? void 0 : b[0]) && (null == (A = e.pixelRatio) ? void 0 : A[1]) === (null == (L = t.pixelRatio) ? void 0 : L[1]) || this.resetInitSegment()
                        } else c = this.generateIS(t, e, s, n);
                        const i = this.isVideoContiguous;
                        let r, a = -1;
                        if (E && (a = function(t) {
                                for (let e = 0; e < t.length; e++)
                                    if (t[e].key) return e;
                                return -1
                            }(e.samples), !i && this.config.forceKeyFrameOnDiscontinuity))
                            if (f = !0, a > 0) {
                                R.warn(`[mp4-remuxer]: Dropped ${a} out of ${y} video samples due to a missing keyframe`);
                                const t = this.getVideoStartPts(e.samples);
                                e.samples = e.samples.slice(a), e.dropped += a, m += (e.samples[0].pts - t) / e.inputTimeScale, r = m
                            } else -1 === a && (R.warn(`[mp4-remuxer]: No keyframe found out of ${y} video samples`), f = !1);
                        if (this.ISGenerated) {
                            if (T && E) {
                                const i = this.getVideoStartPts(e.samples),
                                    r = (bs(t.samples[0].pts, i) - i) / e.inputTimeScale;
                                g += Math.max(0, r), m += Math.max(0, -r)
                            }
                            if (T) {
                                if (t.samplerate || (R.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), c = this.generateIS(t, e, s, n)), u = this.remuxAudio(t, g, this.isAudioContiguous, n, v || E || o === Pe ? m : void 0), E) {
                                    const r = u ? u.endPTS - u.startPTS : 0;
                                    e.inputTimeScale || (R.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), c = this.generateIS(t, e, s, n)), l = this.remuxVideo(e, m, i, r)
                                }
                            } else E && (l = this.remuxVideo(e, m, i, 0));
                            l && (l.firstKeyFrame = a, l.independent = -1 !== a, l.firstKeyFramePTS = r)
                        }
                    }
                    return this.ISGenerated && this._initPTS && this._initDTS && (i.samples.length && (d = As(i, s, this._initPTS, this._initDTS)), r.samples.length && (h = Ls(r, s, this._initPTS))), {
                        audio: u,
                        video: l,
                        initSegment: c,
                        independent: f,
                        text: h,
                        id3: d
                    }
                }
                generateIS(t, e, i, r) {
                    const s = t.samples,
                        n = e.samples,
                        a = this.typeSupported,
                        o = {},
                        l = this._initPTS;
                    let u, c, h, d = !l || r,
                        f = "audio/mp4";
                    if (d && (u = c = Infinity), t.config && s.length) {
                        switch (t.timescale = t.samplerate, t.segmentCodec) {
                            case "mp3":
                                a.mpeg ? (f = "audio/mpeg", t.codec = "") : a.mp3 && (t.codec = "mp3");
                                break;
                            case "ac3":
                                t.codec = "ac-3"
                        }
                        o.audio = {
                            id: "audio",
                            container: f,
                            codec: t.codec,
                            initSegment: "mp3" === t.segmentCodec && a.mpeg ? new Uint8Array(0) : gs.initSegment([t]),
                            metadata: {
                                channelCount: t.channelCount
                            }
                        }, d && (h = t.inputTimeScale, l && h === l.timescale ? d = !1 : u = c = s[0].pts - Math.round(h * i))
                    }
                    if (e.sps && e.pps && n.length) {
                        if (e.timescale = e.inputTimeScale, o.video = {
                                id: "main",
                                container: "video/mp4",
                                codec: e.codec,
                                initSegment: gs.initSegment([e]),
                                metadata: {
                                    width: e.width,
                                    height: e.height
                                }
                            }, d)
                            if (h = e.inputTimeScale, l && h === l.timescale) d = !1;
                            else {
                                const t = this.getVideoStartPts(n),
                                    e = Math.round(h * i);
                                c = Math.min(c, bs(n[0].dts, t) - e), u = Math.min(u, t - e)
                            }
                        this.videoTrackConfig = {
                            width: e.width,
                            height: e.height,
                            pixelRatio: e.pixelRatio
                        }
                    }
                    if (Object.keys(o).length) return this.ISGenerated = !0, d ? (this._initPTS = {
                        baseTime: u,
                        timescale: h
                    }, this._initDTS = {
                        baseTime: c,
                        timescale: h
                    }) : u = h = void 0, {
                        tracks: o,
                        initPTS: u,
                        timescale: h
                    }
                }
                remuxVideo(t, e, i, r) {
                    const s = t.inputTimeScale,
                        n = t.samples,
                        a = [],
                        o = n.length,
                        l = this._initPTS;
                    let u, c, h = this.nextAvcDts,
                        d = 8,
                        f = this.videoSampleDuration,
                        g = Number.POSITIVE_INFINITY,
                        p = Number.NEGATIVE_INFINITY,
                        v = !1;
                    if (!i || null === h) {
                        const t = e * s,
                            r = n[0].pts - bs(n[0].dts, n[0].pts);
                        Ts && null !== h && Math.abs(t - r - h) < 15e3 ? i = !0 : h = t - r
                    }
                    const y = l.baseTime * s / l.timescale;
                    for (let t = 0; t < o; t++) {
                        const e = n[t];
                        e.pts = bs(e.pts - y, h), e.dts = bs(e.dts - y, h), e.dts < n[t > 0 ? t - 1 : t].dts && (v = !0)
                    }
                    v && n.sort((function(t, e) {
                        const i = t.dts - e.dts,
                            r = t.pts - e.pts;
                        return i || r
                    })), u = n[0].dts, c = n[n.length - 1].dts;
                    const b = c - u,
                        A = b ? Math.round(b / (o - 1)) : f || t.inputTimeScale / 30;
                    if (i) {
                        const t = u - h,
                            i = t > A,
                            r = t < -1;
                        if ((i || r) && (i ? R.warn(`AVC: ${vs(t,!0)} ms (${t}dts) hole between fragments detected at ${e.toFixed(3)}`) : R.warn(`AVC: ${vs(-t,!0)} ms (${t}dts) overlapping between fragments detected at ${e.toFixed(3)}`), !r || h >= n[0].pts || Ts)) {
                            u = h;
                            const e = n[0].pts - t;
                            if (i) n[0].dts = u, n[0].pts = e;
                            else
                                for (let i = 0; i < n.length && !(n[i].dts > e); i++) n[i].dts -= t, n[i].pts -= t;
                            R.log(`Video: Initial PTS/DTS adjusted: ${vs(e,!0)}/${vs(u,!0)}, delta: ${vs(t,!0)} ms`)
                        }
                    }
                    u = Math.max(0, u);
                    let L = 0,
                        k = 0,
                        w = u;
                    for (let t = 0; t < o; t++) {
                        const e = n[t],
                            i = e.units,
                            r = i.length;
                        let s = 0;
                        for (let t = 0; t < r; t++) s += i[t].data.length;
                        k += s, L += r, e.length = s, e.dts < w ? (e.dts = w, w += A / 4 | 0 || 1) : w = e.dts, g = Math.min(e.pts, g), p = Math.max(e.pts, p)
                    }
                    c = n[o - 1].dts;
                    const _ = k + 4 * L + 8;
                    let D;
                    try {
                        D = new Uint8Array(_)
                    } catch (t) {
                        return void this.observer.emit(T.ERROR, T.ERROR, {
                            type: E.MUX_ERROR,
                            details: S.REMUX_ALLOC_ERROR,
                            fatal: !1,
                            error: t,
                            bytes: _,
                            reason: `fail allocating video mdat ${_}`
                        })
                    }
                    const C = new DataView(D.buffer);
                    C.setUint32(0, _), D.set(gs.types.mdat, 4);
                    let I = !1,
                        P = Number.POSITIVE_INFINITY,
                        x = Number.POSITIVE_INFINITY,
                        M = Number.NEGATIVE_INFINITY,
                        O = Number.NEGATIVE_INFINITY;
                    for (let t = 0; t < o; t++) {
                        const e = n[t],
                            i = e.units;
                        let l, u = 0;
                        for (let t = 0, e = i.length; t < e; t++) {
                            const e = i[t],
                                r = e.data,
                                s = e.data.byteLength;
                            C.setUint32(d, s), d += 4, D.set(r, d), d += s, u += 4 + s
                        }
                        if (t < o - 1) f = n[t + 1].dts - e.dts, l = n[t + 1].pts - e.pts;
                        else {
                            const i = this.config,
                                a = t > 0 ? e.dts - n[t - 1].dts : A;
                            if (l = t > 0 ? e.pts - n[t - 1].pts : A, i.stretchShortVideoTrack && null !== this.nextAudioPts) {
                                const t = Math.floor(i.maxBufferHole * s),
                                    n = (r ? g + r * s : this.nextAudioPts) - e.pts;
                                n > t ? (f = n - a, f < 0 ? f = a : I = !0, R.log(`[mp4-remuxer]: It is approximately ${n/90} ms to the next segment; using duration ${f/90} ms for the last video frame.`)) : f = a
                            } else f = a
                        }
                        const c = Math.round(e.pts - e.dts);
                        P = Math.min(P, f), M = Math.max(M, f), x = Math.min(x, l), O = Math.max(O, l), a.push(new ks(e.key, f, u, c))
                    }
                    if (a.length)
                        if (Ts) {
                            if (Ts < 70) {
                                const t = a[0].flags;
                                t.dependsOn = 2, t.isNonSync = 0
                            }
                        } else if (Es && O - x < M - P && A / M < .025 && 0 === a[0].cts) {
                        R.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
                        let t = u;
                        for (let e = 0, i = a.length; e < i; e++) {
                            const r = t + a[e].duration,
                                s = t + a[e].cts;
                            if (e < i - 1) {
                                const t = r + a[e + 1].cts;
                                a[e].duration = t - s
                            } else a[e].duration = e ? a[e - 1].duration : A;
                            a[e].cts = 0, t = r
                        }
                    }
                    f = I || !f ? A : f, this.nextAvcDts = h = c + f, this.videoSampleDuration = f, this.isVideoContiguous = !0;
                    const F = {
                        data1: gs.moof(t.sequenceNumber++, u, m({}, t, {
                            samples: a
                        })),
                        data2: D,
                        startPTS: g / s,
                        endPTS: (p + f) / s,
                        startDTS: u / s,
                        endDTS: h / s,
                        type: "video",
                        hasAudio: !1,
                        hasVideo: !0,
                        nb: a.length,
                        dropped: t.dropped
                    };
                    return t.samples = [], t.dropped = 0, F
                }
                getSamplesPerFrame(t) {
                    switch (t.segmentCodec) {
                        case "mp3":
                            return 1152;
                        case "ac3":
                            return 1536;
                        default:
                            return 1024
                    }
                }
                remuxAudio(t, e, i, r, s) {
                    const n = t.inputTimeScale,
                        a = n / (t.samplerate ? t.samplerate : n),
                        o = this.getSamplesPerFrame(t),
                        l = o * a,
                        u = this._initPTS,
                        c = "mp3" === t.segmentCodec && this.typeSupported.mpeg,
                        h = [],
                        d = void 0 !== s;
                    let f = t.samples,
                        g = c ? 0 : 8,
                        p = this.nextAudioPts || -1;
                    const v = e * n,
                        y = u.baseTime * n / u.timescale;
                    if (this.isAudioContiguous = i = i || f.length && p > 0 && (r && Math.abs(v - p) < 9e3 || Math.abs(bs(f[0].pts - y, v) - p) < 20 * l), f.forEach((function(t) {
                            t.pts = bs(t.pts - y, v)
                        })), !i || p < 0) {
                        if (f = f.filter((t => t.pts >= 0)), !f.length) return;
                        p = 0 === s ? 0 : r && !d ? Math.max(0, v) : f[0].pts
                    }
                    if ("aac" === t.segmentCodec) {
                        const e = this.config.maxAudioFramesDrift;
                        for (let i = 0, r = p; i < f.length; i++) {
                            const s = f[i],
                                a = s.pts,
                                o = a - r,
                                u = Math.abs(1e3 * o / n);
                            if (o <= -e * l && d) 0 === i && (R.warn(`Audio frame @ ${(a/n).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3*o/n)} ms.`), this.nextAudioPts = p = r = a);
                            else if (o >= e * l && u < 1e4 && d) {
                                let e = Math.round(o / l);
                                r = a - e * l, r < 0 && (e--, r += l), 0 === i && (this.nextAudioPts = p = r), R.warn(`[mp4-remuxer]: Injecting ${e} audio frame @ ${(r/n).toFixed(3)}s due to ${Math.round(1e3*o/n)} ms gap.`);
                                for (let n = 0; n < e; n++) {
                                    const e = Math.max(r, 0);
                                    let n = ds.getSilentFrame(t.manifestCodec || t.codec, t.channelCount);
                                    n || (R.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), n = s.unit.subarray()), f.splice(i, 0, {
                                        unit: n,
                                        pts: e
                                    }), r += l, i++
                                }
                            }
                            s.pts = r, r += l
                        }
                    }
                    let b, A = null,
                        L = null,
                        k = 0,
                        w = f.length;
                    for (; w--;) k += f[w].unit.byteLength;
                    for (let e = 0, r = f.length; e < r; e++) {
                        const r = f[e],
                            s = r.unit;
                        let n = r.pts;
                        if (null !== L) {
                            h[e - 1].duration = Math.round((n - L) / a)
                        } else {
                            if (i && "aac" === t.segmentCodec && (n = p), A = n, !(k > 0)) return;
                            k += g;
                            try {
                                b = new Uint8Array(k)
                            } catch (t) {
                                return void this.observer.emit(T.ERROR, T.ERROR, {
                                    type: E.MUX_ERROR,
                                    details: S.REMUX_ALLOC_ERROR,
                                    fatal: !1,
                                    error: t,
                                    bytes: k,
                                    reason: `fail allocating audio mdat ${k}`
                                })
                            }
                            if (!c) {
                                new DataView(b.buffer).setUint32(0, k), b.set(gs.types.mdat, 4)
                            }
                        }
                        b.set(s, g);
                        const l = s.byteLength;
                        g += l, h.push(new ks(!0, o, l, 0)), L = n
                    }
                    const _ = h.length;
                    if (!_) return;
                    const D = h[h.length - 1];
                    this.nextAudioPts = p = L + a * D.duration;
                    const C = c ? new Uint8Array(0) : gs.moof(t.sequenceNumber++, A / a, m({}, t, {
                        samples: h
                    }));
                    t.samples = [];
                    const I = A / n,
                        P = p / n,
                        x = {
                            data1: C,
                            data2: b,
                            startPTS: I,
                            endPTS: P,
                            startDTS: I,
                            endDTS: P,
                            type: "audio",
                            hasAudio: !0,
                            hasVideo: !1,
                            nb: _
                        };
                    return this.isAudioContiguous = !0, x
                }
                remuxEmptyAudio(t, e, i, r) {
                    const s = t.inputTimeScale,
                        n = s / (t.samplerate ? t.samplerate : s),
                        a = this.nextAudioPts,
                        o = this._initDTS,
                        l = 9e4 * o.baseTime / o.timescale,
                        u = (null !== a ? a : r.startDTS * s) + l,
                        c = r.endDTS * s + l,
                        h = 1024 * n,
                        d = Math.ceil((c - u) / h),
                        f = ds.getSilentFrame(t.manifestCodec || t.codec, t.channelCount);
                    if (R.warn("[mp4-remuxer]: remux empty Audio"), !f) return void R.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
                    const g = [];
                    for (let t = 0; t < d; t++) {
                        const e = u + t * h;
                        g.push({
                            unit: f,
                            pts: e,
                            dts: e
                        })
                    }
                    return t.samples = g, this.remuxAudio(t, e, i, !1)
                }
            }

            function bs(t, e) {
                let i;
                if (null === e) return t;
                for (i = e < t ? -8589934592 : 8589934592; Math.abs(t - e) > 4294967296;) t += i;
                return t
            }

            function As(t, e, i, r) {
                const s = t.samples.length;
                if (!s) return;
                const n = t.inputTimeScale;
                for (let a = 0; a < s; a++) {
                    const s = t.samples[a];
                    s.pts = bs(s.pts - i.baseTime * n / i.timescale, e * n) / n, s.dts = bs(s.dts - r.baseTime * n / r.timescale, e * n) / n
                }
                const a = t.samples;
                return t.samples = [], {
                    samples: a
                }
            }

            function Ls(t, e, i) {
                const r = t.samples.length;
                if (!r) return;
                const s = t.inputTimeScale;
                for (let n = 0; n < r; n++) {
                    const r = t.samples[n];
                    r.pts = bs(r.pts - i.baseTime * s / i.timescale, e * s) / s
                }
                t.samples.sort(((t, e) => t.pts - e.pts));
                const n = t.samples;
                return t.samples = [], {
                    samples: n
                }
            }
            class ks {
                constructor(t, e, i, r) {
                    this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = e, this.size = i, this.cts = r, this.flags = {
                        isLeading: 0,
                        isDependedOn: 0,
                        hasRedundancy: 0,
                        degradPrio: 0,
                        dependsOn: t ? 2 : 1,
                        isNonSync: t ? 0 : 1
                    }
                }
            }

            function Rs(t, e) {
                const i = null == t ? void 0 : t.codec;
                if (i && i.length > 4) return i;
                if (e === x) {
                    if ("ec-3" === i || "ac-3" === i || "alac" === i) return i;
                    if ("fLaC" === i || "Opus" === i) {
                        return de(i, !1)
                    }
                    const t = "mp4a.40.5";
                    return R.info(`Parsed audio codec "${i}" or audio object type not handled. Using "${t}"`), t
                }
                return R.warn(`Unhandled video codec "${i}"`), "hvc1" === i || "hev1" === i ? "hvc1.1.6.L120.90" : "av01" === i ? "av01.0.04M.08" : "avc1.42e01e"
            }
            try {
                ys = self.performance.now.bind(self.performance)
            } catch (t) {
                R.debug("Unable to use Performance API on this environment"), ys = null == V ? void 0 : V.Date.now
            }
            const ws = [{
                demux: class {
                    constructor(t, e) {
                        this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = e
                    }
                    resetTimeStamp() {}
                    resetInitSegment(t, e, i, r) {
                        const s = this.videoTrack = Dr("video", 1),
                            n = this.audioTrack = Dr("audio", 1),
                            a = this.txtTrack = Dr("text", 1);
                        if (this.id3Track = Dr("id3", 1), this.timeOffset = 0, null == t || !t.byteLength) return;
                        const o = Ot(t);
                        if (o.video) {
                            const {
                                id: t,
                                timescale: e,
                                codec: i
                            } = o.video;
                            s.id = t, s.timescale = a.timescale = e, s.codec = i
                        }
                        if (o.audio) {
                            const {
                                id: t,
                                timescale: e,
                                codec: i
                            } = o.audio;
                            n.id = t, n.timescale = e, n.codec = i
                        }
                        a.id = Rt.text, s.sampleDuration = 0, s.duration = n.duration = r
                    }
                    resetContiguity() {
                        this.remainderData = null
                    }
                    static probe(t) {
                        return function(t) {
                            const e = t.byteLength;
                            for (let i = 0; i < e;) {
                                const r = Dt(t, i);
                                if (r > 8 && 109 === t[i + 4] && 111 === t[i + 5] && 111 === t[i + 6] && 102 === t[i + 7]) return !0;
                                i = r > 1 ? i + r : e
                            }
                            return !1
                        }(t)
                    }
                    demux(t, e) {
                        this.timeOffset = e;
                        let i = t;
                        const r = this.videoTrack,
                            s = this.txtTrack;
                        if (this.config.progressive) {
                            this.remainderData && (i = Ht(this.remainderData, t));
                            const e = function(t) {
                                const e = {
                                        valid: null,
                                        remainder: null
                                    },
                                    i = xt(t, ["moof"]);
                                if (i.length < 2) return e.remainder = t, e;
                                const r = i[i.length - 1];
                                return e.valid = nt(t, 0, r.byteOffset - 8), e.remainder = nt(t, r.byteOffset - 8), e
                            }(i);
                            this.remainderData = e.remainder, r.samples = e.valid || new Uint8Array
                        } else r.samples = i;
                        const n = this.extractID3Track(r, e);
                        return s.samples = Vt(e, r), {
                            videoTrack: r,
                            audioTrack: this.audioTrack,
                            id3Track: n,
                            textTrack: this.txtTrack
                        }
                    }
                    flush() {
                        const t = this.timeOffset,
                            e = this.videoTrack,
                            i = this.txtTrack;
                        e.samples = this.remainderData || new Uint8Array, this.remainderData = null;
                        const r = this.extractID3Track(e, this.timeOffset);
                        return i.samples = Vt(t, e), {
                            videoTrack: e,
                            audioTrack: Dr(),
                            id3Track: r,
                            textTrack: Dr()
                        }
                    }
                    extractID3Track(t, e) {
                        const i = this.id3Track;
                        if (t.samples.length) {
                            const r = xt(t.samples, ["emsg"]);
                            r && r.forEach((t => {
                                const r = function(t) {
                                    const e = t[0];
                                    let i = "",
                                        r = "",
                                        s = 0,
                                        n = 0,
                                        a = 0,
                                        o = 0,
                                        l = 0,
                                        u = 0;
                                    if (0 === e) {
                                        for (;
                                            "\0" !== wt(t.subarray(u, u + 1));) i += wt(t.subarray(u, u + 1)), u += 1;
                                        for (i += wt(t.subarray(u, u + 1)), u += 1;
                                            "\0" !== wt(t.subarray(u, u + 1));) r += wt(t.subarray(u, u + 1)), u += 1;
                                        r += wt(t.subarray(u, u + 1)), u += 1, s = Dt(t, 12), n = Dt(t, 16), o = Dt(t, 20), l = Dt(t, 24), u = 28
                                    } else if (1 === e) {
                                        u += 4, s = Dt(t, u), u += 4;
                                        const e = Dt(t, u);
                                        u += 4;
                                        const n = Dt(t, u);
                                        for (u += 4, a = 2 ** 32 * e + n, v(a) || (a = Number.MAX_SAFE_INTEGER, R.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o = Dt(t, u), u += 4, l = Dt(t, u), u += 4;
                                            "\0" !== wt(t.subarray(u, u + 1));) i += wt(t.subarray(u, u + 1)), u += 1;
                                        for (i += wt(t.subarray(u, u + 1)), u += 1;
                                            "\0" !== wt(t.subarray(u, u + 1));) r += wt(t.subarray(u, u + 1)), u += 1;
                                        r += wt(t.subarray(u, u + 1)), u += 1
                                    }
                                    return {
                                        schemeIdUri: i,
                                        value: r,
                                        timeScale: s,
                                        presentationTime: a,
                                        presentationTimeDelta: n,
                                        eventDuration: o,
                                        id: l,
                                        payload: t.subarray(u, t.byteLength)
                                    }
                                }(t);
                                if (Xr.test(r.schemeIdUri)) {
                                    const t = p(r.presentationTime) ? r.presentationTime / r.timeScale : e + r.presentationTimeDelta / r.timeScale;
                                    let s = 4294967295 === r.eventDuration ? Number.POSITIVE_INFINITY : r.eventDuration / r.timeScale;
                                    s <= .001 && (s = Number.POSITIVE_INFINITY);
                                    const n = r.payload;
                                    i.samples.push({
                                        data: n,
                                        len: n.byteLength,
                                        dts: t,
                                        pts: t,
                                        type: We,
                                        duration: s
                                    })
                                }
                            }))
                        }
                        return i
                    }
                    demuxSampleAes(t, e, i) {
                        return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
                    }
                    destroy() {}
                },
                remux: class {
                    constructor() {
                        this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null
                    }
                    destroy() {}
                    resetTimeStamp(t) {
                        this.initPTS = t, this.lastEndTime = null
                    }
                    resetNextTimestamp() {
                        this.lastEndTime = null
                    }
                    resetInitSegment(t, e, i, r) {
                        this.audioCodec = e, this.videoCodec = i, this.generateInitSegment(function(t, e) {
                            if (!t || !e) return t;
                            const i = e.keyId;
                            i && e.isCommonEncryption && xt(t, ["moov", "trak"]).forEach((t => {
                                const e = xt(t, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8);
                                let r = xt(e, ["enca"]);
                                const s = r.length > 0;
                                s || (r = xt(e, ["encv"])), r.forEach((t => {
                                    xt(s ? t.subarray(28) : t.subarray(78), ["sinf"]).forEach((t => {
                                        const e = $t(t);
                                        if (e) {
                                            const t = e.subarray(8, 24);
                                            t.some((t => 0 !== t)) || (R.log(`[eme] Patching keyId in 'enc${s?"a":"v"}>sinf>>tenc' box: ${At.hexDump(t)} -> ${At.hexDump(i)}`), e.set(i, 8))
                                        }
                                    }))
                                }))
                            }));
                            return t
                        }(t, r)), this.emitInitSegment = !0
                    }
                    generateInitSegment(t) {
                        let {
                            audioCodec: e,
                            videoCodec: i
                        } = this;
                        if (null == t || !t.byteLength) return this.initTracks = void 0, void(this.initData = void 0);
                        const r = this.initData = Ot(t);
                        r.audio && (e = Rs(r.audio, x)), r.video && (i = Rs(r.video, M));
                        const s = {};
                        r.audio && r.video ? s.audiovideo = {
                            container: "video/mp4",
                            codec: e + "," + i,
                            initSegment: t,
                            id: "main"
                        } : r.audio ? s.audio = {
                            container: "audio/mp4",
                            codec: e,
                            initSegment: t,
                            id: "audio"
                        } : r.video ? s.video = {
                            container: "video/mp4",
                            codec: i,
                            initSegment: t,
                            id: "main"
                        } : R.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = s
                    }
                    remux(t, e, i, r, s, n) {
                        var a, o;
                        let {
                            initPTS: l,
                            lastEndTime: u
                        } = this;
                        const c = {
                            audio: void 0,
                            video: void 0,
                            text: r,
                            id3: i,
                            initSegment: void 0
                        };
                        p(u) || (u = this.lastEndTime = s || 0);
                        const h = e.samples;
                        if (null == h || !h.length) return c;
                        const d = {
                            initPTS: void 0,
                            timescale: 1
                        };
                        let f = this.initData;
                        if (null != (a = f) && a.length || (this.generateInitSegment(h), f = this.initData), null == (o = f) || !o.length) return R.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), c;
                        this.emitInitSegment && (d.tracks = this.initTracks, this.emitInitSegment = !1);
                        const g = function(t, e) {
                                let i = 0,
                                    r = 0,
                                    s = 0;
                                const n = xt(t, ["moof", "traf"]);
                                for (let t = 0; t < n.length; t++) {
                                    const a = n[t],
                                        o = xt(a, ["tfhd"])[0],
                                        l = e[Dt(o, 4)];
                                    if (!l) continue;
                                    const u = l.default,
                                        c = Dt(o, 0) | (null == u ? void 0 : u.flags);
                                    let h = null == u ? void 0 : u.duration;
                                    8 & c && (h = Dt(o, 2 & c ? 12 : 8));
                                    const d = l.timescale || 9e4,
                                        f = xt(a, ["trun"]);
                                    for (let t = 0; t < f.length; t++) i = Gt(f[t]), !i && h && (i = h * Dt(f[t], 4)), l.type === M ? r += i / d : l.type === x && (s += i / d)
                                }
                                if (0 === r && 0 === s) {
                                    let e = Infinity,
                                        i = 0,
                                        r = 0;
                                    const s = xt(t, ["sidx"]);
                                    for (let t = 0; t < s.length; t++) {
                                        const n = Mt(s[t]);
                                        if (null != n && n.references) {
                                            e = Math.min(e, n.earliestPresentationTime / n.timescale);
                                            const t = n.references.reduce(((t, e) => t + e.info.duration || 0), 0);
                                            i = Math.max(i, t + n.earliestPresentationTime / n.timescale), r = i - e
                                        }
                                    }
                                    if (r && p(r)) return r
                                }
                                return r || s
                            }(h, f),
                            m = function(t, e) {
                                return xt(e, ["moof", "traf"]).reduce(((e, i) => {
                                    const r = xt(i, ["tfdt"])[0],
                                        s = r[0],
                                        n = xt(i, ["tfhd"]).reduce(((e, i) => {
                                            const n = Dt(i, 4),
                                                a = t[n];
                                            if (a) {
                                                let t = Dt(r, 4);
                                                if (1 === s) {
                                                    if (t === Lt) return R.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time"), e;
                                                    t *= Lt + 1, t += Dt(r, 8)
                                                }
                                                const i = t / (a.timescale || 9e4);
                                                if (p(i) && (null === e || i < e)) return i
                                            }
                                            return e
                                        }), null);
                                    return null !== n && p(n) && (null === e || n < e) ? n : e
                                }), null)
                            }(f, h),
                            v = null === m ? s : m;
                        (function(t, e, i, r) {
                            if (null === t) return !0;
                            const s = Math.max(r, 1),
                                n = e - t.baseTime / t.timescale;
                            return Math.abs(n - i) > s
                        }(l, v, s, g) || d.timescale !== l.timescale && n) && (d.initPTS = v - s, l && 1 === l.timescale && R.warn("Adjusting initPTS by " + (d.initPTS - l.baseTime)), this.initPTS = l = {
                            baseTime: d.initPTS,
                            timescale: 1
                        });
                        const y = t ? v - l.baseTime / l.timescale : u,
                            T = y + g;
                        ! function(t, e, i) {
                            xt(e, ["moof", "traf"]).forEach((e => {
                                xt(e, ["tfhd"]).forEach((r => {
                                    const s = Dt(r, 4),
                                        n = t[s];
                                    if (!n) return;
                                    const a = n.timescale || 9e4;
                                    xt(e, ["tfdt"]).forEach((t => {
                                        const e = t[0],
                                            r = i * a;
                                        if (r) {
                                            let i = Dt(t, 4);
                                            if (0 === e) i -= r, i = Math.max(i, 0), Pt(t, 4, i);
                                            else {
                                                i *= Math.pow(2, 32), i += Dt(t, 8), i -= r, i = Math.max(i, 0);
                                                const e = Math.floor(i / (Lt + 1)),
                                                    s = Math.floor(i % (Lt + 1));
                                                Pt(t, 4, e), Pt(t, 8, s)
                                            }
                                        }
                                    }))
                                }))
                            }))
                        }(f, h, l.baseTime / l.timescale), g > 0 ? this.lastEndTime = T : (R.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
                        const E = !!f.audio,
                            S = !!f.video;
                        let b = "";
                        E && (b += "audio"), S && (b += "video");
                        const A = {
                            data1: h,
                            startPTS: y,
                            startDTS: y,
                            endPTS: T,
                            endDTS: T,
                            type: b,
                            hasAudio: E,
                            hasVideo: S,
                            nb: 1,
                            dropped: 0
                        };
                        return c.audio = "audio" === A.type ? A : void 0, c.video = "audio" !== A.type ? A : void 0, c.initSegment = d, c.id3 = As(i, s, l, l), r.samples.length && (c.text = Ls(r, s, l)), c
                    }
                }
            }, {
                demux: ns,
                remux: Ss
            }, {
                demux: class extends Cr {
                    constructor(t, e) {
                        super(), this.observer = void 0, this.config = void 0, this.observer = t, this.config = e
                    }
                    resetInitSegment(t, e, i, r) {
                        super.resetInitSegment(t, e, i, r), this._audioTrack = {
                            container: "audio/adts",
                            type: "audio",
                            id: 2,
                            pid: -1,
                            sequenceNumber: 0,
                            segmentCodec: "aac",
                            samples: [],
                            manifestCodec: e,
                            duration: r,
                            inputTimeScale: 9e4,
                            dropped: 0
                        }
                    }
                    static probe(t) {
                        if (!t) return !1;
                        const e = lt(t, 0);
                        let i = (null == e ? void 0 : e.length) || 0;
                        if (zr(t, i)) return !1;
                        for (let e = t.length; i < e; i++)
                            if (Fr(t, i)) return R.log("ADTS sync word found !"), !0;
                        return !1
                    }
                    canParse(t, e) {
                        return function(t, e) {
                            return function(t, e) {
                                return e + 5 < t.length
                            }(t, e) && Pr(t, e) && Mr(t, e) <= t.length - e
                        }(t, e)
                    }
                    appendFrame(t, e, i) {
                        Nr(t, this.observer, e, i, t.manifestCodec);
                        const r = Ur(t, e, i, this.basePTS, this.frameIndex);
                        if (r && 0 === r.missing) return r
                    }
                },
                remux: Ss
            }, {
                demux: class extends Cr {
                    resetInitSegment(t, e, i, r) {
                        super.resetInitSegment(t, e, i, r), this._audioTrack = {
                            container: "audio/mpeg",
                            type: "audio",
                            id: 2,
                            pid: -1,
                            sequenceNumber: 0,
                            segmentCodec: "mp3",
                            samples: [],
                            manifestCodec: e,
                            duration: r,
                            inputTimeScale: 9e4,
                            dropped: 0
                        }
                    }
                    static probe(t) {
                        if (!t) return !1;
                        const e = lt(t, 0);
                        let i = (null == e ? void 0 : e.length) || 0;
                        if (e && 11 === t[i] && 119 === t[i + 1] && void 0 !== ht(e) && Qr(t, i) <= 16) return !1;
                        for (let e = t.length; i < e; i++)
                            if (zr(t, i)) return R.log("MPEG Audio sync word found !"), !0;
                        return !1
                    }
                    canParse(t, e) {
                        return function(t, e) {
                            return qr(t, e) && 4 <= t.length - e
                        }(t, e)
                    }
                    appendFrame(t, e, i) {
                        if (null !== this.basePTS) return Kr(t, e, i, this.basePTS, this.frameIndex)
                    }
                },
                remux: Ss
            }];
            ws.splice(2, 0, {
                demux: Jr,
                remux: Ss
            });
            class _s {
                constructor(t, e, i, r, s) {
                    this.async = !1, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = t, this.typeSupported = e, this.config = i, this.vendor = r, this.id = s
                }
                configure(t) {
                    this.transmuxConfig = t, this.decrypter && this.decrypter.reset()
                }
                push(t, e, i, r) {
                    const s = i.transmuxing;
                    s.executeStart = ys();
                    let n = new Uint8Array(t);
                    const {
                        currentTransmuxState: a,
                        transmuxConfig: o
                    } = this;
                    r && (this.currentTransmuxState = r);
                    const {
                        contiguous: l,
                        discontinuity: u,
                        trackSwitch: c,
                        accurateTimeOffset: h,
                        timeOffset: d,
                        initSegmentChange: f
                    } = r || a, {
                        audioCodec: g,
                        videoCodec: m,
                        defaultInitPts: p,
                        duration: v,
                        initSegmentData: y
                    } = o, b = function(t, e) {
                        let i = null;
                        t.byteLength > 0 && null != (null == e ? void 0 : e.key) && null !== e.iv && null != e.method && (i = e);
                        return i
                    }(n, e);
                    if (b && "AES-128" === b.method) {
                        const t = this.getDecrypter();
                        if (!t.isSync()) return this.decryptionPromise = t.webCryptoDecrypt(n, b.key.buffer, b.iv.buffer).then((t => {
                            const e = this.push(t, null, i);
                            return this.decryptionPromise = null, e
                        })), this.decryptionPromise; {
                            let e = t.softwareDecrypt(n, b.key.buffer, b.iv.buffer);
                            if (i.part > -1 && (e = t.flush()), !e) return s.executeEnd = ys(), Ds(i);
                            n = new Uint8Array(e)
                        }
                    }
                    const A = this.needsProbing(u, c);
                    if (A) {
                        const t = this.configureTransmuxer(n);
                        if (t) return R.warn(`[transmuxer] ${t.message}`), this.observer.emit(T.ERROR, T.ERROR, {
                            type: E.MEDIA_ERROR,
                            details: S.FRAG_PARSING_ERROR,
                            fatal: !1,
                            error: t,
                            reason: t.message
                        }), s.executeEnd = ys(), Ds(i)
                    }(u || c || f || A) && this.resetInitSegment(y, g, m, v, e), (u || f || A) && this.resetInitialTimestamp(p), l || this.resetContiguity();
                    const L = this.transmux(n, b, d, h, i),
                        k = this.currentTransmuxState;
                    return k.contiguous = !0, k.discontinuity = !1, k.trackSwitch = !1, s.executeEnd = ys(), L
                }
                flush(t) {
                    const e = t.transmuxing;
                    e.executeStart = ys();
                    const {
                        decrypter: i,
                        currentTransmuxState: r,
                        decryptionPromise: s
                    } = this;
                    if (s) return s.then((() => this.flush(t)));
                    const n = [],
                        {
                            timeOffset: a
                        } = r;
                    if (i) {
                        const e = i.flush();
                        e && n.push(this.push(e, null, t))
                    }
                    const {
                        demuxer: o,
                        remuxer: l
                    } = this;
                    if (!o || !l) return e.executeEnd = ys(), [Ds(t)];
                    const u = o.flush(a);
                    return Cs(u) ? u.then((e => (this.flushRemux(n, e, t), n))) : (this.flushRemux(n, u, t), n)
                }
                flushRemux(t, e, i) {
                    const {
                        audioTrack: r,
                        videoTrack: s,
                        id3Track: n,
                        textTrack: a
                    } = e, {
                        accurateTimeOffset: o,
                        timeOffset: l
                    } = this.currentTransmuxState;
                    R.log(`[transmuxer.ts]: Flushed fragment ${i.sn}${i.part>-1?" p: "+i.part:""} of level ${i.level}`);
                    const u = this.remuxer.remux(r, s, n, a, l, o, !0, this.id);
                    t.push({
                        remuxResult: u,
                        chunkMeta: i
                    }), i.transmuxing.executeEnd = ys()
                }
                resetInitialTimestamp(t) {
                    const {
                        demuxer: e,
                        remuxer: i
                    } = this;
                    e && i && (e.resetTimeStamp(t), i.resetTimeStamp(t))
                }
                resetContiguity() {
                    const {
                        demuxer: t,
                        remuxer: e
                    } = this;
                    t && e && (t.resetContiguity(), e.resetNextTimestamp())
                }
                resetInitSegment(t, e, i, r, s) {
                    const {
                        demuxer: n,
                        remuxer: a
                    } = this;
                    n && a && (n.resetInitSegment(t, e, i, r), a.resetInitSegment(t, e, i, s))
                }
                destroy() {
                    this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0)
                }
                transmux(t, e, i, r, s) {
                    let n;
                    return n = e && "SAMPLE-AES" === e.method ? this.transmuxSampleAes(t, e, i, r, s) : this.transmuxUnencrypted(t, i, r, s), n
                }
                transmuxUnencrypted(t, e, i, r) {
                    const {
                        audioTrack: s,
                        videoTrack: n,
                        id3Track: a,
                        textTrack: o
                    } = this.demuxer.demux(t, e, !1, !this.config.progressive);
                    return {
                        remuxResult: this.remuxer.remux(s, n, a, o, e, i, !1, this.id),
                        chunkMeta: r
                    }
                }
                transmuxSampleAes(t, e, i, r, s) {
                    return this.demuxer.demuxSampleAes(t, e, i).then((t => ({
                        remuxResult: this.remuxer.remux(t.audioTrack, t.videoTrack, t.id3Track, t.textTrack, i, r, !1, this.id),
                        chunkMeta: s
                    })))
                }
                configureTransmuxer(t) {
                    const {
                        config: e,
                        observer: i,
                        typeSupported: r,
                        vendor: s
                    } = this;
                    let n;
                    for (let e = 0, i = ws.length; e < i; e++) {
                        var a;
                        if (null != (a = ws[e].demux) && a.probe(t)) {
                            n = ws[e];
                            break
                        }
                    }
                    if (!n) return new Error("Failed to find demuxer by probing fragment data");
                    const o = this.demuxer,
                        l = this.remuxer,
                        u = n.remux,
                        c = n.demux;
                    l && l instanceof u || (this.remuxer = new u(i, e, r, s)), o && o instanceof c || (this.demuxer = new c(i, e, r), this.probe = c.probe)
                }
                needsProbing(t, e) {
                    return !this.demuxer || !this.remuxer || t || e
                }
                getDecrypter() {
                    let t = this.decrypter;
                    return t || (t = this.decrypter = new fr(this.config)), t
                }
            }
            const Ds = t => ({
                remuxResult: {},
                chunkMeta: t
            });

            function Cs(t) {
                return "then" in t && t.then instanceof Function
            }
            class Is {
                constructor(t, e, i, r, s) {
                    this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = t, this.videoCodec = e, this.initSegmentData = i, this.duration = r, this.defaultInitPts = s || null
                }
            }
            class Ps {
                constructor(t, e, i, r, s, n) {
                    this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = t, this.contiguous = e, this.accurateTimeOffset = i, this.trackSwitch = r, this.timeOffset = s, this.initSegmentChange = n
                }
            }
            var xs = {
                exports: {}
            };
            ! function(t) {
                var e = Object.prototype.hasOwnProperty,
                    i = "~";

                function r() {}

                function s(t, e, i) {
                    this.fn = t, this.context = e, this.once = i || !1
                }

                function n(t, e, r, n, a) {
                    if ("function" != typeof r) throw new TypeError("The listener must be a function");
                    var o = new s(r, n || t, a),
                        l = i ? i + e : e;
                    return t._events[l] ? t._events[l].fn ? t._events[l] = [t._events[l], o] : t._events[l].push(o) : (t._events[l] = o, t._eventsCount++), t
                }

                function a(t, e) {
                    0 == --t._eventsCount ? t._events = new r : delete t._events[e]
                }

                function o() {
                    this._events = new r, this._eventsCount = 0
                }
                Object.create && (r.prototype = Object.create(null), (new r).__proto__ || (i = !1)), o.prototype.eventNames = function() {
                    var t, r, s = [];
                    if (0 === this._eventsCount) return s;
                    for (r in t = this._events) e.call(t, r) && s.push(i ? r.slice(1) : r);
                    return Object.getOwnPropertySymbols ? s.concat(Object.getOwnPropertySymbols(t)) : s
                }, o.prototype.listeners = function(t) {
                    var e = i ? i + t : t,
                        r = this._events[e];
                    if (!r) return [];
                    if (r.fn) return [r.fn];
                    for (var s = 0, n = r.length, a = new Array(n); s < n; s++) a[s] = r[s].fn;
                    return a
                }, o.prototype.listenerCount = function(t) {
                    var e = i ? i + t : t,
                        r = this._events[e];
                    return r ? r.fn ? 1 : r.length : 0
                }, o.prototype.emit = function(t, e, r, s, n, a) {
                    var o = i ? i + t : t;
                    if (!this._events[o]) return !1;
                    var l, u, c = this._events[o],
                        h = arguments.length;
                    if (c.fn) {
                        switch (c.once && this.removeListener(t, c.fn, void 0, !0), h) {
                            case 1:
                                return c.fn.call(c.context), !0;
                            case 2:
                                return c.fn.call(c.context, e), !0;
                            case 3:
                                return c.fn.call(c.context, e, r), !0;
                            case 4:
                                return c.fn.call(c.context, e, r, s), !0;
                            case 5:
                                return c.fn.call(c.context, e, r, s, n), !0;
                            case 6:
                                return c.fn.call(c.context, e, r, s, n, a), !0
                        }
                        for (u = 1, l = new Array(h - 1); u < h; u++) l[u - 1] = arguments[u];
                        c.fn.apply(c.context, l)
                    } else {
                        var d, f = c.length;
                        for (u = 0; u < f; u++) switch (c[u].once && this.removeListener(t, c[u].fn, void 0, !0), h) {
                            case 1:
                                c[u].fn.call(c[u].context);
                                break;
                            case 2:
                                c[u].fn.call(c[u].context, e);
                                break;
                            case 3:
                                c[u].fn.call(c[u].context, e, r);
                                break;
                            case 4:
                                c[u].fn.call(c[u].context, e, r, s);
                                break;
                            default:
                                if (!l)
                                    for (d = 1, l = new Array(h - 1); d < h; d++) l[d - 1] = arguments[d];
                                c[u].fn.apply(c[u].context, l)
                        }
                    }
                    return !0
                }, o.prototype.on = function(t, e, i) {
                    return n(this, t, e, i, !1)
                }, o.prototype.once = function(t, e, i) {
                    return n(this, t, e, i, !0)
                }, o.prototype.removeListener = function(t, e, r, s) {
                    var n = i ? i + t : t;
                    if (!this._events[n]) return this;
                    if (!e) return a(this, n), this;
                    var o = this._events[n];
                    if (o.fn) o.fn !== e || s && !o.once || r && o.context !== r || a(this, n);
                    else {
                        for (var l = 0, u = [], c = o.length; l < c; l++)(o[l].fn !== e || s && !o[l].once || r && o[l].context !== r) && u.push(o[l]);
                        u.length ? this._events[n] = 1 === u.length ? u[0] : u : a(this, n)
                    }
                    return this
                }, o.prototype.removeAllListeners = function(t) {
                    var e;
                    return t ? (e = i ? i + t : t, this._events[e] && a(this, e)) : (this._events = new r, this._eventsCount = 0), this
                }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = i, o.EventEmitter = o, t.exports = o
            }(xs);
            var Ms = r(xs.exports);
            class Os {
                constructor(t, e, i, r) {
                    this.error = null, this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0;
                    const s = t.config;
                    this.hls = t, this.id = e, this.useWorker = !!s.enableWorker, this.onTransmuxComplete = i, this.onFlush = r;
                    const n = (t, e) => {
                        (e = e || {}).frag = this.frag, e.id = this.id, t === T.ERROR && (this.error = e.error), this.hls.trigger(t, e)
                    };
                    this.observer = new Ms, this.observer.on(T.FRAG_DECRYPTED, n), this.observer.on(T.ERROR, n);
                    const a = re(s.preferManagedMediaSource) || {
                            isTypeSupported: () => !1
                        },
                        o = {
                            mpeg: a.isTypeSupported("audio/mpeg"),
                            mp3: a.isTypeSupported('audio/mp4; codecs="mp3"'),
                            ac3: a.isTypeSupported('audio/mp4; codecs="ac-3"')
                        };
                    if (this.useWorker && "undefined" != typeof Worker) {
                        if (s.workerPath || "function" == typeof __HLS_WORKER_BUNDLE__) {
                            try {
                                s.workerPath ? (R.log(`loading Web Worker ${s.workerPath} for "${e}"`), this.workerContext = function(t) {
                                    const e = new self.URL(t, self.location.href).href;
                                    return {
                                        worker: new self.Worker(e),
                                        scriptURL: e
                                    }
                                }(s.workerPath)) : (R.log(`injecting Web Worker for "${e}"`), this.workerContext = function() {
                                    const t = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {
                                            type: "text/javascript"
                                        }),
                                        e = self.URL.createObjectURL(t);
                                    return {
                                        worker: new self.Worker(e),
                                        objectURL: e
                                    }
                                }()), this.onwmsg = t => this.onWorkerMessage(t);
                                const {
                                    worker: t
                                } = this.workerContext;
                                t.addEventListener("message", this.onwmsg), t.onerror = t => {
                                    const i = new Error(`${t.message}  (${t.filename}:${t.lineno})`);
                                    s.enableWorker = !1, R.warn(`Error in "${e}" Web Worker, fallback to inline`), this.hls.trigger(T.ERROR, {
                                        type: E.OTHER_ERROR,
                                        details: S.INTERNAL_EXCEPTION,
                                        fatal: !1,
                                        event: "demuxerWorker",
                                        error: i
                                    })
                                }, t.postMessage({
                                    cmd: "init",
                                    typeSupported: o,
                                    vendor: "",
                                    id: e,
                                    config: JSON.stringify(s)
                                })
                            } catch (t) {
                                R.warn(`Error setting up "${e}" Web Worker, fallback to inline`, t), this.resetWorker(), this.error = null, this.transmuxer = new _s(this.observer, o, s, "", e)
                            }
                            return
                        }
                    }
                    this.transmuxer = new _s(this.observer, o, s, "", e)
                }
                resetWorker() {
                    if (this.workerContext) {
                        const {
                            worker: t,
                            objectURL: e
                        } = this.workerContext;
                        e && self.URL.revokeObjectURL(e), t.removeEventListener("message", this.onwmsg), t.onerror = null, t.terminate(), this.workerContext = null
                    }
                }
                destroy() {
                    if (this.workerContext) this.resetWorker(), this.onwmsg = void 0;
                    else {
                        const t = this.transmuxer;
                        t && (t.destroy(), this.transmuxer = null)
                    }
                    const t = this.observer;
                    t && t.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null
                }
                push(t, e, i, r, s, n, a, o, l, u) {
                    var c, h;
                    l.transmuxing.start = self.performance.now();
                    const {
                        transmuxer: d
                    } = this, f = n ? n.start : s.start, g = s.decryptdata, m = this.frag, p = !(m && s.cc === m.cc), v = !(m && l.level === m.level), y = m ? l.sn - m.sn : -1, T = this.part ? l.part - this.part.index : -1, E = 0 === y && l.id > 1 && l.id === (null == m ? void 0 : m.stats.chunkCount), S = !v && (1 === y || 0 === y && (1 === T || E && T <= 0)), b = self.performance.now();
                    (v || y || 0 === s.stats.parsing.start) && (s.stats.parsing.start = b), !n || !T && S || (n.stats.parsing.start = b);
                    const A = !(m && (null == (c = s.initSegment) ? void 0 : c.url) === (null == (h = m.initSegment) ? void 0 : h.url)),
                        L = new Ps(p, S, o, v, f, A);
                    if (!S || p || A) {
                        R.log(`[transmuxer-interface, ${s.type}]: Starting new transmux session for sn: ${l.sn} p: ${l.part} level: ${l.level} id: ${l.id}\n        discontinuity: ${p}\n        trackSwitch: ${v}\n        contiguous: ${S}\n        accurateTimeOffset: ${o}\n        timeOffset: ${f}\n        initSegmentChange: ${A}`);
                        const t = new Is(i, r, e, a, u);
                        this.configureTransmuxer(t)
                    }
                    if (this.frag = s, this.part = n, this.workerContext) this.workerContext.worker.postMessage({
                        cmd: "demux",
                        data: t,
                        decryptdata: g,
                        chunkMeta: l,
                        state: L
                    }, t instanceof ArrayBuffer ? [t] : []);
                    else if (d) {
                        const e = d.push(t, g, l, L);
                        Cs(e) ? (d.async = !0, e.then((t => {
                            this.handleTransmuxComplete(t)
                        })).catch((t => {
                            this.transmuxerError(t, l, "transmuxer-interface push error")
                        }))) : (d.async = !1, this.handleTransmuxComplete(e))
                    }
                }
                flush(t) {
                    t.transmuxing.start = self.performance.now();
                    const {
                        transmuxer: e
                    } = this;
                    if (this.workerContext) this.workerContext.worker.postMessage({
                        cmd: "flush",
                        chunkMeta: t
                    });
                    else if (e) {
                        let i = e.flush(t);
                        Cs(i) || e.async ? (Cs(i) || (i = Promise.resolve(i)), i.then((e => {
                            this.handleFlushResult(e, t)
                        })).catch((e => {
                            this.transmuxerError(e, t, "transmuxer-interface flush error")
                        }))) : this.handleFlushResult(i, t)
                    }
                }
                transmuxerError(t, e, i) {
                    this.hls && (this.error = t, this.hls.trigger(T.ERROR, {
                        type: E.MEDIA_ERROR,
                        details: S.FRAG_PARSING_ERROR,
                        chunkMeta: e,
                        frag: this.frag || void 0,
                        fatal: !1,
                        error: t,
                        err: t,
                        reason: i
                    }))
                }
                handleFlushResult(t, e) {
                    t.forEach((t => {
                        this.handleTransmuxComplete(t)
                    })), this.onFlush(e)
                }
                onWorkerMessage(t) {
                    const e = t.data;
                    if (null == e || !e.event) return void R.warn("worker message received with no " + (e ? "event name" : "data"));
                    const i = this.hls;
                    if (this.hls) switch (e.event) {
                        case "init":
                            {
                                var r;
                                const t = null == (r = this.workerContext) ? void 0 : r.objectURL;t && self.URL.revokeObjectURL(t);
                                break
                            }
                        case "transmuxComplete":
                            this.handleTransmuxComplete(e.data);
                            break;
                        case "flush":
                            this.onFlush(e.data);
                            break;
                        case "workerLog":
                            R[e.data.logType] && R[e.data.logType](e.data.message);
                            break;
                        default:
                            e.data = e.data || {}, e.data.frag = this.frag, e.data.id = this.id, i.trigger(e.event, e.data)
                    }
                }
                configureTransmuxer(t) {
                    const {
                        transmuxer: e
                    } = this;
                    this.workerContext ? this.workerContext.worker.postMessage({
                        cmd: "configure",
                        config: t
                    }) : e && e.configure(t)
                }
                handleTransmuxComplete(t) {
                    t.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(t)
                }
            }

            function Fs(t, e) {
                if (t.length !== e.length) return !1;
                for (let i = 0; i < t.length; i++)
                    if (!Ns(t[i].attrs, e[i].attrs)) return !1;
                return !0
            }

            function Ns(t, e, i) {
                const r = t["STABLE-RENDITION-ID"];
                return r && !i ? r === e["STABLE-RENDITION-ID"] : !(i || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some((i => t[i] !== e[i]))
            }

            function Bs(t, e) {
                return e.label.toLowerCase() === t.name.toLowerCase() && (!e.language || e.language.toLowerCase() === (t.lang || "").toLowerCase())
            }
            class Us {
                constructor(t) {
                    this.buffered = void 0;
                    const e = (e, i, r) => {
                        if ((i >>>= 0) > r - 1) throw new DOMException(`Failed to execute '${e}' on 'TimeRanges': The index provided (${i}) is greater than the maximum bound (${r})`);
                        return t[i][e]
                    };
                    this.buffered = {
                        get length() {
                            return t.length
                        },
                        end: i => e("end", i, t.length),
                        start: i => e("start", i, t.length)
                    }
                }
            }
            class $s {
                constructor(t) {
                    this.buffers = void 0, this.queues = {
                        video: [],
                        audio: [],
                        audiovideo: []
                    }, this.buffers = t
                }
                append(t, e, i) {
                    const r = this.queues[e];
                    r.push(t), 1 !== r.length || i || this.executeNext(e)
                }
                insertAbort(t, e) {
                    this.queues[e].unshift(t), this.executeNext(e)
                }
                appendBlocker(t) {
                    let e;
                    const i = new Promise((t => {
                            e = t
                        })),
                        r = {
                            execute: e,
                            onStart: () => {},
                            onComplete: () => {},
                            onError: () => {}
                        };
                    return this.append(r, t), i
                }
                executeNext(t) {
                    const e = this.queues[t];
                    if (e.length) {
                        const i = e[0];
                        try {
                            i.execute()
                        } catch (e) {
                            R.warn(`[buffer-operation-queue]: Exception executing "${t}" SourceBuffer operation: ${e}`), i.onError(e);
                            const r = this.buffers[t];
                            null != r && r.updating || this.shiftAndExecuteNext(t)
                        }
                    }
                }
                shiftAndExecuteNext(t) {
                    this.queues[t].shift(), this.executeNext(t)
                }
                current(t) {
                    return this.queues[t][0]
                }
            }
            const Gs = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/;

            function Hs(t) {
                const e = t.querySelectorAll("source");
                [].slice.call(e).forEach((e => {
                    t.removeChild(e)
                }))
            }
            const Vs = {
                    42: 225,
                    92: 233,
                    94: 237,
                    95: 243,
                    96: 250,
                    123: 231,
                    124: 247,
                    125: 209,
                    126: 241,
                    127: 9608,
                    128: 174,
                    129: 176,
                    130: 189,
                    131: 191,
                    132: 8482,
                    133: 162,
                    134: 163,
                    135: 9834,
                    136: 224,
                    137: 32,
                    138: 232,
                    139: 226,
                    140: 234,
                    141: 238,
                    142: 244,
                    143: 251,
                    144: 193,
                    145: 201,
                    146: 211,
                    147: 218,
                    148: 220,
                    149: 252,
                    150: 8216,
                    151: 161,
                    152: 42,
                    153: 8217,
                    154: 9473,
                    155: 169,
                    156: 8480,
                    157: 8226,
                    158: 8220,
                    159: 8221,
                    160: 192,
                    161: 194,
                    162: 199,
                    163: 200,
                    164: 202,
                    165: 203,
                    166: 235,
                    167: 206,
                    168: 207,
                    169: 239,
                    170: 212,
                    171: 217,
                    172: 249,
                    173: 219,
                    174: 171,
                    175: 187,
                    176: 195,
                    177: 227,
                    178: 205,
                    179: 204,
                    180: 236,
                    181: 210,
                    182: 242,
                    183: 213,
                    184: 245,
                    185: 123,
                    186: 125,
                    187: 92,
                    188: 94,
                    189: 95,
                    190: 124,
                    191: 8764,
                    192: 196,
                    193: 228,
                    194: 214,
                    195: 246,
                    196: 223,
                    197: 165,
                    198: 164,
                    199: 9475,
                    200: 197,
                    201: 229,
                    202: 216,
                    203: 248,
                    204: 9487,
                    205: 9491,
                    206: 9495,
                    207: 9499
                },
                Ws = t => String.fromCharCode(Vs[t] || t),
                Ks = 15,
                js = 100,
                qs = {
                    17: 1,
                    18: 3,
                    21: 5,
                    22: 7,
                    23: 9,
                    16: 11,
                    19: 12,
                    20: 14
                },
                Ys = {
                    17: 2,
                    18: 4,
                    21: 6,
                    22: 8,
                    23: 10,
                    19: 13,
                    20: 15
                },
                zs = {
                    25: 1,
                    26: 3,
                    29: 5,
                    30: 7,
                    31: 9,
                    24: 11,
                    27: 12,
                    28: 14
                },
                Xs = {
                    25: 2,
                    26: 4,
                    29: 6,
                    30: 8,
                    31: 10,
                    27: 13,
                    28: 15
                },
                Qs = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
            class Js {
                constructor() {
                    this.time = null, this.verboseLevel = 0
                }
                log(t, e) {
                    if (this.verboseLevel >= t) {
                        const i = "function" == typeof e ? e() : e;
                        R.log(`${this.time} [${t}] ${i}`)
                    }
                }
            }
            const Zs = function(t) {
                const e = [];
                for (let i = 0; i < t.length; i++) e.push(t[i].toString(16));
                return e
            };
            class tn {
                constructor() {
                    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
                }
                reset() {
                    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
                }
                setStyles(t) {
                    const e = ["foreground", "underline", "italics", "background", "flash"];
                    for (let i = 0; i < e.length; i++) {
                        const r = e[i];
                        t.hasOwnProperty(r) && (this[r] = t[r])
                    }
                }
                isDefault() {
                    return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash
                }
                equals(t) {
                    return this.foreground === t.foreground && this.underline === t.underline && this.italics === t.italics && this.background === t.background && this.flash === t.flash
                }
                copy(t) {
                    this.foreground = t.foreground, this.underline = t.underline, this.italics = t.italics, this.background = t.background, this.flash = t.flash
                }
                toString() {
                    return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
                }
            }
            class en {
                constructor() {
                    this.uchar = " ", this.penState = new tn
                }
                reset() {
                    this.uchar = " ", this.penState.reset()
                }
                setChar(t, e) {
                    this.uchar = t, this.penState.copy(e)
                }
                setPenState(t) {
                    this.penState.copy(t)
                }
                equals(t) {
                    return this.uchar === t.uchar && this.penState.equals(t.penState)
                }
                copy(t) {
                    this.uchar = t.uchar, this.penState.copy(t.penState)
                }
                isEmpty() {
                    return " " === this.uchar && this.penState.isDefault()
                }
            }
            class rn {
                constructor(t) {
                    this.chars = [], this.pos = 0, this.currPenState = new tn, this.cueStartTime = null, this.logger = void 0;
                    for (let t = 0; t < js; t++) this.chars.push(new en);
                    this.logger = t
                }
                equals(t) {
                    for (let e = 0; e < js; e++)
                        if (!this.chars[e].equals(t.chars[e])) return !1;
                    return !0
                }
                copy(t) {
                    for (let e = 0; e < js; e++) this.chars[e].copy(t.chars[e])
                }
                isEmpty() {
                    let t = !0;
                    for (let e = 0; e < js; e++)
                        if (!this.chars[e].isEmpty()) {
                            t = !1;
                            break
                        }
                    return t
                }
                setCursor(t) {
                    this.pos !== t && (this.pos = t), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > js && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = js)
                }
                moveCursor(t) {
                    const e = this.pos + t;
                    if (t > 1)
                        for (let t = this.pos + 1; t < e + 1; t++) this.chars[t].setPenState(this.currPenState);
                    this.setCursor(e)
                }
                backSpace() {
                    this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState)
                }
                insertChar(t) {
                    t >= 144 && this.backSpace();
                    const e = Ws(t);
                    this.pos >= js ? this.logger.log(0, (() => "Cannot insert " + t.toString(16) + " (" + e + ") at position " + this.pos + ". Skipping it!")) : (this.chars[this.pos].setChar(e, this.currPenState), this.moveCursor(1))
                }
                clearFromPos(t) {
                    let e;
                    for (e = t; e < js; e++) this.chars[e].reset()
                }
                clear() {
                    this.clearFromPos(0), this.pos = 0, this.currPenState.reset()
                }
                clearToEndOfRow() {
                    this.clearFromPos(this.pos)
                }
                getTextString() {
                    const t = [];
                    let e = !0;
                    for (let i = 0; i < js; i++) {
                        const r = this.chars[i].uchar;
                        " " !== r && (e = !1), t.push(r)
                    }
                    return e ? "" : t.join("")
                }
                setPenStyles(t) {
                    this.currPenState.setStyles(t);
                    this.chars[this.pos].setPenState(this.currPenState)
                }
            }
            class sn {
                constructor(t) {
                    this.rows = [], this.currRow = 14, this.nrRollUpRows = null, this.lastOutputScreen = null, this.logger = void 0;
                    for (let e = 0; e < Ks; e++) this.rows.push(new rn(t));
                    this.logger = t
                }
                reset() {
                    for (let t = 0; t < Ks; t++) this.rows[t].clear();
                    this.currRow = 14
                }
                equals(t) {
                    let e = !0;
                    for (let i = 0; i < Ks; i++)
                        if (!this.rows[i].equals(t.rows[i])) {
                            e = !1;
                            break
                        }
                    return e
                }
                copy(t) {
                    for (let e = 0; e < Ks; e++) this.rows[e].copy(t.rows[e])
                }
                isEmpty() {
                    let t = !0;
                    for (let e = 0; e < Ks; e++)
                        if (!this.rows[e].isEmpty()) {
                            t = !1;
                            break
                        }
                    return t
                }
                backSpace() {
                    this.rows[this.currRow].backSpace()
                }
                clearToEndOfRow() {
                    this.rows[this.currRow].clearToEndOfRow()
                }
                insertChar(t) {
                    this.rows[this.currRow].insertChar(t)
                }
                setPen(t) {
                    this.rows[this.currRow].setPenStyles(t)
                }
                moveCursor(t) {
                    this.rows[this.currRow].moveCursor(t)
                }
                setCursor(t) {
                    this.logger.log(2, "setCursor: " + t);
                    this.rows[this.currRow].setCursor(t)
                }
                setPAC(t) {
                    this.logger.log(2, (() => "pacData = " + JSON.stringify(t)));
                    let e = t.row - 1;
                    if (this.nrRollUpRows && e < this.nrRollUpRows - 1 && (e = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== e) {
                        for (let t = 0; t < Ks; t++) this.rows[t].clear();
                        const t = this.currRow + 1 - this.nrRollUpRows,
                            i = this.lastOutputScreen;
                        if (i) {
                            const r = i.rows[t].cueStartTime,
                                s = this.logger.time;
                            if (null !== r && null !== s && r < s)
                                for (let r = 0; r < this.nrRollUpRows; r++) this.rows[e - this.nrRollUpRows + r + 1].copy(i.rows[t + r])
                        }
                    }
                    this.currRow = e;
                    const i = this.rows[this.currRow];
                    if (null !== t.indent) {
                        const e = t.indent,
                            r = Math.max(e - 1, 0);
                        i.setCursor(t.indent), t.color = i.chars[r].penState.foreground
                    }
                    const r = {
                        foreground: t.color,
                        underline: t.underline,
                        italics: t.italics,
                        background: "black",
                        flash: !1
                    };
                    this.setPen(r)
                }
                setBkgData(t) {
                    this.logger.log(2, (() => "bkgData = " + JSON.stringify(t))), this.backSpace(), this.setPen(t), this.insertChar(32)
                }
                setRollUpRows(t) {
                    this.nrRollUpRows = t
                }
                rollUp() {
                    if (null === this.nrRollUpRows) return void this.logger.log(3, "roll_up but nrRollUpRows not set yet");
                    this.logger.log(1, (() => this.getDisplayText()));
                    const t = this.currRow + 1 - this.nrRollUpRows,
                        e = this.rows.splice(t, 1)[0];
                    e.clear(), this.rows.splice(this.currRow, 0, e), this.logger.log(2, "Rolling up")
                }
                getDisplayText(t) {
                    t = t || !1;
                    const e = [];
                    let i = "",
                        r = -1;
                    for (let i = 0; i < Ks; i++) {
                        const s = this.rows[i].getTextString();
                        s && (r = i + 1, t ? e.push("Row " + r + ": '" + s + "'") : e.push(s.trim()))
                    }
                    return e.length > 0 && (i = t ? "[" + e.join(" | ") + "]" : e.join("\n")), i
                }
                getTextAndFormat() {
                    return this.rows
                }
            }
            class nn {
                constructor(t, e, i) {
                    this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = t, this.outputFilter = e, this.mode = null, this.verbose = 0, this.displayedMemory = new sn(i), this.nonDisplayedMemory = new sn(i), this.lastOutputScreen = new sn(i), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = i
                }
                reset() {
                    this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null
                }
                getHandler() {
                    return this.outputFilter
                }
                setHandler(t) {
                    this.outputFilter = t
                }
                setPAC(t) {
                    this.writeScreen.setPAC(t)
                }
                setBkgData(t) {
                    this.writeScreen.setBkgData(t)
                }
                setMode(t) {
                    t !== this.mode && (this.mode = t, this.logger.log(2, (() => "MODE=" + t)), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = t)
                }
                insertChars(t) {
                    for (let e = 0; e < t.length; e++) this.writeScreen.insertChar(t[e]);
                    const e = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
                    this.logger.log(2, (() => e + ": " + this.writeScreen.getDisplayText(!0))), "MODE_PAINT-ON" !== this.mode && "MODE_ROLL-UP" !== this.mode || (this.logger.log(1, (() => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0))), this.outputDataUpdate())
                }
                ccRCL() {
                    this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON")
                }
                ccBS() {
                    this.logger.log(2, "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate())
                }
                ccAOF() {}
                ccAON() {}
                ccDER() {
                    this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate()
                }
                ccRU(t) {
                    this.logger.log(2, "RU(" + t + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(t)
                }
                ccFON() {
                    this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({
                        flash: !0
                    })
                }
                ccRDC() {
                    this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON")
                }
                ccTR() {
                    this.logger.log(2, "TR"), this.setMode("MODE_TEXT")
                }
                ccRTD() {
                    this.logger.log(2, "RTD"), this.setMode("MODE_TEXT")
                }
                ccEDM() {
                    this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0)
                }
                ccCR() {
                    this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0)
                }
                ccENM() {
                    this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset()
                }
                ccEOC() {
                    if (this.logger.log(2, "EOC - End Of Caption"), "MODE_POP-ON" === this.mode) {
                        const t = this.displayedMemory;
                        this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = t, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, (() => "DISP: " + this.displayedMemory.getDisplayText()))
                    }
                    this.outputDataUpdate(!0)
                }
                ccTO(t) {
                    this.logger.log(2, "TO(" + t + ") - Tab Offset"), this.writeScreen.moveCursor(t)
                }
                ccMIDROW(t) {
                    const e = {
                        flash: !1
                    };
                    if (e.underline = t % 2 == 1, e.italics = t >= 46, e.italics) e.foreground = "white";
                    else {
                        const i = Math.floor(t / 2) - 16,
                            r = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
                        e.foreground = r[i]
                    }
                    this.logger.log(2, "MIDROW: " + JSON.stringify(e)), this.writeScreen.setPen(e)
                }
                outputDataUpdate(t = !1) {
                    const e = this.logger.time;
                    null !== e && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, e, this.lastOutputScreen), t && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : e) : this.cueStartTime = e, this.lastOutputScreen.copy(this.displayedMemory))
                }
                cueSplitAtTime(t) {
                    this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory), this.cueStartTime = t))
                }
            }
            class an {
                constructor(t, e, i) {
                    this.channels = void 0, this.currentChannel = 0, this.cmdHistory = {
                        a: null,
                        b: null
                    }, this.logger = void 0;
                    const r = this.logger = new Js;
                    this.channels = [null, new nn(t, e, r), new nn(t + 1, i, r)]
                }
                getHandler(t) {
                    return this.channels[t].getHandler()
                }
                setHandler(t, e) {
                    this.channels[t].setHandler(e)
                }
                addData(t, e) {
                    this.logger.time = t;
                    for (let t = 0; t < e.length; t += 2) {
                        const i = 127 & e[t],
                            r = 127 & e[t + 1];
                        let s = !1,
                            n = null;
                        if (0 === i && 0 === r) continue;
                        this.logger.log(3, (() => "[" + Zs([e[t], e[t + 1]]) + "] -> (" + Zs([i, r]) + ")"));
                        const a = this.cmdHistory;
                        if (i >= 16 && i <= 31) {
                            if (ln(i, r, a)) {
                                on(null, null, a), this.logger.log(3, (() => "Repeated command (" + Zs([i, r]) + ") is dropped"));
                                continue
                            }
                            on(i, r, this.cmdHistory), s = this.parseCmd(i, r), s || (s = this.parseMidrow(i, r)), s || (s = this.parsePAC(i, r)), s || (s = this.parseBackgroundAttributes(i, r))
                        } else on(null, null, a);
                        if (!s && (n = this.parseChars(i, r), n)) {
                            const t = this.currentChannel;
                            if (t && t > 0) {
                                this.channels[t].insertChars(n)
                            } else this.logger.log(2, "No channel found yet. TEXT-MODE?")
                        }
                        s || n || this.logger.log(2, (() => "Couldn't parse cleaned data " + Zs([i, r]) + " orig: " + Zs([e[t], e[t + 1]])))
                    }
                }
                parseCmd(t, e) {
                    if (!((20 === t || 28 === t || 21 === t || 29 === t) && e >= 32 && e <= 47) && !((23 === t || 31 === t) && e >= 33 && e <= 35)) return !1;
                    const i = 20 === t || 21 === t || 23 === t ? 1 : 2,
                        r = this.channels[i];
                    return 20 === t || 21 === t || 28 === t || 29 === t ? 32 === e ? r.ccRCL() : 33 === e ? r.ccBS() : 34 === e ? r.ccAOF() : 35 === e ? r.ccAON() : 36 === e ? r.ccDER() : 37 === e ? r.ccRU(2) : 38 === e ? r.ccRU(3) : 39 === e ? r.ccRU(4) : 40 === e ? r.ccFON() : 41 === e ? r.ccRDC() : 42 === e ? r.ccTR() : 43 === e ? r.ccRTD() : 44 === e ? r.ccEDM() : 45 === e ? r.ccCR() : 46 === e ? r.ccENM() : 47 === e && r.ccEOC() : r.ccTO(e - 32), this.currentChannel = i, !0
                }
                parseMidrow(t, e) {
                    let i = 0;
                    if ((17 === t || 25 === t) && e >= 32 && e <= 47) {
                        if (i = 17 === t ? 1 : 2, i !== this.currentChannel) return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
                        const r = this.channels[i];
                        return !!r && (r.ccMIDROW(e), this.logger.log(3, (() => "MIDROW (" + Zs([t, e]) + ")")), !0)
                    }
                    return !1
                }
                parsePAC(t, e) {
                    let i;
                    if (!((t >= 17 && t <= 23 || t >= 25 && t <= 31) && e >= 64 && e <= 127) && !((16 === t || 24 === t) && e >= 64 && e <= 95)) return !1;
                    const r = t <= 23 ? 1 : 2;
                    i = e >= 64 && e <= 95 ? 1 === r ? qs[t] : zs[t] : 1 === r ? Ys[t] : Xs[t];
                    const s = this.channels[r];
                    return !!s && (s.setPAC(this.interpretPAC(i, e)), this.currentChannel = r, !0)
                }
                interpretPAC(t, e) {
                    let i;
                    const r = {
                        color: null,
                        italics: !1,
                        indent: null,
                        underline: !1,
                        row: t
                    };
                    return i = e > 95 ? e - 96 : e - 64, r.underline = !(1 & ~i), i <= 13 ? r.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(i / 2)] : i <= 15 ? (r.italics = !0, r.color = "white") : r.indent = 4 * Math.floor((i - 16) / 2), r
                }
                parseChars(t, e) {
                    let i, r = null,
                        s = null;
                    if (t >= 25 ? (i = 2, s = t - 8) : (i = 1, s = t), s >= 17 && s <= 19) {
                        let t;
                        t = 17 === s ? e + 80 : 18 === s ? e + 112 : e + 144, this.logger.log(2, (() => "Special char '" + Ws(t) + "' in channel " + i)), r = [t]
                    } else t >= 32 && t <= 127 && (r = 0 === e ? [t] : [t, e]);
                    return r && this.logger.log(3, (() => "Char codes =  " + Zs(r).join(","))), r
                }
                parseBackgroundAttributes(t, e) {
                    if (!((16 === t || 24 === t) && e >= 32 && e <= 47) && !((23 === t || 31 === t) && e >= 45 && e <= 47)) return !1;
                    let i;
                    const r = {};
                    16 === t || 24 === t ? (i = Math.floor((e - 32) / 2), r.background = Qs[i], e % 2 == 1 && (r.background = r.background + "_semi")) : 45 === e ? r.background = "transparent" : (r.foreground = "black", 47 === e && (r.underline = !0));
                    const s = t <= 23 ? 1 : 2;
                    return this.channels[s].setBkgData(r), !0
                }
                reset() {
                    for (let t = 0; t < Object.keys(this.channels).length; t++) {
                        const e = this.channels[t];
                        e && e.reset()
                    }
                    on(null, null, this.cmdHistory)
                }
                cueSplitAtTime(t) {
                    for (let e = 0; e < this.channels.length; e++) {
                        const i = this.channels[e];
                        i && i.cueSplitAtTime(t)
                    }
                }
            }

            function on(t, e, i) {
                i.a = t, i.b = e
            }

            function ln(t, e, i) {
                return i.a === t && i.b === e
            }
            class un {
                constructor(t, e) {
                    this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = t, this.trackName = e
                }
                dispatchCue() {
                    null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null)
                }
                newCue(t, e, i) {
                    (null === this.startTime || this.startTime > t) && (this.startTime = t), this.endTime = e, this.screen = i, this.timelineController.createCaptionsTrack(this.trackName)
                }
                reset() {
                    this.cueRanges = [], this.startTime = null
                }
            }
            var cn = function() {
                if (null != V && V.VTTCue) return self.VTTCue;
                const t = ["", "lr", "rl"],
                    e = ["start", "middle", "end", "left", "right"];

                function i(t, e) {
                    if ("string" != typeof e) return !1;
                    if (!Array.isArray(t)) return !1;
                    const i = e.toLowerCase();
                    return !!~t.indexOf(i) && i
                }

                function r(t) {
                    return i(e, t)
                }

                function s(t, ...e) {
                    let i = 1;
                    for (; i < arguments.length; i++) {
                        const e = arguments[i];
                        for (const i in e) t[i] = e[i]
                    }
                    return t
                }

                function n(e, n, a) {
                    const o = this,
                        l = {
                            enumerable: !0
                        };
                    o.hasBeenReset = !1;
                    let u = "",
                        c = !1,
                        h = e,
                        d = n,
                        f = a,
                        g = null,
                        m = "",
                        p = !0,
                        v = "auto",
                        y = "start",
                        T = 50,
                        E = "middle",
                        S = 50,
                        b = "middle";
                    Object.defineProperty(o, "id", s({}, l, {
                        get: function() {
                            return u
                        },
                        set: function(t) {
                            u = "" + t
                        }
                    })), Object.defineProperty(o, "pauseOnExit", s({}, l, {
                        get: function() {
                            return c
                        },
                        set: function(t) {
                            c = !!t
                        }
                    })), Object.defineProperty(o, "startTime", s({}, l, {
                        get: function() {
                            return h
                        },
                        set: function(t) {
                            if ("number" != typeof t) throw new TypeError("Start time must be set to a number.");
                            h = t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "endTime", s({}, l, {
                        get: function() {
                            return d
                        },
                        set: function(t) {
                            if ("number" != typeof t) throw new TypeError("End time must be set to a number.");
                            d = t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "text", s({}, l, {
                        get: function() {
                            return f
                        },
                        set: function(t) {
                            f = "" + t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "region", s({}, l, {
                        get: function() {
                            return g
                        },
                        set: function(t) {
                            g = t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "vertical", s({}, l, {
                        get: function() {
                            return m
                        },
                        set: function(e) {
                            const r = function(e) {
                                return i(t, e)
                            }(e);
                            if (!1 === r) throw new SyntaxError("An invalid or illegal string was specified.");
                            m = r, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "snapToLines", s({}, l, {
                        get: function() {
                            return p
                        },
                        set: function(t) {
                            p = !!t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "line", s({}, l, {
                        get: function() {
                            return v
                        },
                        set: function(t) {
                            if ("number" != typeof t && "auto" !== t) throw new SyntaxError("An invalid number or illegal string was specified.");
                            v = t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "lineAlign", s({}, l, {
                        get: function() {
                            return y
                        },
                        set: function(t) {
                            const e = r(t);
                            if (!e) throw new SyntaxError("An invalid or illegal string was specified.");
                            y = e, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "position", s({}, l, {
                        get: function() {
                            return T
                        },
                        set: function(t) {
                            if (t < 0 || t > 100) throw new Error("Position must be between 0 and 100.");
                            T = t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "positionAlign", s({}, l, {
                        get: function() {
                            return E
                        },
                        set: function(t) {
                            const e = r(t);
                            if (!e) throw new SyntaxError("An invalid or illegal string was specified.");
                            E = e, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "size", s({}, l, {
                        get: function() {
                            return S
                        },
                        set: function(t) {
                            if (t < 0 || t > 100) throw new Error("Size must be between 0 and 100.");
                            S = t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "align", s({}, l, {
                        get: function() {
                            return b
                        },
                        set: function(t) {
                            const e = r(t);
                            if (!e) throw new SyntaxError("An invalid or illegal string was specified.");
                            b = e, this.hasBeenReset = !0
                        }
                    })), o.displayState = void 0
                }
                return n.prototype.getCueAsHTML = function() {
                    return self.WebVTT.convertCueToDOMTree(self, this.text)
                }, n
            }();
            class hn {
                decode(t, e) {
                    if (!t) return "";
                    if ("string" != typeof t) throw new Error("Error - expected string data.");
                    return decodeURIComponent(encodeURIComponent(t))
                }
            }

            function dn(t) {
                function e(t, e, i, r) {
                    return 3600 * (0 | t) + 60 * (0 | e) + (0 | i) + parseFloat(r || 0)
                }
                const i = t.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
                return i ? parseFloat(i[2]) > 59 ? e(i[2], i[3], 0, i[4]) : e(i[1], i[2], i[3], i[4]) : null
            }
            class fn {
                constructor() {
                    this.values = Object.create(null)
                }
                set(t, e) {
                    this.get(t) || "" === e || (this.values[t] = e)
                }
                get(t, e, i) {
                    return i ? this.has(t) ? this.values[t] : e[i] : this.has(t) ? this.values[t] : e
                }
                has(t) {
                    return t in this.values
                }
                alt(t, e, i) {
                    for (let r = 0; r < i.length; ++r)
                        if (e === i[r]) {
                            this.set(t, e);
                            break
                        }
                }
                integer(t, e) {
                    /^-?\d+$/.test(e) && this.set(t, parseInt(e, 10))
                }
                percent(t, e) {
                    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(e)) {
                        const i = parseFloat(e);
                        if (i >= 0 && i <= 100) return this.set(t, i), !0
                    }
                    return !1
                }
            }

            function gn(t, e, i, r) {
                const s = r ? t.split(r) : [t];
                for (const t in s) {
                    if ("string" != typeof s[t]) continue;
                    const r = s[t].split(i);
                    if (2 !== r.length) continue;
                    e(r[0], r[1])
                }
            }
            const mn = new cn(0, 0, ""),
                pn = "middle" === mn.align ? "middle" : "center";

            function vn(t, e, i) {
                const r = t;

                function s() {
                    const e = dn(t);
                    if (null === e) throw new Error("Malformed timestamp: " + r);
                    return t = t.replace(/^[^\sa-zA-Z-]+/, ""), e
                }

                function n() {
                    t = t.replace(/^\s+/, "")
                }
                if (n(), e.startTime = s(), n(), "--\x3e" !== t.slice(0, 3)) throw new Error("Malformed time stamp (time stamps must be separated by '--\x3e'): " + r);
                t = t.slice(3), n(), e.endTime = s(), n(),
                    function(t, e) {
                        const r = new fn;
                        gn(t, (function(t, e) {
                            let s;
                            switch (t) {
                                case "region":
                                    for (let s = i.length - 1; s >= 0; s--)
                                        if (i[s].id === e) {
                                            r.set(t, i[s].region);
                                            break
                                        }
                                    break;
                                case "vertical":
                                    r.alt(t, e, ["rl", "lr"]);
                                    break;
                                case "line":
                                    s = e.split(","), r.integer(t, s[0]), r.percent(t, s[0]) && r.set("snapToLines", !1), r.alt(t, s[0], ["auto"]), 2 === s.length && r.alt("lineAlign", s[1], ["start", pn, "end"]);
                                    break;
                                case "position":
                                    s = e.split(","), r.percent(t, s[0]), 2 === s.length && r.alt("positionAlign", s[1], ["start", pn, "end", "line-left", "line-right", "auto"]);
                                    break;
                                case "size":
                                    r.percent(t, e);
                                    break;
                                case "align":
                                    r.alt(t, e, ["start", pn, "end", "left", "right"])
                            }
                        }), /:/, /\s/), e.region = r.get("region", null), e.vertical = r.get("vertical", "");
                        let s = r.get("line", "auto");
                        "auto" === s && -1 === mn.line && (s = -1), e.line = s, e.lineAlign = r.get("lineAlign", "start"), e.snapToLines = r.get("snapToLines", !0), e.size = r.get("size", 100), e.align = r.get("align", pn);
                        let n = r.get("position", "auto");
                        "auto" === n && 50 === mn.position && (n = "start" === e.align || "left" === e.align ? 0 : "end" === e.align || "right" === e.align ? 100 : 50), e.position = n
                    }(t, e)
            }

            function yn(t) {
                return t.replace(/<br(?: \/)?>/gi, "\n")
            }
            class Tn {
                constructor() {
                    this.state = "INITIAL", this.buffer = "", this.decoder = new hn, this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0
                }
                parse(t) {
                    const e = this;

                    function i() {
                        let t = e.buffer,
                            i = 0;
                        for (t = yn(t); i < t.length && "\r" !== t[i] && "\n" !== t[i];) ++i;
                        const r = t.slice(0, i);
                        return "\r" === t[i] && ++i, "\n" === t[i] && ++i, e.buffer = t.slice(i), r
                    }
                    t && (e.buffer += e.decoder.decode(t, {
                        stream: !0
                    }));
                    try {
                        let t = "";
                        if ("INITIAL" === e.state) {
                            if (!/\r\n|\n/.test(e.buffer)) return this;
                            t = i();
                            const r = t.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
                            if (null == r || !r[0]) throw new Error("Malformed WebVTT signature.");
                            e.state = "HEADER"
                        }
                        let r = !1;
                        for (; e.buffer;) {
                            if (!/\r\n|\n/.test(e.buffer)) return this;
                            switch (r ? r = !1 : t = i(), e.state) {
                                case "HEADER":
                                    /:/.test(t) ? gn(t, (function(t, e) {}), /:/) : t || (e.state = "ID");
                                    continue;
                                case "NOTE":
                                    t || (e.state = "ID");
                                    continue;
                                case "ID":
                                    if (/^NOTE($|[ \t])/.test(t)) {
                                        e.state = "NOTE";
                                        break
                                    }
                                    if (!t) continue;
                                    if (e.cue = new cn(0, 0, ""), e.state = "CUE", -1 === t.indexOf("--\x3e")) {
                                        e.cue.id = t;
                                        continue
                                    }
                                case "CUE":
                                    if (!e.cue) {
                                        e.state = "BADCUE";
                                        continue
                                    }
                                    try {
                                        vn(t, e.cue, e.regionList)
                                    } catch (t) {
                                        e.cue = null, e.state = "BADCUE";
                                        continue
                                    }
                                    e.state = "CUETEXT";
                                    continue;
                                case "CUETEXT":
                                    {
                                        const i = -1 !== t.indexOf("--\x3e");
                                        if (!t || i && (r = !0)) {
                                            e.oncue && e.cue && e.oncue(e.cue), e.cue = null, e.state = "ID";
                                            continue
                                        }
                                        if (null === e.cue) continue;e.cue.text && (e.cue.text += "\n"),
                                        e.cue.text += t
                                    }
                                    continue;
                                case "BADCUE":
                                    t || (e.state = "ID")
                            }
                        }
                    } catch (t) {
                        "CUETEXT" === e.state && e.cue && e.oncue && e.oncue(e.cue), e.cue = null, e.state = "INITIAL" === e.state ? "BADWEBVTT" : "BADCUE"
                    }
                    return this
                }
                flush() {
                    const t = this;
                    try {
                        if ((t.cue || "HEADER" === t.state) && (t.buffer += "\n\n", t.parse()), "INITIAL" === t.state || "BADWEBVTT" === t.state) throw new Error("Malformed WebVTT signature.")
                    } catch (e) {
                        t.onparsingerror && t.onparsingerror(e)
                    }
                    return t.onflush && t.onflush(), this
                }
            }
            const En = /\r\n|\n\r|\n|\r/g,
                Sn = function(t, e, i = 0) {
                    return t.slice(i, i + e.length) === e
                },
                bn = function(t) {
                    let e = 5381,
                        i = t.length;
                    for (; i;) e = 33 * e ^ t.charCodeAt(--i);
                    return (e >>> 0).toString()
                };

            function An(t, e, i) {
                return bn(t.toString()) + bn(e.toString()) + bn(i)
            }

            function Ln(t, e, i, r, s, n, a) {
                const o = new Tn,
                    l = Et(new Uint8Array(t)).trim().replace(En, "\n").split("\n"),
                    u = [],
                    c = e ? function(t, e = 1) {
                        return ps(t, ms, 1 / e)
                    }(e.baseTime, e.timescale) : 0;
                let h, d = "00:00.000",
                    f = 0,
                    g = 0,
                    m = !0;
                o.oncue = function(t) {
                    const n = i[r];
                    let a = i.ccOffset;
                    const o = (f - c) / 9e4;
                    if (null != n && n.new && (void 0 !== g ? a = i.ccOffset = n.start : function(t, e, i) {
                            let r = t[e],
                                s = t[r.prevCC];
                            if (!s || !s.new && r.new) return t.ccOffset = t.presentationOffset = r.start, void(r.new = !1);
                            for (; null != (n = s) && n.new;) {
                                var n;
                                t.ccOffset += r.start - s.start, r.new = !1, r = s, s = t[r.prevCC]
                            }
                            t.presentationOffset = i
                        }(i, r, o)), o) {
                        if (!e) return void(h = new Error("Missing initPTS for VTT MPEGTS"));
                        a = o - i.presentationOffset
                    }
                    const l = t.endTime - t.startTime,
                        d = bs(9e4 * (t.startTime + a - g), 9e4 * s) / 9e4;
                    t.startTime = Math.max(d, 0), t.endTime = Math.max(d + l, 0);
                    const m = t.text.trim();
                    t.text = decodeURIComponent(encodeURIComponent(m)), t.id || (t.id = An(t.startTime, t.endTime, m)), t.endTime > 0 && u.push(t)
                }, o.onparsingerror = function(t) {
                    h = t
                }, o.onflush = function() {
                    h ? a(h) : n(u)
                }, l.forEach((t => {
                    if (m) {
                        if (Sn(t, "X-TIMESTAMP-MAP=")) {
                            m = !1, t.slice(16).split(",").forEach((t => {
                                Sn(t, "LOCAL:") ? d = t.slice(6) : Sn(t, "MPEGTS:") && (f = parseInt(t.slice(7)))
                            }));
                            try {
                                g = function(t) {
                                    let e = parseInt(t.slice(-3));
                                    const i = parseInt(t.slice(-6, -4)),
                                        r = parseInt(t.slice(-9, -7)),
                                        s = t.length > 9 ? parseInt(t.substring(0, t.indexOf(":"))) : 0;
                                    if (!(p(e) && p(i) && p(r) && p(s))) throw Error(`Malformed X-TIMESTAMP-MAP: Local:${t}`);
                                    return e += 1e3 * i, e += 6e4 * r, e += 36e5 * s, e
                                }(d) / 1e3
                            } catch (t) {
                                h = t
                            }
                            return
                        }
                        "" === t && (m = !1)
                    }
                    o.parse(t + "\n")
                })), o.flush()
            }
            const kn = "stpp.ttml.im1t",
                Rn = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/,
                wn = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/,
                _n = {
                    left: "start",
                    center: "center",
                    right: "end",
                    start: "start",
                    end: "end"
                };

            function Dn(t, e, i, r) {
                const s = xt(new Uint8Array(t), ["mdat"]);
                if (0 === s.length) return void r(new Error("Could not parse IMSC1 mdat"));
                const n = s.map((t => Et(t))),
                    a = function(t, e, i = 1, r = !1) {
                        return ps(t, e, 1 / i, r)
                    }(e.baseTime, 1, e.timescale);
                try {
                    n.forEach((t => i(function(t, e) {
                        const i = (new DOMParser).parseFromString(t, "text/xml"),
                            r = i.getElementsByTagName("tt")[0];
                        if (!r) throw new Error("Invalid ttml");
                        const s = {
                                frameRate: 30,
                                subFrameRate: 1,
                                frameRateMultiplier: 0,
                                tickRate: 0
                            },
                            n = Object.keys(s).reduce(((t, e) => (t[e] = r.getAttribute(`ttp:${e}`) || s[e], t)), {}),
                            a = "preserve" !== r.getAttribute("xml:space"),
                            o = In(Cn(r, "styling", "style")),
                            l = In(Cn(r, "layout", "region")),
                            u = Cn(r, "body", "[begin]");
                        return [].map.call(u, (t => {
                            const i = Pn(t, a);
                            if (!i || !t.hasAttribute("begin")) return null;
                            const r = On(t.getAttribute("begin"), n),
                                s = On(t.getAttribute("dur"), n);
                            let u = On(t.getAttribute("end"), n);
                            if (null === r) throw Mn(t);
                            if (null === u) {
                                if (null === s) throw Mn(t);
                                u = r + s
                            }
                            const c = new cn(r - e, u - e, i);
                            c.id = An(c.startTime, c.endTime, c.text);
                            const h = function(t, e, i) {
                                    const r = "http://www.w3.org/ns/ttml#styling";
                                    let s = null;
                                    const n = ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"],
                                        a = null != t && t.hasAttribute("style") ? t.getAttribute("style") : null;
                                    a && i.hasOwnProperty(a) && (s = i[a]);
                                    return n.reduce(((i, n) => {
                                        const a = xn(e, r, n) || xn(t, r, n) || xn(s, r, n);
                                        return a && (i[n] = a), i
                                    }), {})
                                }(l[t.getAttribute("region")], o[t.getAttribute("style")], o),
                                {
                                    textAlign: d
                                } = h;
                            if (d) {
                                const t = _n[d];
                                t && (c.lineAlign = t), c.align = d
                            }
                            return m(c, h), c
                        })).filter((t => null !== t))
                    }(t, a))))
                } catch (t) {
                    r(t)
                }
            }

            function Cn(t, e, i) {
                const r = t.getElementsByTagName(e)[0];
                return r ? [].slice.call(r.querySelectorAll(i)) : []
            }

            function In(t) {
                return t.reduce(((t, e) => {
                    const i = e.getAttribute("xml:id");
                    return i && (t[i] = e), t
                }), {})
            }

            function Pn(t, e) {
                return [].slice.call(t.childNodes).reduce(((t, i, r) => {
                    var s;
                    return "br" === i.nodeName && r ? t + "\n" : null != (s = i.childNodes) && s.length ? Pn(i, e) : e ? t + i.textContent.trim().replace(/\s+/g, " ") : t + i.textContent
                }), "")
            }

            function xn(t, e, i) {
                return t && t.hasAttributeNS(e, i) ? t.getAttributeNS(e, i) : null
            }

            function Mn(t) {
                return new Error(`Could not parse ttml timestamp ${t}`)
            }

            function On(t, e) {
                if (!t) return null;
                let i = dn(t);
                return null === i && (Rn.test(t) ? i = function(t, e) {
                    const i = Rn.exec(t),
                        r = (0 | i[4]) + (0 | i[5]) / e.subFrameRate;
                    return 3600 * (0 | i[1]) + 60 * (0 | i[2]) + (0 | i[3]) + r / e.frameRate
                }(t, e) : wn.test(t) && (i = function(t, e) {
                    const i = wn.exec(t),
                        r = Number(i[1]);
                    switch (i[2]) {
                        case "h":
                            return 3600 * r;
                        case "m":
                            return 60 * r;
                        case "ms":
                            return 1e3 * r;
                        case "f":
                            return r / e.frameRate;
                        case "t":
                            return r / e.tickRate
                    }
                    return r
                }(t, e))), i
            }

            function Fn(t) {
                return t.characteristics && /transcribes-spoken-dialog/gi.test(t.characteristics) && /describes-music-and-sound/gi.test(t.characteristics) ? "captions" : "subtitles"
            }

            function Nn(t, e) {
                return !!t && t.kind === Fn(e) && Bs(e, t)
            }
            class Bn {
                constructor(t) {
                    this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = t, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners()
                }
                setStreamController(t) {
                    this.streamController = t
                }
                destroy() {
                    this.hls && this.unregisterListener(), this.timer && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null
                }
                registerListeners() {
                    const {
                        hls: t
                    } = this;
                    t.on(T.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), t.on(T.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(T.MANIFEST_PARSED, this.onManifestParsed, this), t.on(T.LEVELS_UPDATED, this.onLevelsUpdated, this), t.on(T.BUFFER_CODECS, this.onBufferCodecs, this), t.on(T.MEDIA_DETACHING, this.onMediaDetaching, this)
                }
                unregisterListener() {
                    const {
                        hls: t
                    } = this;
                    t.off(T.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), t.off(T.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(T.MANIFEST_PARSED, this.onManifestParsed, this), t.off(T.LEVELS_UPDATED, this.onLevelsUpdated, this), t.off(T.BUFFER_CODECS, this.onBufferCodecs, this), t.off(T.MEDIA_DETACHING, this.onMediaDetaching, this)
                }
                onFpsDropLevelCapping(t, e) {
                    const i = this.hls.levels[e.droppedLevel];
                    this.isLevelAllowed(i) && this.restrictedLevels.push({
                        bitrate: i.bitrate,
                        height: i.height,
                        width: i.width
                    })
                }
                onMediaAttaching(t, e) {
                    this.media = e.media instanceof HTMLVideoElement ? e.media : null, this.clientRect = null, this.timer && this.hls.levels.length && this.detectPlayerSize()
                }
                onManifestParsed(t, e) {
                    const i = this.hls;
                    this.restrictedLevels = [], this.firstLevel = e.firstLevel, i.config.capLevelToPlayerSize && e.video && this.startCapping()
                }
                onLevelsUpdated(t, e) {
                    this.timer && p(this.autoLevelCapping) && this.detectPlayerSize()
                }
                onBufferCodecs(t, e) {
                    this.hls.config.capLevelToPlayerSize && e.video && this.startCapping()
                }
                onMediaDetaching() {
                    this.stopCapping()
                }
                detectPlayerSize() {
                    if (this.media) {
                        if (this.mediaHeight <= 0 || this.mediaWidth <= 0) return void(this.clientRect = null);
                        const t = this.hls.levels;
                        if (t.length) {
                            const e = this.hls,
                                i = this.getMaxLevel(t.length - 1);
                            i !== this.autoLevelCapping && R.log(`Setting autoLevelCapping to ${i}: ${t[i].height}p@${t[i].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`), e.autoLevelCapping = i, e.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = e.autoLevelCapping
                        }
                    }
                }
                getMaxLevel(t) {
                    const e = this.hls.levels;
                    if (!e.length) return -1;
                    const i = e.filter(((e, i) => this.isLevelAllowed(e) && i <= t));
                    return this.clientRect = null, Bn.getMaxLevelByMediaSize(i, this.mediaWidth, this.mediaHeight)
                }
                startCapping() {
                    this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize())
                }
                stopCapping() {
                    this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0)
                }
                getDimensions() {
                    if (this.clientRect) return this.clientRect;
                    const t = this.media,
                        e = {
                            width: 0,
                            height: 0
                        };
                    if (t) {
                        const i = t.getBoundingClientRect();
                        e.width = i.width, e.height = i.height, e.width || e.height || (e.width = i.right - i.left || t.width || 0, e.height = i.bottom - i.top || t.height || 0)
                    }
                    return this.clientRect = e, e
                }
                get mediaWidth() {
                    return this.getDimensions().width * this.contentScaleFactor
                }
                get mediaHeight() {
                    return this.getDimensions().height * this.contentScaleFactor
                }
                get contentScaleFactor() {
                    let t = 1;
                    if (!this.hls.config.ignoreDevicePixelRatio) try {
                        t = self.devicePixelRatio
                    } catch (t) {}
                    return t
                }
                isLevelAllowed(t) {
                    return !this.restrictedLevels.some((e => t.bitrate === e.bitrate && t.width === e.width && t.height === e.height))
                }
                static getMaxLevelByMediaSize(t, e, i) {
                    if (null == t || !t.length) return -1;
                    let r = t.length - 1;
                    const s = Math.max(e, i);
                    for (let e = 0; e < t.length; e += 1) {
                        const i = t[e];
                        if ((i.width >= s || i.height >= s) && (n = i, !(a = t[e + 1]) || n.width !== a.width || n.height !== a.height)) {
                            r = e;
                            break
                        }
                    }
                    var n, a;
                    return r
                }
            }
            const Un = "[eme]";
            class $n {
                constructor(t) {
                    this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.setMediaKeysQueue = $n.CDMCleanupPromise ? [$n.CDMCleanupPromise] : [], this.onMediaEncrypted = this._onMediaEncrypted.bind(this), this.onWaitingForKey = this._onWaitingForKey.bind(this), this.debug = R.debug.bind(R, Un), this.log = R.log.bind(R, Un), this.warn = R.warn.bind(R, Un), this.error = R.error.bind(R, Un), this.hls = t, this.config = t.config, this.registerListeners()
                }
                destroy() {
                    this.unregisterListeners(), this.onMediaDetached();
                    const t = this.config;
                    t.requestMediaKeySystemAccessFunc = null, t.licenseXhrSetup = t.licenseResponseCallback = void 0, t.drmSystems = t.drmSystemOptions = {}, this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null, this.config = null
                }
                registerListeners() {
                    this.hls.on(T.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(T.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(T.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(T.MANIFEST_LOADED, this.onManifestLoaded, this)
                }
                unregisterListeners() {
                    this.hls.off(T.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(T.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(T.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(T.MANIFEST_LOADED, this.onManifestLoaded, this)
                }
                getLicenseServerUrl(t) {
                    const {
                        drmSystems: e,
                        widevineLicenseUrl: i
                    } = this.config, r = e[t];
                    if (r) return r.licenseUrl;
                    if (t === W.WIDEVINE && i) return i;
                    throw new Error(`no license server URL configured for key-system "${t}"`)
                }
                getServerCertificateUrl(t) {
                    const {
                        drmSystems: e
                    } = this.config, i = e[t];
                    if (i) return i.serverCertificateUrl;
                    this.log(`No Server Certificate in config.drmSystems["${t}"]`)
                }
                attemptKeySystemAccess(t) {
                    const e = this.hls.levels,
                        i = (t, e, i) => !!t && i.indexOf(t) === e,
                        r = e.map((t => t.audioCodec)).filter(i),
                        s = e.map((t => t.videoCodec)).filter(i);
                    return r.length + s.length === 0 && s.push("avc1.42e01e"), new Promise(((e, i) => {
                        const n = t => {
                            const a = t.shift();
                            this.getMediaKeysPromise(a, r, s).then((t => e({
                                keySystem: a,
                                mediaKeys: t
                            }))).catch((e => {
                                t.length ? n(t) : i(e instanceof Gn ? e : new Gn({
                                    type: E.KEY_SYSTEM_ERROR,
                                    details: S.KEY_SYSTEM_NO_ACCESS,
                                    error: e,
                                    fatal: !0
                                }, e.message))
                            }))
                        };
                        n(t)
                    }))
                }
                requestMediaKeySystemAccess(t, e) {
                    const {
                        requestMediaKeySystemAccessFunc: i
                    } = this.config;
                    if ("function" != typeof i) {
                        let t = `Configured requestMediaKeySystemAccess is not a function ${i}`;
                        return null === rt && "http:" === self.location.protocol && (t = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(t))
                    }
                    return i(t, e)
                }
                getMediaKeysPromise(t, e, i) {
                    const r = function(t, e, i, r) {
                            let s;
                            switch (t) {
                                case W.FAIRPLAY:
                                    s = ["cenc", "sinf"];
                                    break;
                                case W.WIDEVINE:
                                case W.PLAYREADY:
                                    s = ["cenc"];
                                    break;
                                case W.CLEARKEY:
                                    s = ["cenc", "keyids"];
                                    break;
                                default:
                                    throw new Error(`Unknown key-system: ${t}`)
                            }
                            return function(t, e, i, r) {
                                return [{
                                    initDataTypes: t,
                                    persistentState: r.persistentState || "optional",
                                    distinctiveIdentifier: r.distinctiveIdentifier || "optional",
                                    sessionTypes: r.sessionTypes || [r.sessionType || "temporary"],
                                    audioCapabilities: e.map((t => ({
                                        contentType: `audio/mp4; codecs="${t}"`,
                                        robustness: r.audioRobustness || "",
                                        encryptionScheme: r.audioEncryptionScheme || null
                                    }))),
                                    videoCapabilities: i.map((t => ({
                                        contentType: `video/mp4; codecs="${t}"`,
                                        robustness: r.videoRobustness || "",
                                        encryptionScheme: r.videoEncryptionScheme || null
                                    })))
                                }]
                            }(s, e, i, r)
                        }(t, e, i, this.config.drmSystemOptions),
                        s = this.keySystemAccessPromises[t];
                    let n = null == s ? void 0 : s.keySystemAccess;
                    if (!n) {
                        this.log(`Requesting encrypted media "${t}" key-system access with config: ${JSON.stringify(r)}`), n = this.requestMediaKeySystemAccess(t, r);
                        const e = this.keySystemAccessPromises[t] = {
                            keySystemAccess: n
                        };
                        return n.catch((e => {
                            this.log(`Failed to obtain access to key-system "${t}": ${e}`)
                        })), n.then((i => {
                            this.log(`Access for key-system "${i.keySystem}" obtained`);
                            const r = this.fetchServerCertificate(t);
                            return this.log(`Create media-keys for "${t}"`), e.mediaKeys = i.createMediaKeys().then((e => (this.log(`Media-keys created for "${t}"`), r.then((i => i ? this.setMediaKeysServerCertificate(e, t, i) : e))))), e.mediaKeys.catch((e => {
                                this.error(`Failed to create media-keys for "${t}"}: ${e}`)
                            })), e.mediaKeys
                        }))
                    }
                    return n.then((() => s.mediaKeys))
                }
                createMediaKeySessionContext({
                    decryptdata: t,
                    keySystem: e,
                    mediaKeys: i
                }) {
                    this.log(`Creating key-system session "${e}" keyId: ${At.hexDump(t.keyId||[])}`);
                    const r = i.createSession(),
                        s = {
                            decryptdata: t,
                            keySystem: e,
                            mediaKeys: i,
                            mediaKeysSession: r,
                            keyStatus: "status-pending"
                        };
                    return this.mediaKeySessions.push(s), s
                }
                renewKeySession(t) {
                    const e = t.decryptdata;
                    if (e.pssh) {
                        const i = this.createMediaKeySessionContext(t),
                            r = this.getKeyIdString(e),
                            s = "cenc";
                        this.keyIdToKeySessionPromise[r] = this.generateRequestWithPreferredKeySession(i, s, e.pssh, "expired")
                    } else this.warn("Could not renew expired session. Missing pssh initData.");
                    this.removeSession(t)
                }
                getKeyIdString(t) {
                    if (!t) throw new Error("Could not read keyId of undefined decryptdata");
                    if (null === t.keyId) throw new Error("keyId is null");
                    return At.hexDump(t.keyId)
                }
                updateKeySession(t, e) {
                    var i;
                    const r = t.mediaKeysSession;
                    return this.log(`Updating key-session "${r.sessionId}" for keyID ${At.hexDump((null==(i=t.decryptdata)?void 0:i.keyId)||[])}\n      } (data length: ${e?e.byteLength:e})`), r.update(e)
                }
                selectKeySystemFormat(t) {
                    const e = Object.keys(t.levelkeys || {});
                    return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${t.sn} ${t.type}: ${t.level}) key formats ${e.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(e)), this.keyFormatPromise
                }
                getKeyFormatPromise(t) {
                    return new Promise(((e, i) => {
                        const r = it(this.config),
                            s = t.map(z).filter((t => !!t && -1 !== r.indexOf(t)));
                        return this.getKeySystemSelectionPromise(s).then((({
                            keySystem: t
                        }) => {
                            const r = et(t);
                            r ? e(r) : i(new Error(`Unable to find format for key-system "${t}"`))
                        })).catch(i)
                    }))
                }
                loadKey(t) {
                    const e = t.keyInfo.decryptdata,
                        i = this.getKeyIdString(e),
                        r = `(keyId: ${i} format: "${e.keyFormat}" method: ${e.method} uri: ${e.uri})`;
                    this.log(`Starting session for key ${r}`);
                    let s = this.keyIdToKeySessionPromise[i];
                    return s || (s = this.keyIdToKeySessionPromise[i] = this.getKeySystemForKeyPromise(e).then((({
                        keySystem: i,
                        mediaKeys: s
                    }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${t.frag.sn} ${t.frag.type}: ${t.frag.level} using key ${r}`), this.attemptSetMediaKeys(i, s).then((() => {
                        this.throwIfDestroyed();
                        const t = this.createMediaKeySessionContext({
                            keySystem: i,
                            mediaKeys: s,
                            decryptdata: e
                        });
                        return this.generateRequestWithPreferredKeySession(t, "cenc", e.pssh, "playlist-key")
                    }))))), s.catch((t => this.handleError(t)))), s
                }
                throwIfDestroyed(t = "Invalid state") {
                    if (!this.hls) throw new Error("invalid state")
                }
                handleError(t) {
                    this.hls && (this.error(t.message), t instanceof Gn ? this.hls.trigger(T.ERROR, t.data) : this.hls.trigger(T.ERROR, {
                        type: E.KEY_SYSTEM_ERROR,
                        details: S.KEY_SYSTEM_NO_KEYS,
                        error: t,
                        fatal: !0
                    }))
                }
                getKeySystemForKeyPromise(t) {
                    const e = this.getKeyIdString(t),
                        i = this.keyIdToKeySessionPromise[e];
                    if (!i) {
                        const e = z(t.keyFormat),
                            i = e ? [e] : it(this.config);
                        return this.attemptKeySystemAccess(i)
                    }
                    return i
                }
                getKeySystemSelectionPromise(t) {
                    if (t.length || (t = it(this.config)), 0 === t.length) throw new Gn({
                        type: E.KEY_SYSTEM_ERROR,
                        details: S.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
                        fatal: !0
                    }, `Missing key-system license configuration options ${JSON.stringify({drmSystems:this.config.drmSystems})}`);
                    return this.attemptKeySystemAccess(t)
                }
                _onMediaEncrypted(t) {
                    const {
                        initDataType: e,
                        initData: i
                    } = t, r = `"${t.type}" event: init data type: "${e}"`;
                    if (this.debug(r), null === i) return;
                    let s, n;
                    if ("sinf" === e && this.config.drmSystems[W.FAIRPLAY]) {
                        const t = wt(new Uint8Array(i));
                        try {
                            const e = $(JSON.parse(t).sinf),
                                i = $t(new Uint8Array(e));
                            if (!i) throw new Error("'schm' box missing or not cbcs/cenc with schi > tenc");
                            s = i.subarray(8, 24), n = W.FAIRPLAY
                        } catch (t) {
                            return void this.warn(`${r} Failed to parse sinf: ${t}`)
                        }
                    } else {
                        const t = function(t) {
                                const e = [];
                                if (t instanceof ArrayBuffer) {
                                    const i = t.byteLength;
                                    let r = 0;
                                    for (; r + 32 < i;) {
                                        const i = Yt(new DataView(t, r));
                                        e.push(i), r += i.size
                                    }
                                }
                                return e
                            }(i),
                            e = t.filter((t => t.systemId === Z))[0];
                        if (!e) return void(0 === t.length || t.some((t => !t.systemId)) ? this.warn(`${r} contains incomplete or invalid pssh data`) : this.log(`ignoring ${r} for ${t.map((t=>tt(t.systemId))).join(",")} pssh data in favor of playlist keys`));
                        if (n = tt(e.systemId), 0 === e.version && e.data) {
                            const t = e.data.length - 22;
                            s = e.data.subarray(t, t + 16)
                        }
                    }
                    if (!n || !s) return;
                    const a = At.hexDump(s),
                        {
                            keyIdToKeySessionPromise: o,
                            mediaKeySessions: l
                        } = this;
                    let u = o[a];
                    for (let t = 0; t < l.length; t++) {
                        const r = l[t],
                            n = r.decryptdata;
                        if (!n.keyId) continue;
                        const c = At.hexDump(n.keyId);
                        if (a === c || -1 !== n.uri.replace(/-/g, "").indexOf(a)) {
                            if (u = o[c], n.pssh) break;
                            delete o[c], n.pssh = new Uint8Array(i), n.keyId = s, u = o[a] = u.then((() => this.generateRequestWithPreferredKeySession(r, e, i, "encrypted-event-key-match")));
                            break
                        }
                    }
                    u || (u = o[a] = this.getKeySystemSelectionPromise([n]).then((({
                        keySystem: t,
                        mediaKeys: r
                    }) => {
                        var n;
                        this.throwIfDestroyed();
                        const o = new Xt("ISO-23001-7", a, null != (n = et(t)) ? n : "");
                        return o.pssh = new Uint8Array(i), o.keyId = s, this.attemptSetMediaKeys(t, r).then((() => {
                            this.throwIfDestroyed();
                            const s = this.createMediaKeySessionContext({
                                decryptdata: o,
                                keySystem: t,
                                mediaKeys: r
                            });
                            return this.generateRequestWithPreferredKeySession(s, e, i, "encrypted-event-no-match")
                        }))
                    }))), u.catch((t => this.handleError(t)))
                }
                _onWaitingForKey(t) {
                    this.log(`"${t.type}" event`)
                }
                attemptSetMediaKeys(t, e) {
                    const i = this.setMediaKeysQueue.slice();
                    this.log(`Setting media-keys for "${t}"`);
                    const r = Promise.all(i).then((() => {
                        if (!this.media) throw new Error("Attempted to set mediaKeys without media element attached");
                        return this.media.setMediaKeys(e)
                    }));
                    return this.setMediaKeysQueue.push(r), r.then((() => {
                        this.log(`Media-keys set for "${t}"`), i.push(r), this.setMediaKeysQueue = this.setMediaKeysQueue.filter((t => -1 === i.indexOf(t)))
                    }))
                }
                generateRequestWithPreferredKeySession(t, e, i, r) {
                    var s, n;
                    const a = null == (s = this.config.drmSystems) || null == (n = s[t.keySystem]) ? void 0 : n.generateRequest;
                    if (a) try {
                        const r = a.call(this.hls, e, i, t);
                        if (!r) throw new Error("Invalid response from configured generateRequest filter");
                        e = r.initDataType, i = t.decryptdata.pssh = r.initData ? new Uint8Array(r.initData) : null
                    } catch (t) {
                        var o;
                        if (this.warn(t.message), null != (o = this.hls) && o.config.debug) throw t
                    }
                    if (null === i) return this.log(`Skipping key-session request for "${r}" (no initData)`), Promise.resolve(t);
                    const l = this.getKeyIdString(t.decryptdata);
                    this.log(`Generating key-session request for "${r}": ${l} (init data type: ${e} length: ${i?i.byteLength:null})`);
                    const u = new Ms,
                        c = t._onmessage = e => {
                            const i = t.mediaKeysSession;
                            if (!i) return void u.emit("error", new Error("invalid state"));
                            const {
                                messageType: r,
                                message: s
                            } = e;
                            this.log(`"${r}" message event for session "${i.sessionId}" message size: ${s.byteLength}`), "license-request" === r || "license-renewal" === r ? this.renewLicense(t, s).catch((t => {
                                this.handleError(t), u.emit("error", t)
                            })) : "license-release" === r ? t.keySystem === W.FAIRPLAY && (this.updateKeySession(t, H("acknowledged")), this.removeSession(t)) : this.warn(`unhandled media key message type "${r}"`)
                        },
                        h = t._onkeystatuseschange = e => {
                            if (!t.mediaKeysSession) return void u.emit("error", new Error("invalid state"));
                            this.onKeyStatusChange(t);
                            const i = t.keyStatus;
                            u.emit("keyStatus", i), "expired" === i && (this.warn(`${t.keySystem} expired for key ${l}`), this.renewKeySession(t))
                        };
                    t.mediaKeysSession.addEventListener("message", c), t.mediaKeysSession.addEventListener("keystatuseschange", h);
                    const d = new Promise(((t, e) => {
                        u.on("error", e), u.on("keyStatus", (i => {
                            i.startsWith("usable") ? t() : "output-restricted" === i ? e(new Gn({
                                type: E.KEY_SYSTEM_ERROR,
                                details: S.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
                                fatal: !1
                            }, "HDCP level output restricted")) : "internal-error" === i ? e(new Gn({
                                type: E.KEY_SYSTEM_ERROR,
                                details: S.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
                                fatal: !0
                            }, `key status changed to "${i}"`)) : "expired" === i ? e(new Error("key expired while generating request")) : this.warn(`unhandled key status change "${i}"`)
                        }))
                    }));
                    return t.mediaKeysSession.generateRequest(e, i).then((() => {
                        var e;
                        this.log(`Request generated for key-session "${null==(e=t.mediaKeysSession)?void 0:e.sessionId}" keyId: ${l}`)
                    })).catch((t => {
                        throw new Gn({
                            type: E.KEY_SYSTEM_ERROR,
                            details: S.KEY_SYSTEM_NO_SESSION,
                            error: t,
                            fatal: !1
                        }, `Error generating key-session request: ${t}`)
                    })).then((() => d)).catch((e => {
                        throw u.removeAllListeners(), this.removeSession(t), e
                    })).then((() => (u.removeAllListeners(), t)))
                }
                onKeyStatusChange(t) {
                    t.mediaKeysSession.keyStatuses.forEach(((e, i) => {
                        this.log(`key status change "${e}" for keyStatuses keyId: ${At.hexDump("buffer"in i?new Uint8Array(i.buffer,i.byteOffset,i.byteLength):new Uint8Array(i))} session keyId: ${At.hexDump(new Uint8Array(t.decryptdata.keyId||[]))} uri: ${t.decryptdata.uri}`), t.keyStatus = e
                    }))
                }
                fetchServerCertificate(t) {
                    const e = this.config,
                        i = new(0, e.loader)(e),
                        r = this.getServerCertificateUrl(t);
                    return r ? (this.log(`Fetching server certificate for "${t}"`), new Promise(((s, n) => {
                        const a = {
                                responseType: "arraybuffer",
                                url: r
                            },
                            o = e.certLoadPolicy.default,
                            l = {
                                loadPolicy: o,
                                timeout: o.maxLoadTimeMs,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: 0
                            },
                            u = {
                                onSuccess: (t, e, i, r) => {
                                    s(t.data)
                                },
                                onError: (e, i, s, o) => {
                                    n(new Gn({
                                        type: E.KEY_SYSTEM_ERROR,
                                        details: S.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                                        fatal: !0,
                                        networkDetails: s,
                                        response: d({
                                            url: a.url,
                                            data: void 0
                                        }, e)
                                    }, `"${t}" certificate request failed (${r}). Status: ${e.code} (${e.text})`))
                                },
                                onTimeout: (e, i, s) => {
                                    n(new Gn({
                                        type: E.KEY_SYSTEM_ERROR,
                                        details: S.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                                        fatal: !0,
                                        networkDetails: s,
                                        response: {
                                            url: a.url,
                                            data: void 0
                                        }
                                    }, `"${t}" certificate request timed out (${r})`))
                                },
                                onAbort: (t, e, i) => {
                                    n(new Error("aborted"))
                                }
                            };
                        i.load(a, l, u)
                    }))) : Promise.resolve()
                }
                setMediaKeysServerCertificate(t, e, i) {
                    return new Promise(((r, s) => {
                        t.setServerCertificate(i).then((s => {
                            this.log(`setServerCertificate ${s?"success":"not supported by CDM"} (${null==i?void 0:i.byteLength}) on "${e}"`), r(t)
                        })).catch((t => {
                            s(new Gn({
                                type: E.KEY_SYSTEM_ERROR,
                                details: S.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
                                error: t,
                                fatal: !0
                            }, t.message))
                        }))
                    }))
                }
                renewLicense(t, e) {
                    return this.requestLicense(t, new Uint8Array(e)).then((e => this.updateKeySession(t, new Uint8Array(e)).catch((t => {
                        throw new Gn({
                            type: E.KEY_SYSTEM_ERROR,
                            details: S.KEY_SYSTEM_SESSION_UPDATE_FAILED,
                            error: t,
                            fatal: !0
                        }, t.message)
                    }))))
                }
                unpackPlayReadyKeyMessage(t, e) {
                    const i = String.fromCharCode.apply(null, new Uint16Array(e.buffer));
                    if (!i.includes("PlayReadyKeyMessage")) return t.setRequestHeader("Content-Type", "text/xml; charset=utf-8"), e;
                    const r = (new DOMParser).parseFromString(i, "application/xml"),
                        s = r.querySelectorAll("HttpHeader");
                    if (s.length > 0) {
                        let e;
                        for (let i = 0, r = s.length; i < r; i++) {
                            var n, a;
                            e = s[i];
                            const r = null == (n = e.querySelector("name")) ? void 0 : n.textContent,
                                o = null == (a = e.querySelector("value")) ? void 0 : a.textContent;
                            r && o && t.setRequestHeader(r, o)
                        }
                    }
                    const o = r.querySelector("Challenge"),
                        l = null == o ? void 0 : o.textContent;
                    if (!l) throw new Error("Cannot find <Challenge> in key message");
                    return H(atob(l))
                }
                setupLicenseXHR(t, e, i, r) {
                    const s = this.config.licenseXhrSetup;
                    return s ? Promise.resolve().then((() => {
                        if (!i.decryptdata) throw new Error("Key removed");
                        return s.call(this.hls, t, e, i, r)
                    })).catch((n => {
                        if (!i.decryptdata) throw n;
                        return t.open("POST", e, !0), s.call(this.hls, t, e, i, r)
                    })).then((i => {
                        t.readyState || t.open("POST", e, !0);
                        return {
                            xhr: t,
                            licenseChallenge: i || r
                        }
                    })) : (t.open("POST", e, !0), Promise.resolve({
                        xhr: t,
                        licenseChallenge: r
                    }))
                }
                requestLicense(t, e) {
                    const i = this.config.keyLoadPolicy.default;
                    return new Promise(((r, s) => {
                        const n = this.getLicenseServerUrl(t.keySystem);
                        this.log(`Sending license request to URL: ${n}`);
                        const a = new XMLHttpRequest;
                        a.responseType = "arraybuffer", a.onreadystatechange = () => {
                            if (!this.hls || !t.mediaKeysSession) return s(new Error("invalid state"));
                            if (4 === a.readyState)
                                if (200 === a.status) {
                                    this._requestLicenseFailureCount = 0;
                                    let e = a.response;
                                    this.log(`License received ${e instanceof ArrayBuffer?e.byteLength:e}`);
                                    const i = this.config.licenseResponseCallback;
                                    if (i) try {
                                        e = i.call(this.hls, a, n, t)
                                    } catch (t) {
                                        this.error(t)
                                    }
                                    r(e)
                                } else {
                                    const o = i.errorRetry,
                                        l = o ? o.maxNumRetry : 0;
                                    if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > l || a.status >= 400 && a.status < 500) s(new Gn({
                                        type: E.KEY_SYSTEM_ERROR,
                                        details: S.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                                        fatal: !0,
                                        networkDetails: a,
                                        response: {
                                            url: n,
                                            data: void 0,
                                            code: a.status,
                                            text: a.statusText
                                        }
                                    }, `License Request XHR failed (${n}). Status: ${a.status} (${a.statusText})`));
                                    else {
                                        const i = l - this._requestLicenseFailureCount + 1;
                                        this.warn(`Retrying license request, ${i} attempts left`), this.requestLicense(t, e).then(r, s)
                                    }
                                }
                        }, t.licenseXhr && t.licenseXhr.readyState !== XMLHttpRequest.DONE && t.licenseXhr.abort(), t.licenseXhr = a, this.setupLicenseXHR(a, n, t, e).then((({
                            xhr: e,
                            licenseChallenge: i
                        }) => {
                            t.keySystem == W.PLAYREADY && (i = this.unpackPlayReadyKeyMessage(e, i)), e.send(i)
                        }))
                    }))
                }
                onMediaAttached(t, e) {
                    if (!this.config.emeEnabled) return;
                    const i = e.media;
                    this.media = i, i.addEventListener("encrypted", this.onMediaEncrypted), i.addEventListener("waitingforkey", this.onWaitingForKey)
                }
                onMediaDetached() {
                    const t = this.media,
                        e = this.mediaKeySessions;
                    t && (t.removeEventListener("encrypted", this.onMediaEncrypted), t.removeEventListener("waitingforkey", this.onWaitingForKey), this.media = null), this._requestLicenseFailureCount = 0, this.setMediaKeysQueue = [], this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, Xt.clearKeyUriToKeyIdMap();
                    const i = e.length;
                    $n.CDMCleanupPromise = Promise.all(e.map((t => this.removeSession(t))).concat(null == t ? void 0 : t.setMediaKeys(null).catch((t => {
                        this.log(`Could not clear media keys: ${t}`)
                    })))).then((() => {
                        i && (this.log("finished closing key sessions and clearing media keys"), e.length = 0)
                    })).catch((t => {
                        this.log(`Could not close sessions and clear media keys: ${t}`)
                    }))
                }
                onManifestLoading() {
                    this.keyFormatPromise = null
                }
                onManifestLoaded(t, {
                    sessionKeys: e
                }) {
                    if (e && this.config.emeEnabled && !this.keyFormatPromise) {
                        const t = e.reduce(((t, e) => (-1 === t.indexOf(e.keyFormat) && t.push(e.keyFormat), t)), []);
                        this.log(`Selecting key-system from session-keys ${t.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(t)
                    }
                }
                removeSession(t) {
                    const {
                        mediaKeysSession: e,
                        licenseXhr: i
                    } = t;
                    if (e) {
                        this.log(`Remove licenses and keys and close session ${e.sessionId}`), t._onmessage && (e.removeEventListener("message", t._onmessage), t._onmessage = void 0), t._onkeystatuseschange && (e.removeEventListener("keystatuseschange", t._onkeystatuseschange), t._onkeystatuseschange = void 0), i && i.readyState !== XMLHttpRequest.DONE && i.abort(), t.mediaKeysSession = t.decryptdata = t.licenseXhr = void 0;
                        const r = this.mediaKeySessions.indexOf(t);
                        return r > -1 && this.mediaKeySessions.splice(r, 1), e.remove().catch((t => {
                            this.log(`Could not remove session: ${t}`)
                        })).then((() => e.close())).catch((t => {
                            this.log(`Could not close session: ${t}`)
                        }))
                    }
                }
            }
            $n.CDMCleanupPromise = void 0;
            class Gn extends Error {
                constructor(t, e) {
                    super(e), this.data = void 0, t.error || (t.error = new Error(e)), this.data = t, t.err = t.error
                }
            }
            var Hn, Vn, Wn;
            ! function(t) {
                t.MANIFEST = "m", t.AUDIO = "a", t.VIDEO = "v", t.MUXED = "av", t.INIT = "i", t.CAPTION = "c", t.TIMED_TEXT = "tt", t.KEY = "k", t.OTHER = "o"
            }(Hn || (Hn = {})),
            function(t) {
                t.DASH = "d", t.HLS = "h", t.SMOOTH = "s", t.OTHER = "o"
            }(Vn || (Vn = {})),
            function(t) {
                t.OBJECT = "CMCD-Object", t.REQUEST = "CMCD-Request", t.SESSION = "CMCD-Session", t.STATUS = "CMCD-Status"
            }(Wn || (Wn = {}));
            const Kn = {
                [Wn.OBJECT]: ["br", "d", "ot", "tb"],
                [Wn.REQUEST]: ["bl", "dl", "mtp", "nor", "nrr", "su"],
                [Wn.SESSION]: ["cid", "pr", "sf", "sid", "st", "v"],
                [Wn.STATUS]: ["bs", "rtp"]
            };
            class jn {
                constructor(t, e) {
                    this.value = void 0, this.params = void 0, Array.isArray(t) && (t = t.map((t => t instanceof jn ? t : new jn(t)))), this.value = t, this.params = e
                }
            }
            class qn {
                constructor(t) {
                    this.description = void 0, this.description = t
                }
            }
            const Yn = "Dict";

            function zn(t, e, i, r) {
                return new Error(`failed to ${t} "${s=e,Array.isArray(s)?JSON.stringify(s):s instanceof Map?"Map{}":s instanceof Set?"Set{}":"object"==typeof s?JSON.stringify(s):String(s)}" as ${i}`, {
                    cause: r
                });
                var s
            }
            const Xn = "Bare Item",
                Qn = "Boolean",
                Jn = "Byte Sequence",
                Zn = "Decimal",
                ta = "Integer";
            const ea = /[\x00-\x1f\x7f]+/,
                ia = "Token",
                ra = "Key";

            function sa(t, e, i) {
                return zn("serialize", t, e, i)
            }

            function na(t) {
                if (!1 === ArrayBuffer.isView(t)) throw sa(t, Jn);
                return `:${e=t,btoa(String.fromCharCode(...e))}:`;
                var e
            }

            function aa(t) {
                if (function(t) {
                        return t < -999999999999999 || 999999999999999 < t
                    }(t)) throw sa(t, ta);
                return t.toString()
            }

            function oa(t, e) {
                if (t < 0) return -oa(-t, e);
                const i = Math.pow(10, e);
                if (Math.abs(t * i % 1 - .5) < Number.EPSILON) {
                    const e = Math.floor(t * i);
                    return (e % 2 == 0 ? e : e + 1) / i
                }
                return Math.round(t * i) / i
            }

            function la(t) {
                const e = oa(t, 3);
                if (Math.floor(Math.abs(e)).toString().length > 12) throw sa(t, Zn);
                const i = e.toString();
                return i.includes(".") ? i : `${i}.0`
            }
            const ua = "String";

            function ca(t) {
                const e = (i = t).description || i.toString().slice(7, -1);
                var i;
                if (!1 === /^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(e)) throw sa(e, ia);
                return e
            }

            function ha(t) {
                switch (typeof t) {
                    case "number":
                        if (!p(t)) throw sa(t, Xn);
                        return Number.isInteger(t) ? aa(t) : la(t);
                    case "string":
                        return function(t) {
                            if (ea.test(t)) throw sa(t, ua);
                            return `"${t.replace(/\\/g,"\\\\").replace(/"/g,'\\"')}"`
                        }(t);
                    case "symbol":
                        return ca(t);
                    case "boolean":
                        return function(t) {
                            if ("boolean" != typeof t) throw sa(t, Qn);
                            return t ? "?1" : "?0"
                        }(t);
                    case "object":
                        if (t instanceof Date) return function(t) {
                            return `@${aa(t.getTime()/1e3)}`
                        }(t);
                        if (t instanceof Uint8Array) return na(t);
                        if (t instanceof qn) return ca(t);
                    default:
                        throw sa(t, Xn)
                }
            }

            function da(t) {
                if (!1 === /^[a-z*][a-z0-9\-_.*]*$/.test(t)) throw sa(t, ra);
                return t
            }

            function fa(t) {
                return null == t ? "" : Object.entries(t).map((([t, e]) => !0 === e ? `;${da(t)}` : `;${da(t)}=${ha(e)}`)).join("")
            }

            function ga(t) {
                return t instanceof jn ? `${ha(t.value)}${fa(t.params)}` : ha(t)
            }

            function ma(t, e = {
                whitespace: !0
            }) {
                if ("object" != typeof t) throw sa(t, Yn);
                const i = t instanceof Map ? t.entries() : Object.entries(t),
                    r = null != e && e.whitespace ? " " : "";
                return Array.from(i).map((([t, e]) => {
                    e instanceof jn == !1 && (e = new jn(e));
                    let i = da(t);
                    var r;
                    return !0 === e.value ? i += fa(e.params) : (i += "=", Array.isArray(e.value) ? i += `(${(r=e).value.map(ga).join(" ")})${fa(r.params)}` : i += ga(e)), i
                })).join(`,${r}`)
            }
            const pa = t => "ot" === t || "sf" === t || "st" === t,
                va = t => "number" == typeof t ? p(t) : null != t && "" !== t && !1 !== t;
            const ya = t => Math.round(t),
                Ta = t => 100 * ya(t / 100),
                Ea = {
                    br: ya,
                    d: ya,
                    bl: Ta,
                    dl: Ta,
                    mtp: Ta,
                    nor: (t, e) => (null != e && e.baseUrl && (t = function(t, e) {
                        const i = new URL(t),
                            r = new URL(e);
                        if (i.origin !== r.origin) return t;
                        const s = i.pathname.split("/").slice(1),
                            n = r.pathname.split("/").slice(1, -1);
                        for (; s[0] === n[0];) s.shift(), n.shift();
                        for (; n.length;) n.shift(), s.unshift("..");
                        return s.join("/")
                    }(t, e.baseUrl)), encodeURIComponent(t)),
                    rtp: Ta,
                    tb: ya
                };

            function Sa(t, e = {}) {
                return t ? function(t, e) {
                    return ma(t, e)
                }(function(t, e) {
                    const i = {};
                    if (null == t || "object" != typeof t) return i;
                    const r = Object.keys(t).sort(),
                        s = m({}, Ea, null == e ? void 0 : e.formatters),
                        n = null == e ? void 0 : e.filter;
                    return r.forEach((r => {
                        if (null != n && n(r)) return;
                        let a = t[r];
                        const o = s[r];
                        o && (a = o(a, e)), "v" === r && 1 === a || "pr" == r && 1 === a || va(a) && (pa(r) && "string" == typeof a && (a = new qn(a)), i[r] = a)
                    })), i
                }(t, e), m({
                    whitespace: !1
                }, e)) : ""
            }

            function ba(t, e, i) {
                return m(t, function(t, e = {}) {
                    if (!t) return {};
                    const i = Object.entries(t),
                        r = Object.entries(Kn).concat(Object.entries((null == e ? void 0 : e.customHeaderMap) || {})),
                        s = i.reduce(((t, e) => {
                            var i;
                            const [s, n] = e, a = (null == (i = r.find((t => t[1].includes(s)))) ? void 0 : i[0]) || Wn.REQUEST;
                            return null != t[a] || (t[a] = {}), t[a][s] = n, t
                        }), {});
                    return Object.entries(s).reduce(((t, [i, r]) => (t[i] = Sa(r, e), t)), {})
                }(e, i))
            }
            const Aa = "CMCD";
            const La = /CMCD=[^&#]+/;

            function ka(t, e, i) {
                const r = function(t, e = {}) {
                    if (!t) return "";
                    const i = Sa(t, e);
                    return `${Aa}=${encodeURIComponent(i)}`
                }(e, i);
                if (!r) return t;
                if (La.test(t)) return t.replace(La, r);
                const s = t.includes("?") ? "&" : "?";
                return `${t}${s}${r}`
            }

            function Ra(t, e, i, r) {
                t && Object.keys(e).forEach((s => {
                    const n = t.filter((t => t.groupId === s)).map((t => {
                        const n = m({}, t);
                        return n.details = void 0, n.attrs = new D(n.attrs), n.url = n.attrs.URI = wa(t.url, t.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", i), n.groupId = n.attrs["GROUP-ID"] = e[s], n.attrs["PATHWAY-ID"] = r, n
                    }));
                    t.push(...n)
                }))
            }

            function wa(t, e, i, r) {
                const {
                    HOST: s,
                    PARAMS: n,
                    [i]: a
                } = r;
                let o;
                e && (o = null == a ? void 0 : a[e], o && (t = o));
                const l = new self.URL(t);
                return s && !o && (l.host = s), n && Object.keys(n).sort().forEach((t => {
                    t && l.searchParams.set(t, n[t])
                })), l.href
            }
            const _a = /^age:\s*[\d.]+\s*$/im;
            class Da {
                constructor(t) {
                    this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = null, this.loader = null, this.stats = void 0, this.xhrSetup = t && t.xhrSetup || null, this.stats = new P, this.retryDelay = 0
                }
                destroy() {
                    this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null, this.context = null, this.xhrSetup = null
                }
                abortInternal() {
                    const t = this.loader;
                    self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), t && (t.onreadystatechange = null, t.onprogress = null, 4 !== t.readyState && (this.stats.aborted = !0, t.abort()))
                }
                abort() {
                    var t;
                    this.abortInternal(), null != (t = this.callbacks) && t.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
                }
                load(t, e, i) {
                    if (this.stats.loading.start) throw new Error("Loader can only be used once.");
                    this.stats.loading.start = self.performance.now(), this.context = t, this.config = e, this.callbacks = i, this.loadInternal()
                }
                loadInternal() {
                    const {
                        config: t,
                        context: e
                    } = this;
                    if (!t || !e) return;
                    const i = this.loader = new self.XMLHttpRequest,
                        r = this.stats;
                    r.loading.first = 0, r.loaded = 0, r.aborted = !1;
                    const s = this.xhrSetup;
                    s ? Promise.resolve().then((() => {
                        if (this.loader === i && !this.stats.aborted) return s(i, e.url)
                    })).catch((t => {
                        if (this.loader === i && !this.stats.aborted) return i.open("GET", e.url, !0), s(i, e.url)
                    })).then((() => {
                        this.loader !== i || this.stats.aborted || this.openAndSendXhr(i, e, t)
                    })).catch((t => {
                        this.callbacks.onError({
                            code: i.status,
                            text: t.message
                        }, e, i, r)
                    })) : this.openAndSendXhr(i, e, t)
                }
                openAndSendXhr(t, e, i) {
                    t.readyState || t.open("GET", e.url, !0);
                    const r = e.headers,
                        {
                            maxTimeToFirstByteMs: s,
                            maxLoadTimeMs: n
                        } = i.loadPolicy;
                    if (r)
                        for (const e in r) t.setRequestHeader(e, r[e]);
                    e.rangeEnd && t.setRequestHeader("Range", "bytes=" + e.rangeStart + "-" + (e.rangeEnd - 1)), t.onreadystatechange = this.readystatechange.bind(this), t.onprogress = this.loadprogress.bind(this), t.responseType = e.responseType, self.clearTimeout(this.requestTimeout), i.timeout = s && p(s) ? s : n, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), i.timeout), t.send()
                }
                readystatechange() {
                    const {
                        context: t,
                        loader: e,
                        stats: i
                    } = this;
                    if (!t || !e) return;
                    const r = e.readyState,
                        s = this.config;
                    if (!i.aborted && r >= 2 && (0 === i.loading.first && (i.loading.first = Math.max(self.performance.now(), i.loading.start), s.timeout !== s.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), s.timeout = s.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), s.loadPolicy.maxLoadTimeMs - (i.loading.first - i.loading.start)))), 4 === r)) {
                        self.clearTimeout(this.requestTimeout), e.onreadystatechange = null, e.onprogress = null;
                        const r = e.status,
                            n = "text" !== e.responseType;
                        if (r >= 200 && r < 300 && (n && e.response || null !== e.responseText)) {
                            i.loading.end = Math.max(self.performance.now(), i.loading.first);
                            const s = n ? e.response : e.responseText,
                                a = "arraybuffer" === e.responseType ? s.byteLength : s.length;
                            if (i.loaded = i.total = a, i.bwEstimate = 8e3 * i.total / (i.loading.end - i.loading.first), !this.callbacks) return;
                            const o = this.callbacks.onProgress;
                            if (o && o(i, t, s, e), !this.callbacks) return;
                            const l = {
                                url: e.responseURL,
                                data: s,
                                code: r
                            };
                            this.callbacks.onSuccess(l, i, t, e)
                        } else {
                            const n = s.loadPolicy.errorRetry;
                            yi(n, i.retry, !1, {
                                url: t.url,
                                data: void 0,
                                code: r
                            }) ? this.retry(n) : (R.error(`${r} while loading ${t.url}`), this.callbacks.onError({
                                code: r,
                                text: e.statusText
                            }, t, e, i))
                        }
                    }
                }
                loadtimeout() {
                    if (!this.config) return;
                    const t = this.config.loadPolicy.timeoutRetry;
                    if (yi(t, this.stats.retry, !0)) this.retry(t);
                    else {
                        var e;
                        R.warn(`timeout while loading ${null==(e=this.context)?void 0:e.url}`);
                        const t = this.callbacks;
                        t && (this.abortInternal(), t.onTimeout(this.stats, this.context, this.loader))
                    }
                }
                retry(t) {
                    const {
                        context: e,
                        stats: i
                    } = this;
                    this.retryDelay = pi(t, i.retry), i.retry++, R.warn(`${status?"HTTP Status "+status:"Timeout"} while loading ${null==e?void 0:e.url}, retrying ${i.retry}/${t.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay)
                }
                loadprogress(t) {
                    const e = this.stats;
                    e.loaded = t.loaded, t.lengthComputable && (e.total = t.total)
                }
                getCacheAge() {
                    let t = null;
                    if (this.loader && _a.test(this.loader.getAllResponseHeaders())) {
                        const e = this.loader.getResponseHeader("age");
                        t = e ? parseFloat(e) : null
                    }
                    return t
                }
                getResponseHeader(t) {
                    return this.loader && new RegExp(`^${t}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(t) : null
                }
            }
            const Ca = /(\d+)-(\d+)\/(\d+)/;
            class Ia {
                constructor(t) {
                    this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = null, this.response = null, this.controller = void 0, this.context = null, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = t.fetchSetup || Pa, this.controller = new self.AbortController, this.stats = new P
                }
                destroy() {
                    this.loader = this.callbacks = this.context = this.config = this.request = null, this.abortInternal(), this.response = null, this.fetchSetup = this.controller = this.stats = null
                }
                abortInternal() {
                    this.controller && !this.stats.loading.end && (this.stats.aborted = !0, this.controller.abort())
                }
                abort() {
                    var t;
                    this.abortInternal(), null != (t = this.callbacks) && t.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
                }
                load(t, e, i) {
                    const r = this.stats;
                    if (r.loading.start) throw new Error("Loader can only be used once.");
                    r.loading.start = self.performance.now();
                    const s = function(t, e) {
                            const i = {
                                method: "GET",
                                mode: "cors",
                                credentials: "same-origin",
                                signal: e,
                                headers: new self.Headers(m({}, t.headers))
                            };
                            t.rangeEnd && i.headers.set("Range", "bytes=" + t.rangeStart + "-" + String(t.rangeEnd - 1));
                            return i
                        }(t, this.controller.signal),
                        n = i.onProgress,
                        a = "arraybuffer" === t.responseType,
                        o = a ? "byteLength" : "length",
                        {
                            maxTimeToFirstByteMs: l,
                            maxLoadTimeMs: u
                        } = e.loadPolicy;
                    this.context = t, this.config = e, this.callbacks = i, this.request = this.fetchSetup(t, s), self.clearTimeout(this.requestTimeout), e.timeout = l && p(l) ? l : u, this.requestTimeout = self.setTimeout((() => {
                        this.abortInternal(), i.onTimeout(r, t, this.response)
                    }), e.timeout), self.fetch(this.request).then((s => {
                        this.response = this.loader = s;
                        const o = Math.max(self.performance.now(), r.loading.start);
                        if (self.clearTimeout(this.requestTimeout), e.timeout = u, this.requestTimeout = self.setTimeout((() => {
                                this.abortInternal(), i.onTimeout(r, t, this.response)
                            }), u - (o - r.loading.start)), !s.ok) {
                            const {
                                status: t,
                                statusText: e
                            } = s;
                            throw new xa(e || "fetch, bad network response", t, s)
                        }
                        return r.loading.first = o, r.total = function(t) {
                            const e = t.get("Content-Range");
                            if (e) {
                                const t = function(t) {
                                    const e = Ca.exec(t);
                                    if (e) return parseInt(e[2]) - parseInt(e[1]) + 1
                                }(e);
                                if (p(t)) return t
                            }
                            const i = t.get("Content-Length");
                            if (i) return parseInt(i)
                        }(s.headers) || r.total, n && p(e.highWaterMark) ? this.loadProgressively(s, r, t, e.highWaterMark, n) : a ? s.arrayBuffer() : "json" === t.responseType ? s.json() : s.text()
                    })).then((s => {
                        const a = this.response;
                        if (!a) throw new Error("loader destroyed");
                        self.clearTimeout(this.requestTimeout), r.loading.end = Math.max(self.performance.now(), r.loading.first);
                        const l = s[o];
                        l && (r.loaded = r.total = l);
                        const u = {
                            url: a.url,
                            data: s,
                            code: a.status
                        };
                        n && !p(e.highWaterMark) && n(r, t, s, a), i.onSuccess(u, r, t, a)
                    })).catch((e => {
                        if (self.clearTimeout(this.requestTimeout), r.aborted) return;
                        const s = e && e.code || 0,
                            n = e ? e.message : null;
                        i.onError({
                            code: s,
                            text: n
                        }, t, e ? e.details : null, r)
                    }))
                }
                getCacheAge() {
                    let t = null;
                    if (this.response) {
                        const e = this.response.headers.get("age");
                        t = e ? parseFloat(e) : null
                    }
                    return t
                }
                getResponseHeader(t) {
                    return this.response ? this.response.headers.get(t) : null
                }
                loadProgressively(t, e, i, r = 0, s) {
                    const n = new _r,
                        a = t.body.getReader(),
                        o = () => a.read().then((a => {
                            if (a.done) return n.dataLength && s(e, i, n.flush(), t), Promise.resolve(new ArrayBuffer(0));
                            const l = a.value,
                                u = l.length;
                            return e.loaded += u, u < r || n.dataLength ? (n.push(l), n.dataLength >= r && s(e, i, n.flush(), t)) : s(e, i, l, t), o()
                        })).catch((() => Promise.reject()));
                    return o()
                }
            }

            function Pa(t, e) {
                return new self.Request(t.url, e)
            }
            class xa extends Error {
                constructor(t, e, i) {
                    super(t), this.code = void 0, this.details = void 0, this.code = e, this.details = i
                }
            }
            const Ma = /\s/,
                Oa = {
                    newCue(t, e, i, r) {
                        const s = [];
                        let n, a, o, l, u;
                        const c = self.VTTCue || self.TextTrackCue;
                        for (let d = 0; d < r.rows.length; d++)
                            if (n = r.rows[d], o = !0, l = 0, u = "", !n.isEmpty()) {
                                var h;
                                for (let t = 0; t < n.chars.length; t++) Ma.test(n.chars[t].uchar) && o ? l++ : (u += n.chars[t].uchar, o = !1);
                                n.cueStartTime = e, e === i && (i += 1e-4), l >= 16 ? l-- : l++;
                                const r = yn(u.trim()),
                                    f = An(e, i, r);
                                null != t && null != (h = t.cues) && h.getCueById(f) || (a = new c(e, i, r), a.id = f, a.line = d + 1, a.align = "left", a.position = 10 + Math.min(80, 10 * Math.floor(8 * l / 32)), s.push(a))
                            }
                        return t && s.length && (s.sort(((t, e) => "auto" === t.line || "auto" === e.line ? 0 : t.line > 8 && e.line > 8 ? e.line - t.line : t.line - e.line)), s.forEach((e => Be(t, e)))), s
                    }
                },
                Fa = d(d({
                    autoStartLoad: !0,
                    startPosition: -1,
                    defaultAudioCodec: void 0,
                    debug: !1,
                    capLevelOnFPSDrop: !1,
                    capLevelToPlayerSize: !1,
                    ignoreDevicePixelRatio: !1,
                    preferManagedMediaSource: !0,
                    initialLiveManifestSize: 1,
                    maxBufferLength: 30,
                    backBufferLength: Infinity,
                    frontBufferFlushThreshold: Infinity,
                    maxBufferSize: 6e7,
                    maxBufferHole: .1,
                    highBufferWatchdogPeriod: 2,
                    nudgeOffset: .1,
                    nudgeMaxRetry: 3,
                    maxFragLookUpTolerance: .25,
                    liveSyncDurationCount: 3,
                    liveMaxLatencyDurationCount: Infinity,
                    liveSyncDuration: void 0,
                    liveMaxLatencyDuration: void 0,
                    maxLiveSyncPlaybackRate: 1,
                    liveDurationInfinity: !1,
                    liveBackBufferLength: null,
                    maxMaxBufferLength: 600,
                    enableWorker: !0,
                    workerPath: null,
                    enableSoftwareAES: !0,
                    startLevel: void 0,
                    startFragPrefetch: !1,
                    fpsDroppedMonitoringPeriod: 5e3,
                    fpsDroppedMonitoringThreshold: .2,
                    appendErrorMaxRetry: 3,
                    loader: Da,
                    fLoader: void 0,
                    pLoader: void 0,
                    xhrSetup: void 0,
                    licenseXhrSetup: void 0,
                    licenseResponseCallback: void 0,
                    abrController: class {
                        constructor(t) {
                            this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = -1, this.firstSelection = -1, this._nextAutoLevel = -1, this.nextAutoLevelKey = "", this.audioTracksByGroup = null, this.codecTiers = null, this.timer = -1, this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this._abandonRulesCheck = () => {
                                const {
                                    fragCurrent: t,
                                    partCurrent: e,
                                    hls: i
                                } = this, {
                                    autoLevelEnabled: r,
                                    media: s
                                } = i;
                                if (!t || !s) return;
                                const n = performance.now(),
                                    a = e ? e.stats : t.stats,
                                    o = e ? e.duration : t.duration,
                                    l = n - a.loading.start,
                                    u = i.minAutoLevel;
                                if (a.aborted || a.loaded && a.loaded === a.total || t.level <= u) return this.clearTimer(), void(this._nextAutoLevel = -1);
                                if (!r || s.paused || !s.playbackRate || !s.readyState) return;
                                const c = i.mainForwardBufferInfo;
                                if (null === c) return;
                                const h = this.bwEstimator.getEstimateTTFB(),
                                    d = Math.abs(s.playbackRate);
                                if (l <= Math.max(h, o / (2 * d) * 1e3)) return;
                                const f = c.len / d,
                                    g = a.loading.first ? a.loading.first - a.loading.start : -1,
                                    m = a.loaded && g > -1,
                                    v = this.getBwEstimate(),
                                    y = i.levels,
                                    E = y[t.level],
                                    S = a.total || Math.max(a.loaded, Math.round(o * E.averageBitrate / 8));
                                let b = m ? l - g : l;
                                b < 1 && m && (b = Math.min(l, 8 * a.loaded / v));
                                const A = m ? 1e3 * a.loaded / b : 0,
                                    L = A ? (S - a.loaded) / A : 8 * S / v + h / 1e3;
                                if (L <= f) return;
                                const k = A ? 8 * A : v;
                                let w, _ = Number.POSITIVE_INFINITY;
                                for (w = t.level - 1; w > u; w--) {
                                    const t = y[w].maxBitrate;
                                    if (_ = this.getTimeToLoadFrag(h / 1e3, k, o * t, !y[w].details), _ < f) break
                                }
                                if (_ >= L) return;
                                if (_ > 10 * o) return;
                                i.nextLoadLevel = i.nextAutoLevel = w, m ? this.bwEstimator.sample(l - Math.min(h, g), a.loaded) : this.bwEstimator.sampleTTFB(l);
                                const D = y[w].maxBitrate;
                                this.getBwEstimate() * this.hls.config.abrBandWidthUpFactor > D && this.resetEstimator(D), this.clearTimer(), R.warn(`[abr] Fragment ${t.sn}${e?" part "+e.index:""} of level ${t.level} is loading too slowly;\n      Time to underbuffer: ${f.toFixed(3)} s\n      Estimated load time for current fragment: ${L.toFixed(3)} s\n      Estimated load time for down switch fragment: ${_.toFixed(3)} s\n      TTFB estimate: ${0|g} ms\n      Current BW estimate: ${p(v)?0|v:"Unknown"} bps\n      New BW estimate: ${0|this.getBwEstimate()} bps\n      Switching to level ${w} @ ${0|D} bps`), i.trigger(T.FRAG_LOAD_EMERGENCY_ABORTED, {
                                    frag: t,
                                    part: e,
                                    stats: a
                                })
                            }, this.hls = t, this.bwEstimator = this.initEstimator(), this.registerListeners()
                        }
                        resetEstimator(t) {
                            t && (R.log(`setting initial bwe to ${t}`), this.hls.config.abrEwmaDefaultEstimate = t), this.firstSelection = -1, this.bwEstimator = this.initEstimator()
                        }
                        initEstimator() {
                            const t = this.hls.config;
                            return new Pi(t.abrEwmaSlowVoD, t.abrEwmaFastVoD, t.abrEwmaDefaultEstimate)
                        }
                        registerListeners() {
                            const {
                                hls: t
                            } = this;
                            t.on(T.MANIFEST_LOADING, this.onManifestLoading, this), t.on(T.FRAG_LOADING, this.onFragLoading, this), t.on(T.FRAG_LOADED, this.onFragLoaded, this), t.on(T.FRAG_BUFFERED, this.onFragBuffered, this), t.on(T.LEVEL_SWITCHING, this.onLevelSwitching, this), t.on(T.LEVEL_LOADED, this.onLevelLoaded, this), t.on(T.LEVELS_UPDATED, this.onLevelsUpdated, this), t.on(T.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), t.on(T.ERROR, this.onError, this)
                        }
                        unregisterListeners() {
                            const {
                                hls: t
                            } = this;
                            t && (t.off(T.MANIFEST_LOADING, this.onManifestLoading, this), t.off(T.FRAG_LOADING, this.onFragLoading, this), t.off(T.FRAG_LOADED, this.onFragLoaded, this), t.off(T.FRAG_BUFFERED, this.onFragBuffered, this), t.off(T.LEVEL_SWITCHING, this.onLevelSwitching, this), t.off(T.LEVEL_LOADED, this.onLevelLoaded, this), t.off(T.LEVELS_UPDATED, this.onLevelsUpdated, this), t.off(T.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), t.off(T.ERROR, this.onError, this))
                        }
                        destroy() {
                            this.unregisterListeners(), this.clearTimer(), this.hls = this._abandonRulesCheck = null, this.fragCurrent = this.partCurrent = null
                        }
                        onManifestLoading(t, e) {
                            this.lastLoadedFragLevel = -1, this.firstSelection = -1, this.lastLevelLoadSec = 0, this.fragCurrent = this.partCurrent = null, this.onLevelsUpdated(), this.clearTimer()
                        }
                        onLevelsUpdated() {
                            this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level), this._nextAutoLevel = -1, this.onMaxAutoLevelUpdated(), this.codecTiers = null, this.audioTracksByGroup = null
                        }
                        onMaxAutoLevelUpdated() {
                            this.firstSelection = -1, this.nextAutoLevelKey = ""
                        }
                        onFragLoading(t, e) {
                            const i = e.frag;
                            if (!this.ignoreFragment(i)) {
                                var r;
                                if (!i.bitrateTest) this.fragCurrent = i, this.partCurrent = null != (r = e.part) ? r : null;
                                this.clearTimer(), this.timer = self.setInterval(this._abandonRulesCheck, 100)
                            }
                        }
                        onLevelSwitching(t, e) {
                            this.clearTimer()
                        }
                        onError(t, e) {
                            if (!e.fatal) switch (e.details) {
                                case S.BUFFER_ADD_CODEC_ERROR:
                                case S.BUFFER_APPEND_ERROR:
                                    this.lastLoadedFragLevel = -1, this.firstSelection = -1;
                                    break;
                                case S.FRAG_LOAD_TIMEOUT:
                                    {
                                        const t = e.frag,
                                            {
                                                fragCurrent: i,
                                                partCurrent: r
                                            } = this;
                                        if (t && i && t.sn === i.sn && t.level === i.level) {
                                            const e = performance.now(),
                                                i = r ? r.stats : t.stats,
                                                s = e - i.loading.start,
                                                n = i.loading.first ? i.loading.first - i.loading.start : -1;
                                            if (i.loaded && n > -1) {
                                                const t = this.bwEstimator.getEstimateTTFB();
                                                this.bwEstimator.sample(s - Math.min(t, n), i.loaded)
                                            } else this.bwEstimator.sampleTTFB(s)
                                        }
                                        break
                                    }
                            }
                        }
                        getTimeToLoadFrag(t, e, i, r) {
                            return t + i / e + (r ? this.lastLevelLoadSec : 0)
                        }
                        onLevelLoaded(t, e) {
                            const i = this.hls.config,
                                {
                                    loading: r
                                } = e.stats,
                                s = r.end - r.start;
                            p(s) && (this.lastLevelLoadSec = s / 1e3), e.details.live ? this.bwEstimator.update(i.abrEwmaSlowLive, i.abrEwmaFastLive) : this.bwEstimator.update(i.abrEwmaSlowVoD, i.abrEwmaFastVoD)
                        }
                        onFragLoaded(t, {
                            frag: e,
                            part: i
                        }) {
                            const r = i ? i.stats : e.stats;
                            if (e.type === Ie && this.bwEstimator.sampleTTFB(r.loading.first - r.loading.start), !this.ignoreFragment(e)) {
                                if (this.clearTimer(), e.level === this._nextAutoLevel && (this._nextAutoLevel = -1), this.firstSelection = -1, this.hls.config.abrMaxWithRealBitrate) {
                                    const t = i ? i.duration : e.duration,
                                        s = this.hls.levels[e.level],
                                        n = (s.loaded ? s.loaded.bytes : 0) + r.loaded,
                                        a = (s.loaded ? s.loaded.duration : 0) + t;
                                    s.loaded = {
                                        bytes: n,
                                        duration: a
                                    }, s.realBitrate = Math.round(8 * n / a)
                                }
                                if (e.bitrateTest) {
                                    const t = {
                                        stats: r,
                                        frag: e,
                                        part: i,
                                        id: e.type
                                    };
                                    this.onFragBuffered(T.FRAG_BUFFERED, t), e.bitrateTest = !1
                                } else this.lastLoadedFragLevel = e.level
                            }
                        }
                        onFragBuffered(t, e) {
                            const {
                                frag: i,
                                part: r
                            } = e, s = null != r && r.stats.loaded ? r.stats : i.stats;
                            if (s.aborted) return;
                            if (this.ignoreFragment(i)) return;
                            const n = s.parsing.end - s.loading.start - Math.min(s.loading.first - s.loading.start, this.bwEstimator.getEstimateTTFB());
                            this.bwEstimator.sample(n, s.loaded), s.bwEstimate = this.getBwEstimate(), i.bitrateTest ? this.bitrateTestDelay = n / 1e3 : this.bitrateTestDelay = 0
                        }
                        ignoreFragment(t) {
                            return t.type !== Ie || "initSegment" === t.sn
                        }
                        clearTimer() {
                            this.timer > -1 && (self.clearInterval(this.timer), this.timer = -1)
                        }
                        get firstAutoLevel() {
                            const {
                                maxAutoLevel: t,
                                minAutoLevel: e
                            } = this.hls, i = this.getBwEstimate(), r = this.hls.config.maxStarvationDelay, s = this.findBestLevel(i, e, t, 0, r, 1, 1);
                            if (s > -1) return s;
                            const n = this.hls.firstLevel,
                                a = Math.min(Math.max(n, e), t);
                            return R.warn(`[abr] Could not find best starting auto level. Defaulting to first in playlist ${n} clamped to ${a}`), a
                        }
                        get forcedAutoLevel() {
                            return this.nextAutoLevelKey ? -1 : this._nextAutoLevel
                        }
                        get nextAutoLevel() {
                            const t = this.forcedAutoLevel,
                                e = this.bwEstimator.canEstimate(),
                                i = this.lastLoadedFragLevel > -1;
                            if (!(-1 === t || e && i && this.nextAutoLevelKey !== this.getAutoLevelKey())) return t;
                            const r = e && i ? this.getNextABRAutoLevel() : this.firstAutoLevel;
                            if (-1 !== t) {
                                const e = this.hls.levels;
                                if (e.length > Math.max(t, r) && e[t].loadError <= e[r].loadError) return t
                            }
                            return this._nextAutoLevel = r, this.nextAutoLevelKey = this.getAutoLevelKey(), r
                        }
                        getAutoLevelKey() {
                            return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`
                        }
                        getNextABRAutoLevel() {
                            const {
                                fragCurrent: t,
                                partCurrent: e,
                                hls: i
                            } = this, {
                                maxAutoLevel: r,
                                config: s,
                                minAutoLevel: n
                            } = i, a = e ? e.duration : t ? t.duration : 0, o = this.getBwEstimate(), l = this.getStarvationDelay();
                            let u = s.abrBandWidthFactor,
                                c = s.abrBandWidthUpFactor;
                            if (l) {
                                const t = this.findBestLevel(o, n, r, l, 0, u, c);
                                if (t >= 0) return t
                            }
                            let h = a ? Math.min(a, s.maxStarvationDelay) : s.maxStarvationDelay;
                            if (!l) {
                                const t = this.bitrateTestDelay;
                                if (t) {
                                    h = (a ? Math.min(a, s.maxLoadingDelay) : s.maxLoadingDelay) - t, R.info(`[abr] bitrate test took ${Math.round(1e3*t)}ms, set first fragment max fetchDuration to ${Math.round(1e3*h)} ms`), u = c = 1
                                }
                            }
                            const d = this.findBestLevel(o, n, r, l, h, u, c);
                            if (R.info(`[abr] ${l?"rebuffering expected":"buffer is empty"}, optimal quality level ${d}`), d > -1) return d;
                            const f = i.levels[n],
                                g = i.levels[i.loadLevel];
                            return (null == f ? void 0 : f.bitrate) < (null == g ? void 0 : g.bitrate) ? n : i.loadLevel
                        }
                        getStarvationDelay() {
                            const t = this.hls,
                                e = t.media;
                            if (!e) return Infinity;
                            const i = e && 0 !== e.playbackRate ? Math.abs(e.playbackRate) : 1,
                                r = t.mainForwardBufferInfo;
                            return (r ? r.len : 0) / i
                        }
                        getBwEstimate() {
                            return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate
                        }
                        findBestLevel(t, e, i, r, s, n, a) {
                            var o;
                            const l = r + s,
                                u = this.lastLoadedFragLevel,
                                c = -1 === u ? this.hls.firstLevel : u,
                                {
                                    fragCurrent: h,
                                    partCurrent: d
                                } = this,
                                {
                                    levels: f,
                                    allAudioTracks: g,
                                    loadLevel: m,
                                    config: v
                                } = this.hls;
                            if (1 === f.length) return 0;
                            const y = f[c],
                                T = !(null == y || null == (o = y.details) || !o.live),
                                E = -1 === m || -1 === u;
                            let S, b = "SDR",
                                A = (null == y ? void 0 : y.frameRate) || 0;
                            const {
                                audioPreference: L,
                                videoPreference: k
                            } = v, w = this.audioTracksByGroup || (this.audioTracksByGroup = function(t) {
                                return t.reduce(((t, e) => {
                                    let i = t.groups[e.groupId];
                                    i || (i = t.groups[e.groupId] = {
                                        tracks: [],
                                        channels: {
                                            2: 0
                                        },
                                        hasDefault: !1,
                                        hasAutoSelect: !1
                                    }), i.tracks.push(e);
                                    const r = e.channels || "2";
                                    return i.channels[r] = (i.channels[r] || 0) + 1, i.hasDefault = i.hasDefault || e.default, i.hasAutoSelect = i.hasAutoSelect || e.autoselect, i.hasDefault && (t.hasDefaultAudio = !0), i.hasAutoSelect && (t.hasAutoSelectAudio = !0), t
                                }), {
                                    hasDefaultAudio: !1,
                                    hasAutoSelectAudio: !1,
                                    groups: {}
                                })
                            }(g));
                            if (E) {
                                if (-1 !== this.firstSelection) return this.firstSelection;
                                const r = this.codecTiers || (this.codecTiers = function(t, e, i, r) {
                                        return t.slice(i, r + 1).reduce(((t, i) => {
                                            if (!i.codecSet) return t;
                                            const r = i.audioGroups;
                                            let s = t[i.codecSet];
                                            s || (t[i.codecSet] = s = {
                                                minBitrate: Infinity,
                                                minHeight: Infinity,
                                                minFramerate: Infinity,
                                                maxScore: 0,
                                                videoRanges: {
                                                    SDR: 0
                                                },
                                                channels: {
                                                    2: 0
                                                },
                                                hasDefaultAudio: !r,
                                                fragmentError: 0
                                            }), s.minBitrate = Math.min(s.minBitrate, i.bitrate);
                                            const n = Math.min(i.height, i.width);
                                            return s.minHeight = Math.min(s.minHeight, n), s.minFramerate = Math.min(s.minFramerate, i.frameRate), s.maxScore = Math.max(s.maxScore, i.score), s.fragmentError += i.fragmentError, s.videoRanges[i.videoRange] = (s.videoRanges[i.videoRange] || 0) + 1, r && r.forEach((t => {
                                                if (!t) return;
                                                const i = e.groups[t];
                                                i && (s.hasDefaultAudio = s.hasDefaultAudio || e.hasDefaultAudio ? i.hasDefault : i.hasAutoSelect || !e.hasDefaultAudio && !e.hasAutoSelectAudio, Object.keys(i.channels).forEach((t => {
                                                    s.channels[t] = (s.channels[t] || 0) + i.channels[t]
                                                })))
                                            })), t
                                        }), {})
                                    }(f, w, e, i)),
                                    s = function(t, e, i, r, s) {
                                        const n = Object.keys(t),
                                            a = null == r ? void 0 : r.channels,
                                            o = null == r ? void 0 : r.audioCodec,
                                            l = a && 2 === parseInt(a);
                                        let u = !0,
                                            c = !1,
                                            h = Infinity,
                                            d = Infinity,
                                            f = Infinity,
                                            g = 0,
                                            m = [];
                                        const {
                                            preferHDR: v,
                                            allowedVideoRanges: y
                                        } = Ni(e, s);
                                        for (let e = n.length; e--;) {
                                            const i = t[n[e]];
                                            u = i.channels[2] > 0, h = Math.min(h, i.minHeight), d = Math.min(d, i.minFramerate), f = Math.min(f, i.minBitrate);
                                            const r = y.filter((t => i.videoRanges[t] > 0));
                                            r.length > 0 && (c = !0, m = r)
                                        }
                                        h = p(h) ? h : 0, d = p(d) ? d : 0;
                                        const T = Math.max(1080, h),
                                            E = Math.max(30, d);
                                        return f = p(f) ? f : i, i = Math.max(f, i), c || (e = void 0, m = []), {
                                            codecSet: n.reduce(((e, r) => {
                                                const s = t[r];
                                                if (r === e) return e;
                                                if (s.minBitrate > i) return Bi(r, `min bitrate of ${s.minBitrate} > current estimate of ${i}`), e;
                                                if (!s.hasDefaultAudio) return Bi(r, "no renditions with default or auto-select sound found"), e;
                                                if (o && r.indexOf(o.substring(0, 4)) % 5 != 0) return Bi(r, `audio codec preference "${o}" not found`), e;
                                                if (a && !l) {
                                                    if (!s.channels[a]) return Bi(r, `no renditions with ${a} channel sound found (channels options: ${Object.keys(s.channels)})`), e
                                                } else if ((!o || l) && u && 0 === s.channels[2]) return Bi(r, "no renditions with stereo sound found"), e;
                                                return s.minHeight > T ? (Bi(r, `min resolution of ${s.minHeight} > maximum of ${T}`), e) : s.minFramerate > E ? (Bi(r, `min framerate of ${s.minFramerate} > maximum of ${E}`), e) : m.some((t => s.videoRanges[t] > 0)) ? s.maxScore < g ? (Bi(r, `max score of ${s.maxScore} < selected max of ${g}`), e) : e && (ue(r) >= ue(e) || s.fragmentError > t[e].fragmentError) ? e : (g = s.maxScore, r) : (Bi(r, `no variants with VIDEO-RANGE of ${JSON.stringify(m)} found`), e)
                                            }), void 0),
                                            videoRanges: m,
                                            preferHDR: v,
                                            minFramerate: d,
                                            minBitrate: f
                                        }
                                    }(r, b, t, L, k),
                                    {
                                        codecSet: n,
                                        videoRanges: a,
                                        minFramerate: o,
                                        minBitrate: l,
                                        preferHDR: u
                                    } = s;
                                S = n, b = u ? a[a.length - 1] : a[0], A = o, t = Math.max(t, l), R.log(`[abr] picked start tier ${JSON.stringify(s)}`)
                            } else S = null == y ? void 0 : y.codecSet, b = null == y ? void 0 : y.videoRange;
                            const _ = d ? d.duration : h ? h.duration : 0,
                                D = this.bwEstimator.getEstimateTTFB() / 1e3,
                                C = [];
                            for (let o = i; o >= e; o--) {
                                var I;
                                const e = f[o],
                                    h = o > c;
                                if (!e) continue;
                                if (v.useMediaCapabilities && !e.supportedResult && !e.supportedPromise) {
                                    const i = navigator.mediaCapabilities;
                                    "function" == typeof(null == i ? void 0 : i.decodingInfo) && Oi(e, w, b, A, t, L) ? (e.supportedPromise = Fi(e, w, i), e.supportedPromise.then((t => {
                                        if (!this.hls) return;
                                        e.supportedResult = t;
                                        const i = this.hls.levels,
                                            r = i.indexOf(e);
                                        t.error ? R.warn(`[abr] MediaCapabilities decodingInfo error: "${t.error}" for level ${r} ${JSON.stringify(t)}`) : t.supported || (R.warn(`[abr] Unsupported MediaCapabilities decodingInfo result for level ${r} ${JSON.stringify(t)}`), r > -1 && i.length > 1 && (R.log(`[abr] Removing unsupported level ${r}`), this.hls.removeLevel(r)))
                                    }))) : e.supportedResult = xi
                                }
                                if (S && e.codecSet !== S || b && e.videoRange !== b || h && A > e.frameRate || !h && A > 0 && A < e.frameRate || e.supportedResult && (null == (I = e.supportedResult.decodingInfoResults) || !I[0].smooth)) {
                                    C.push(o);
                                    continue
                                }
                                const g = e.details,
                                    k = (d ? null == g ? void 0 : g.partTarget : null == g ? void 0 : g.averagetargetduration) || _;
                                let P;
                                P = h ? a * t : n * t;
                                const x = _ && r >= 2 * _ && 0 === s ? f[o].averageBitrate : f[o].maxBitrate,
                                    M = this.getTimeToLoadFrag(D, P, x * k, void 0 === g);
                                if (P >= x && (o === u || 0 === e.loadError && 0 === e.fragmentError) && (M <= D || !p(M) || T && !this.bitrateTestDelay || M < l)) {
                                    const t = this.forcedAutoLevel;
                                    return o === m || -1 !== t && t === m || (C.length && R.trace(`[abr] Skipped level(s) ${C.join(",")} of ${i} max with CODECS and VIDEO-RANGE:"${f[C[0]].codecs}" ${f[C[0]].videoRange}; not compatible with "${y.codecs}" ${b}`), R.info(`[abr] switch candidate:${c}->${o} adjustedbw(${Math.round(P)})-bitrate=${Math.round(P-x)} ttfb:${D.toFixed(1)} avgDuration:${k.toFixed(1)} maxFetchDuration:${l.toFixed(1)} fetchDuration:${M.toFixed(1)} firstSelection:${E} codecSet:${S} videoRange:${b} hls.loadLevel:${m}`)), E && (this.firstSelection = o), o
                                }
                            }
                            return -1
                        }
                        set nextAutoLevel(t) {
                            const {
                                maxAutoLevel: e,
                                minAutoLevel: i
                            } = this.hls, r = Math.min(Math.max(t, i), e);
                            this._nextAutoLevel !== r && (this.nextAutoLevelKey = "", this._nextAutoLevel = r)
                        }
                    },
                    bufferController: class {
                        constructor(t) {
                            this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.appendSource = void 0, this.appendErrors = {
                                audio: 0,
                                video: 0,
                                audiovideo: 0
                            }, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this.log = void 0, this.warn = void 0, this.error = void 0, this._onEndStreaming = t => {
                                this.hls && this.hls.pauseBuffering()
                            }, this._onStartStreaming = t => {
                                this.hls && this.hls.resumeBuffering()
                            }, this._onMediaSourceOpen = () => {
                                const {
                                    media: t,
                                    mediaSource: e
                                } = this;
                                this.log("Media source opened"), t && (t.removeEventListener("emptied", this._onMediaEmptied), this.updateMediaElementDuration(), this.hls.trigger(T.MEDIA_ATTACHED, {
                                    media: t,
                                    mediaSource: e
                                })), e && e.removeEventListener("sourceopen", this._onMediaSourceOpen), this.checkPendingTracks()
                            }, this._onMediaSourceClose = () => {
                                this.log("Media source closed")
                            }, this._onMediaSourceEnded = () => {
                                this.log("Media source ended")
                            }, this._onMediaEmptied = () => {
                                const {
                                    mediaSrc: t,
                                    _objectUrl: e
                                } = this;
                                t !== e && R.error(`Media element src was set while attaching MediaSource (${e} > ${t})`)
                            }, this.hls = t;
                            const e = "[buffer-controller]";
                            var i;
                            this.appendSource = (i = re(t.config.preferManagedMediaSource), "undefined" != typeof self && i === self.ManagedMediaSource), this.log = R.log.bind(R, e), this.warn = R.warn.bind(R, e), this.error = R.error.bind(R, e), this._initSourceBuffer(), this.registerListeners()
                        }
                        hasSourceTypes() {
                            return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0
                        }
                        destroy() {
                            this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = null, this.hls = null
                        }
                        registerListeners() {
                            const {
                                hls: t
                            } = this;
                            t.on(T.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(T.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(T.MANIFEST_LOADING, this.onManifestLoading, this), t.on(T.MANIFEST_PARSED, this.onManifestParsed, this), t.on(T.BUFFER_RESET, this.onBufferReset, this), t.on(T.BUFFER_APPENDING, this.onBufferAppending, this), t.on(T.BUFFER_CODECS, this.onBufferCodecs, this), t.on(T.BUFFER_EOS, this.onBufferEos, this), t.on(T.BUFFER_FLUSHING, this.onBufferFlushing, this), t.on(T.LEVEL_UPDATED, this.onLevelUpdated, this), t.on(T.FRAG_PARSED, this.onFragParsed, this), t.on(T.FRAG_CHANGED, this.onFragChanged, this)
                        }
                        unregisterListeners() {
                            const {
                                hls: t
                            } = this;
                            t.off(T.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(T.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(T.MANIFEST_LOADING, this.onManifestLoading, this), t.off(T.MANIFEST_PARSED, this.onManifestParsed, this), t.off(T.BUFFER_RESET, this.onBufferReset, this), t.off(T.BUFFER_APPENDING, this.onBufferAppending, this), t.off(T.BUFFER_CODECS, this.onBufferCodecs, this), t.off(T.BUFFER_EOS, this.onBufferEos, this), t.off(T.BUFFER_FLUSHING, this.onBufferFlushing, this), t.off(T.LEVEL_UPDATED, this.onLevelUpdated, this), t.off(T.FRAG_PARSED, this.onFragParsed, this), t.off(T.FRAG_CHANGED, this.onFragChanged, this)
                        }
                        _initSourceBuffer() {
                            this.sourceBuffer = {}, this.operationQueue = new $s(this.sourceBuffer), this.listeners = {
                                audio: [],
                                video: [],
                                audiovideo: []
                            }, this.appendErrors = {
                                audio: 0,
                                video: 0,
                                audiovideo: 0
                            }, this.lastMpegAudioChunk = null
                        }
                        onManifestLoading() {
                            this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0, this.details = null
                        }
                        onManifestParsed(t, e) {
                            let i = 2;
                            (e.audio && !e.video || !e.altAudio) && (i = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = i, this.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`)
                        }
                        onMediaAttaching(t, e) {
                            const i = this.media = e.media,
                                r = re(this.appendSource);
                            if (i && r) {
                                var s;
                                const t = this.mediaSource = new r;
                                this.log(`created media source: ${null==(s=t.constructor)?void 0:s.name}`), t.addEventListener("sourceopen", this._onMediaSourceOpen), t.addEventListener("sourceended", this._onMediaSourceEnded), t.addEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (t.addEventListener("startstreaming", this._onStartStreaming), t.addEventListener("endstreaming", this._onEndStreaming));
                                const e = this._objectUrl = self.URL.createObjectURL(t);
                                if (this.appendSource) try {
                                    i.removeAttribute("src");
                                    const r = self.ManagedMediaSource;
                                    i.disableRemotePlayback = i.disableRemotePlayback || r && t instanceof r, Hs(i),
                                        function(t, e) {
                                            const i = self.document.createElement("source");
                                            i.type = "video/mp4", i.src = e, t.appendChild(i)
                                        }(i, e), i.load()
                                } catch (t) {
                                    i.src = e
                                } else i.src = e;
                                i.addEventListener("emptied", this._onMediaEmptied)
                            }
                        }
                        onMediaDetaching() {
                            const {
                                media: t,
                                mediaSource: e,
                                _objectUrl: i
                            } = this;
                            if (e) {
                                if (this.log("media source detaching"), "open" === e.readyState) try {
                                    e.endOfStream()
                                } catch (t) {
                                    this.warn(`onMediaDetaching: ${t.message} while calling endOfStream`)
                                }
                                this.onBufferReset(), e.removeEventListener("sourceopen", this._onMediaSourceOpen), e.removeEventListener("sourceended", this._onMediaSourceEnded), e.removeEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (e.removeEventListener("startstreaming", this._onStartStreaming), e.removeEventListener("endstreaming", this._onEndStreaming)), t && (t.removeEventListener("emptied", this._onMediaEmptied), i && self.URL.revokeObjectURL(i), this.mediaSrc === i ? (t.removeAttribute("src"), this.appendSource && Hs(t), t.load()) : this.warn("media|source.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {}
                            }
                            this.hls.trigger(T.MEDIA_DETACHED, void 0)
                        }
                        onBufferReset() {
                            this.getSourceBufferTypes().forEach((t => {
                                this.resetBuffer(t)
                            })), this._initSourceBuffer()
                        }
                        resetBuffer(t) {
                            const e = this.sourceBuffer[t];
                            try {
                                var i;
                                if (e) this.removeBufferListeners(t), this.sourceBuffer[t] = void 0, null != (i = this.mediaSource) && i.sourceBuffers.length && this.mediaSource.removeSourceBuffer(e)
                            } catch (e) {
                                this.warn(`onBufferReset ${t}`, e)
                            }
                        }
                        onBufferCodecs(t, e) {
                            const i = this.getSourceBufferTypes().length,
                                r = Object.keys(e);
                            if (r.forEach((t => {
                                    if (i) {
                                        const i = this.tracks[t];
                                        if (i && "function" == typeof i.buffer.changeType) {
                                            var r;
                                            const {
                                                id: s,
                                                codec: n,
                                                levelCodec: a,
                                                container: o,
                                                metadata: l
                                            } = e[t], u = fe(i.codec, i.levelCodec), c = null == u ? void 0 : u.replace(Gs, "$1");
                                            let h = fe(n, a);
                                            const d = null == (r = h) ? void 0 : r.replace(Gs, "$1");
                                            if (h && c !== d) {
                                                "audio" === t.slice(0, 5) && (h = de(h, this.appendSource));
                                                const e = `${o};codecs=${h}`;
                                                this.appendChangeType(t, e), this.log(`switching codec ${u} to ${h}`), this.tracks[t] = {
                                                    buffer: i.buffer,
                                                    codec: n,
                                                    container: o,
                                                    levelCodec: a,
                                                    metadata: l,
                                                    id: s
                                                }
                                            }
                                        }
                                    } else this.pendingTracks[t] = e[t]
                                })), i) return;
                            const s = Math.max(this.bufferCodecEventsExpected - 1, 0);
                            this.bufferCodecEventsExpected !== s && (this.log(`${s} bufferCodec event(s) expected ${r.join(",")}`), this.bufferCodecEventsExpected = s), this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks()
                        }
                        appendChangeType(t, e) {
                            const {
                                operationQueue: i
                            } = this, r = {
                                execute: () => {
                                    const r = this.sourceBuffer[t];
                                    r && (this.log(`changing ${t} sourceBuffer type to ${e}`), r.changeType(e)), i.shiftAndExecuteNext(t)
                                },
                                onStart: () => {},
                                onComplete: () => {},
                                onError: e => {
                                    this.warn(`Failed to change ${t} SourceBuffer type`, e)
                                }
                            };
                            i.append(r, t, !!this.pendingTracks[t])
                        }
                        onBufferAppending(t, e) {
                            const {
                                hls: i,
                                operationQueue: r,
                                tracks: s
                            } = this, {
                                data: n,
                                type: a,
                                frag: o,
                                part: l,
                                chunkMeta: u
                            } = e, c = u.buffering[a], h = self.performance.now();
                            c.start = h;
                            const d = o.stats.buffering,
                                f = l ? l.stats.buffering : null;
                            0 === d.start && (d.start = h), f && 0 === f.start && (f.start = h);
                            const g = s.audio;
                            let m = !1;
                            "audio" === a && "audio/mpeg" === (null == g ? void 0 : g.container) && (m = !this.lastMpegAudioChunk || 1 === u.id || this.lastMpegAudioChunk.sn !== u.sn, this.lastMpegAudioChunk = u);
                            const p = o.start,
                                v = {
                                    execute: () => {
                                        if (c.executeStart = self.performance.now(), m) {
                                            const t = this.sourceBuffer[a];
                                            if (t) {
                                                const e = p - t.timestampOffset;
                                                Math.abs(e) >= .1 && (this.log(`Updating audio SourceBuffer timestampOffset to ${p} (delta: ${e}) sn: ${o.sn})`), t.timestampOffset = p)
                                            }
                                        }
                                        this.appendExecutor(n, a)
                                    },
                                    onStart: () => {},
                                    onComplete: () => {
                                        const t = self.performance.now();
                                        c.executeEnd = c.end = t, 0 === d.first && (d.first = t), f && 0 === f.first && (f.first = t);
                                        const {
                                            sourceBuffer: e
                                        } = this, i = {};
                                        for (const t in e) i[t] = Ji.getBuffered(e[t]);
                                        this.appendErrors[a] = 0, "audio" === a || "video" === a ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0, this.appendErrors.video = 0), this.hls.trigger(T.BUFFER_APPENDED, {
                                            type: a,
                                            frag: o,
                                            part: l,
                                            chunkMeta: u,
                                            parent: o.type,
                                            timeRanges: i
                                        })
                                    },
                                    onError: t => {
                                        const e = {
                                            type: E.MEDIA_ERROR,
                                            parent: o.type,
                                            details: S.BUFFER_APPEND_ERROR,
                                            sourceBufferName: a,
                                            frag: o,
                                            part: l,
                                            chunkMeta: u,
                                            error: t,
                                            err: t,
                                            fatal: !1
                                        };
                                        if (t.code === DOMException.QUOTA_EXCEEDED_ERR) e.details = S.BUFFER_FULL_ERROR;
                                        else {
                                            const t = ++this.appendErrors[a];
                                            e.details = S.BUFFER_APPEND_ERROR, this.warn(`Failed ${t}/${i.config.appendErrorMaxRetry} times to append segment in "${a}" sourceBuffer`), t >= i.config.appendErrorMaxRetry && (e.fatal = !0)
                                        }
                                        i.trigger(T.ERROR, e)
                                    }
                                };
                            r.append(v, a, !!this.pendingTracks[a])
                        }
                        onBufferFlushing(t, e) {
                            const {
                                operationQueue: i
                            } = this, r = t => ({
                                execute: this.removeExecutor.bind(this, t, e.startOffset, e.endOffset),
                                onStart: () => {},
                                onComplete: () => {
                                    this.hls.trigger(T.BUFFER_FLUSHED, {
                                        type: t
                                    })
                                },
                                onError: e => {
                                    this.warn(`Failed to remove from ${t} SourceBuffer`, e)
                                }
                            });
                            e.type ? i.append(r(e.type), e.type) : this.getSourceBufferTypes().forEach((t => {
                                i.append(r(t), t)
                            }))
                        }
                        onFragParsed(t, e) {
                            const {
                                frag: i,
                                part: r
                            } = e, s = [], n = r ? r.elementaryStreams : i.elementaryStreams;
                            n[O] ? s.push("audiovideo") : (n[x] && s.push("audio"), n[M] && s.push("video"));
                            0 === s.length && this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${i.type} level: ${i.level} sn: ${i.sn}`), this.blockBuffers((() => {
                                const t = self.performance.now();
                                i.stats.buffering.end = t, r && (r.stats.buffering.end = t);
                                const e = r ? r.stats : i.stats;
                                this.hls.trigger(T.FRAG_BUFFERED, {
                                    frag: i,
                                    part: r,
                                    stats: e,
                                    id: i.type
                                })
                            }), s)
                        }
                        onFragChanged(t, e) {
                            this.trimBuffers()
                        }
                        onBufferEos(t, e) {
                            this.getSourceBufferTypes().reduce(((t, i) => {
                                const r = this.sourceBuffer[i];
                                return !r || e.type && e.type !== i || (r.ending = !0, r.ended || (r.ended = !0, this.log(`${i} sourceBuffer now EOS`))), t && !(r && !r.ended)
                            }), !0) && (this.log("Queueing mediaSource.endOfStream()"), this.blockBuffers((() => {
                                this.getSourceBufferTypes().forEach((t => {
                                    const e = this.sourceBuffer[t];
                                    e && (e.ending = !1)
                                }));
                                const {
                                    mediaSource: t
                                } = this;
                                t && "open" === t.readyState ? (this.log("Calling mediaSource.endOfStream()"), t.endOfStream()) : t && this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${t.readyState}`)
                            })))
                        }
                        onLevelUpdated(t, {
                            details: e
                        }) {
                            e.fragments.length && (this.details = e, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration())
                        }
                        trimBuffers() {
                            const {
                                hls: t,
                                details: e,
                                media: i
                            } = this;
                            if (!i || null === e) return;
                            if (!this.getSourceBufferTypes().length) return;
                            const r = t.config,
                                s = i.currentTime,
                                n = e.levelTargetDuration,
                                a = e.live && null !== r.liveBackBufferLength ? r.liveBackBufferLength : r.backBufferLength;
                            if (p(a) && a > 0) {
                                const t = Math.max(a, n),
                                    e = Math.floor(s / n) * n - t;
                                this.flushBackBuffer(s, n, e)
                            }
                            if (p(r.frontBufferFlushThreshold) && r.frontBufferFlushThreshold > 0) {
                                const t = Math.max(r.maxBufferLength, r.frontBufferFlushThreshold),
                                    e = Math.max(t, n),
                                    i = Math.floor(s / n) * n + e;
                                this.flushFrontBuffer(s, n, i)
                            }
                        }
                        flushBackBuffer(t, e, i) {
                            const {
                                details: r,
                                sourceBuffer: s
                            } = this;
                            this.getSourceBufferTypes().forEach((n => {
                                const a = s[n];
                                if (a) {
                                    const s = Ji.getBuffered(a);
                                    if (s.length > 0 && i > s.start(0)) {
                                        if (this.hls.trigger(T.BACK_BUFFER_REACHED, {
                                                bufferEnd: i
                                            }), null != r && r.live) this.hls.trigger(T.LIVE_BACK_BUFFER_REACHED, {
                                            bufferEnd: i
                                        });
                                        else if (a.ended && s.end(s.length - 1) - t < 2 * e) return void this.log(`Cannot flush ${n} back buffer while SourceBuffer is in ended state`);
                                        this.hls.trigger(T.BUFFER_FLUSHING, {
                                            startOffset: 0,
                                            endOffset: i,
                                            type: n
                                        })
                                    }
                                }
                            }))
                        }
                        flushFrontBuffer(t, e, i) {
                            const {
                                sourceBuffer: r
                            } = this;
                            this.getSourceBufferTypes().forEach((s => {
                                const n = r[s];
                                if (n) {
                                    const r = Ji.getBuffered(n),
                                        a = r.length;
                                    if (a < 2) return;
                                    const o = r.start(a - 1),
                                        l = r.end(a - 1);
                                    if (i > o || t >= o && t <= l) return;
                                    if (n.ended && t - l < 2 * e) return void this.log(`Cannot flush ${s} front buffer while SourceBuffer is in ended state`);
                                    this.hls.trigger(T.BUFFER_FLUSHING, {
                                        startOffset: o,
                                        endOffset: Infinity,
                                        type: s
                                    })
                                }
                            }))
                        }
                        updateMediaElementDuration() {
                            if (!this.details || !this.media || !this.mediaSource || "open" !== this.mediaSource.readyState) return;
                            const {
                                details: t,
                                hls: e,
                                media: i,
                                mediaSource: r
                            } = this, s = t.fragments[0].start + t.totalduration, n = i.duration, a = p(r.duration) ? r.duration : 0;
                            t.live && e.config.liveDurationInfinity ? (r.duration = Infinity, this.updateSeekableRange(t)) : (s > a && s > n || !p(n)) && (this.log(`Updating Media Source duration to ${s.toFixed(3)}`), r.duration = s)
                        }
                        updateSeekableRange(t) {
                            const e = this.mediaSource,
                                i = t.fragments;
                            if (i.length && t.live && null != e && e.setLiveSeekableRange) {
                                const r = Math.max(0, i[0].start),
                                    s = Math.max(r, r + t.totalduration);
                                this.log(`Media Source duration is set to ${e.duration}. Setting seekable range to ${r}-${s}.`), e.setLiveSeekableRange(r, s)
                            }
                        }
                        checkPendingTracks() {
                            const {
                                bufferCodecEventsExpected: t,
                                operationQueue: e,
                                pendingTracks: i
                            } = this, r = Object.keys(i).length;
                            if (r && (!t || 2 === r || "audiovideo" in i)) {
                                this.createSourceBuffers(i), this.pendingTracks = {};
                                const t = this.getSourceBufferTypes();
                                if (t.length) this.hls.trigger(T.BUFFER_CREATED, {
                                    tracks: this.tracks
                                }), t.forEach((t => {
                                    e.executeNext(t)
                                }));
                                else {
                                    const t = new Error("could not create source buffer for media codec(s)");
                                    this.hls.trigger(T.ERROR, {
                                        type: E.MEDIA_ERROR,
                                        details: S.BUFFER_INCOMPATIBLE_CODECS_ERROR,
                                        fatal: !0,
                                        error: t,
                                        reason: t.message
                                    })
                                }
                            }
                        }
                        createSourceBuffers(t) {
                            const {
                                sourceBuffer: e,
                                mediaSource: i
                            } = this;
                            if (!i) throw Error("createSourceBuffers called when mediaSource was null");
                            for (const s in t)
                                if (!e[s]) {
                                    var r;
                                    const n = t[s];
                                    if (!n) throw Error(`source buffer exists for track ${s}, however track does not`);
                                    let a = -1 === (null == (r = n.levelCodec) ? void 0 : r.indexOf(",")) ? n.levelCodec : n.codec;
                                    a && "audio" === s.slice(0, 5) && (a = de(a, this.appendSource));
                                    const o = `${n.container};codecs=${a}`;
                                    this.log(`creating sourceBuffer(${o})`);
                                    try {
                                        const t = e[s] = i.addSourceBuffer(o),
                                            r = s;
                                        this.addBufferListener(r, "updatestart", this._onSBUpdateStart), this.addBufferListener(r, "updateend", this._onSBUpdateEnd), this.addBufferListener(r, "error", this._onSBUpdateError), this.appendSource && this.addBufferListener(r, "bufferedchange", ((t, e) => {
                                            const i = e.removedRanges;
                                            null != i && i.length && this.hls.trigger(T.BUFFER_FLUSHED, {
                                                type: s
                                            })
                                        })), this.tracks[s] = {
                                            buffer: t,
                                            codec: a,
                                            container: n.container,
                                            levelCodec: n.levelCodec,
                                            metadata: n.metadata,
                                            id: n.id
                                        }
                                    } catch (t) {
                                        this.error(`error while trying to add sourceBuffer: ${t.message}`), this.hls.trigger(T.ERROR, {
                                            type: E.MEDIA_ERROR,
                                            details: S.BUFFER_ADD_CODEC_ERROR,
                                            fatal: !1,
                                            error: t,
                                            sourceBufferName: s,
                                            mimeType: o
                                        })
                                    }
                                }
                        }
                        get mediaSrc() {
                            var t, e;
                            const i = (null == (t = this.media) || null == (e = t.querySelector) ? void 0 : e.call(t, "source")) || this.media;
                            return null == i ? void 0 : i.src
                        }
                        _onSBUpdateStart(t) {
                            const {
                                operationQueue: e
                            } = this;
                            e.current(t).onStart()
                        }
                        _onSBUpdateEnd(t) {
                            var e;
                            if ("closed" === (null == (e = this.mediaSource) ? void 0 : e.readyState)) return void this.resetBuffer(t);
                            const {
                                operationQueue: i
                            } = this;
                            i.current(t).onComplete(), i.shiftAndExecuteNext(t)
                        }
                        _onSBUpdateError(t, e) {
                            var i;
                            const r = new Error(`${t} SourceBuffer error. MediaSource readyState: ${null==(i=this.mediaSource)?void 0:i.readyState}`);
                            this.error(`${r}`, e), this.hls.trigger(T.ERROR, {
                                type: E.MEDIA_ERROR,
                                details: S.BUFFER_APPENDING_ERROR,
                                sourceBufferName: t,
                                error: r,
                                fatal: !1
                            });
                            const s = this.operationQueue.current(t);
                            s && s.onError(r)
                        }
                        removeExecutor(t, e, i) {
                            const {
                                media: r,
                                mediaSource: s,
                                operationQueue: n,
                                sourceBuffer: a
                            } = this, o = a[t];
                            if (!r || !s || !o) return this.warn(`Attempting to remove from the ${t} SourceBuffer, but it does not exist`), void n.shiftAndExecuteNext(t);
                            const l = p(r.duration) ? r.duration : Infinity,
                                u = p(s.duration) ? s.duration : Infinity,
                                c = Math.max(0, e),
                                h = Math.min(i, l, u);
                            h > c && (!o.ending || o.ended) ? (o.ended = !1, this.log(`Removing [${c},${h}] from the ${t} SourceBuffer`), o.remove(c, h)) : n.shiftAndExecuteNext(t)
                        }
                        appendExecutor(t, e) {
                            const i = this.sourceBuffer[e];
                            if (i) i.ended = !1, i.appendBuffer(t);
                            else if (!this.pendingTracks[e]) throw new Error(`Attempting to append to the ${e} SourceBuffer, but it does not exist`)
                        }
                        blockBuffers(t, e = this.getSourceBufferTypes()) {
                            if (!e.length) return this.log("Blocking operation requested, but no SourceBuffers exist"), void Promise.resolve().then(t);
                            const {
                                operationQueue: i
                            } = this, r = e.map((t => i.appendBlocker(t)));
                            Promise.all(r).then((() => {
                                t(), e.forEach((t => {
                                    const e = this.sourceBuffer[t];
                                    null != e && e.updating || i.shiftAndExecuteNext(t)
                                }))
                            }))
                        }
                        getSourceBufferTypes() {
                            return Object.keys(this.sourceBuffer)
                        }
                        addBufferListener(t, e, i) {
                            const r = this.sourceBuffer[t];
                            if (!r) return;
                            const s = i.bind(this, t);
                            this.listeners[t].push({
                                event: e,
                                listener: s
                            }), r.addEventListener(e, s)
                        }
                        removeBufferListeners(t) {
                            const e = this.sourceBuffer[t];
                            e && this.listeners[t].forEach((t => {
                                e.removeEventListener(t.event, t.listener)
                            }))
                        }
                    },
                    capLevelController: Bn,
                    errorController: class {
                        constructor(t) {
                            this.hls = void 0, this.playlistError = 0, this.penalizedRenditions = {}, this.log = void 0, this.warn = void 0, this.error = void 0, this.hls = t, this.log = R.log.bind(R, "[info]:"), this.warn = R.warn.bind(R, "[warning]:"), this.error = R.error.bind(R, "[error]:"), this.registerListeners()
                        }
                        registerListeners() {
                            const t = this.hls;
                            t.on(T.ERROR, this.onError, this), t.on(T.MANIFEST_LOADING, this.onManifestLoading, this), t.on(T.LEVEL_UPDATED, this.onLevelUpdated, this)
                        }
                        unregisterListeners() {
                            const t = this.hls;
                            t && (t.off(T.ERROR, this.onError, this), t.off(T.ERROR, this.onErrorOut, this), t.off(T.MANIFEST_LOADING, this.onManifestLoading, this), t.off(T.LEVEL_UPDATED, this.onLevelUpdated, this))
                        }
                        destroy() {
                            this.unregisterListeners(), this.hls = null, this.penalizedRenditions = {}
                        }
                        startLoad(t) {}
                        stopLoad() {
                            this.playlistError = 0
                        }
                        getVariantLevelIndex(t) {
                            return (null == t ? void 0 : t.type) === Ie ? t.level : this.hls.loadLevel
                        }
                        onManifestLoading() {
                            this.playlistError = 0, this.penalizedRenditions = {}
                        }
                        onLevelUpdated() {
                            this.playlistError = 0
                        }
                        onError(t, e) {
                            var i, r;
                            if (e.fatal) return;
                            const s = this.hls,
                                n = e.context;
                            switch (e.details) {
                                case S.FRAG_LOAD_ERROR:
                                case S.FRAG_LOAD_TIMEOUT:
                                case S.KEY_LOAD_ERROR:
                                case S.KEY_LOAD_TIMEOUT:
                                    return void(e.errorAction = this.getFragRetryOrSwitchAction(e));
                                case S.FRAG_PARSING_ERROR:
                                    if (null != (i = e.frag) && i.gap) return void(e.errorAction = {
                                        action: Ai,
                                        flags: wi
                                    });
                                case S.FRAG_GAP:
                                case S.FRAG_DECRYPT_ERROR:
                                    return e.errorAction = this.getFragRetryOrSwitchAction(e), void(e.errorAction.action = Li);
                                case S.LEVEL_EMPTY_ERROR:
                                case S.LEVEL_PARSING_ERROR:
                                    {
                                        var a, o;
                                        const t = e.parent === Ie ? e.level : s.loadLevel;e.details === S.LEVEL_EMPTY_ERROR && null != (a = e.context) && null != (o = a.levelDetails) && o.live ? e.errorAction = this.getPlaylistRetryOrSwitchAction(e, t) : (e.levelRetry = !1, e.errorAction = this.getLevelSwitchAction(e, t))
                                    }
                                    return;
                                case S.LEVEL_LOAD_ERROR:
                                case S.LEVEL_LOAD_TIMEOUT:
                                    return void("number" == typeof(null == n ? void 0 : n.level) && (e.errorAction = this.getPlaylistRetryOrSwitchAction(e, n.level)));
                                case S.AUDIO_TRACK_LOAD_ERROR:
                                case S.AUDIO_TRACK_LOAD_TIMEOUT:
                                case S.SUBTITLE_LOAD_ERROR:
                                case S.SUBTITLE_TRACK_LOAD_TIMEOUT:
                                    if (n) {
                                        const t = s.levels[s.loadLevel];
                                        if (t && (n.type === De && t.hasAudioGroup(n.groupId) || n.type === Ce && t.hasSubtitleGroup(n.groupId))) return e.errorAction = this.getPlaylistRetryOrSwitchAction(e, s.loadLevel), e.errorAction.action = Li, void(e.errorAction.flags = _i)
                                    }
                                    return;
                                case S.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
                                    {
                                        const t = s.levels[s.loadLevel],
                                            i = null == t ? void 0 : t.attrs["HDCP-LEVEL"];i ? e.errorAction = {
                                            action: Li,
                                            flags: Di,
                                            hdcpLevel: i
                                        } : this.keySystemError(e)
                                    }
                                    return;
                                case S.BUFFER_ADD_CODEC_ERROR:
                                case S.REMUX_ALLOC_ERROR:
                                case S.BUFFER_APPEND_ERROR:
                                    return void(e.errorAction = this.getLevelSwitchAction(e, null != (r = e.level) ? r : s.loadLevel));
                                case S.INTERNAL_EXCEPTION:
                                case S.BUFFER_APPENDING_ERROR:
                                case S.BUFFER_FULL_ERROR:
                                case S.LEVEL_SWITCH_ERROR:
                                case S.BUFFER_STALLED_ERROR:
                                case S.BUFFER_SEEK_OVER_HOLE:
                                case S.BUFFER_NUDGE_ON_STALL:
                                    return void(e.errorAction = {
                                        action: Ai,
                                        flags: wi
                                    })
                            }
                            e.type === E.KEY_SYSTEM_ERROR && this.keySystemError(e)
                        }
                        keySystemError(t) {
                            const e = this.getVariantLevelIndex(t.frag);
                            t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, e)
                        }
                        getPlaylistRetryOrSwitchAction(t, e) {
                            const i = mi(this.hls.config.playlistLoadPolicy, t),
                                r = this.playlistError++;
                            if (yi(i, r, gi(t), t.response)) return {
                                action: Ri,
                                flags: wi,
                                retryConfig: i,
                                retryCount: r
                            };
                            const s = this.getLevelSwitchAction(t, e);
                            return i && (s.retryConfig = i, s.retryCount = r), s
                        }
                        getFragRetryOrSwitchAction(t) {
                            const e = this.hls,
                                i = this.getVariantLevelIndex(t.frag),
                                r = e.levels[i],
                                {
                                    fragLoadPolicy: s,
                                    keyLoadPolicy: n
                                } = e.config,
                                a = mi(t.details.startsWith("key") ? n : s, t),
                                o = e.levels.reduce(((t, e) => t + e.fragmentError), 0);
                            if (r) {
                                t.details !== S.FRAG_GAP && r.fragmentError++;
                                if (yi(a, o, gi(t), t.response)) return {
                                    action: Ri,
                                    flags: wi,
                                    retryConfig: a,
                                    retryCount: o
                                }
                            }
                            const l = this.getLevelSwitchAction(t, i);
                            return a && (l.retryConfig = a, l.retryCount = o), l
                        }
                        getLevelSwitchAction(t, e) {
                            const i = this.hls;
                            null == e && (e = i.loadLevel);
                            const r = this.hls.levels[e];
                            if (r) {
                                var s, n;
                                const e = t.details;
                                r.loadError++, e === S.BUFFER_APPEND_ERROR && r.fragmentError++;
                                let l = -1;
                                const {
                                    levels: u,
                                    loadLevel: c,
                                    minAutoLevel: h,
                                    maxAutoLevel: d
                                } = i;
                                i.autoLevelEnabled || (i.loadLevel = -1);
                                const f = null == (s = t.frag) ? void 0 : s.type,
                                    g = (f === Pe && e === S.FRAG_PARSING_ERROR || "audio" === t.sourceBufferName && (e === S.BUFFER_ADD_CODEC_ERROR || e === S.BUFFER_APPEND_ERROR)) && u.some((({
                                        audioCodec: t
                                    }) => r.audioCodec !== t)),
                                    m = "video" === t.sourceBufferName && (e === S.BUFFER_ADD_CODEC_ERROR || e === S.BUFFER_APPEND_ERROR) && u.some((({
                                        codecSet: t,
                                        audioCodec: e
                                    }) => r.codecSet !== t && r.audioCodec === e)),
                                    {
                                        type: p,
                                        groupId: v
                                    } = null != (n = t.context) ? n : {};
                                for (let i = u.length; i--;) {
                                    const s = (i + c) % u.length;
                                    if (s !== c && s >= h && s <= d && 0 === u[s].loadError) {
                                        var a, o;
                                        const i = u[s];
                                        if (e === S.FRAG_GAP && f === Ie && t.frag) {
                                            const e = u[s].details;
                                            if (e) {
                                                const i = Ei(t.frag, e.fragments, t.frag.start);
                                                if (null != i && i.gap) continue
                                            }
                                        } else {
                                            if (p === De && i.hasAudioGroup(v) || p === Ce && i.hasSubtitleGroup(v)) continue;
                                            if (f === Pe && null != (a = r.audioGroups) && a.some((t => i.hasAudioGroup(t))) || f === xe && null != (o = r.subtitleGroups) && o.some((t => i.hasSubtitleGroup(t))) || g && r.audioCodec === i.audioCodec || !g && r.audioCodec !== i.audioCodec || m && r.codecSet === i.codecSet) continue
                                        }
                                        l = s;
                                        break
                                    }
                                }
                                if (l > -1 && i.loadLevel !== l) return t.levelRetry = !0, this.playlistError = 0, {
                                    action: Li,
                                    flags: wi,
                                    nextAutoLevel: l
                                }
                            }
                            return {
                                action: Li,
                                flags: _i
                            }
                        }
                        onErrorOut(t, e) {
                            var i;
                            switch (null == (i = e.errorAction) ? void 0 : i.action) {
                                case Ai:
                                    break;
                                case Li:
                                    this.sendAlternateToPenaltyBox(e), e.errorAction.resolved || e.details === S.FRAG_GAP ? /MediaSource readyState: ended/.test(e.error.message) && (this.warn(`MediaSource ended after "${e.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`), this.hls.recoverMediaError()) : e.fatal = !0
                            }
                            e.fatal && this.hls.stopLoad()
                        }
                        sendAlternateToPenaltyBox(t) {
                            const e = this.hls,
                                i = t.errorAction;
                            if (!i) return;
                            const {
                                flags: r,
                                hdcpLevel: s,
                                nextAutoLevel: n
                            } = i;
                            switch (r) {
                                case wi:
                                    this.switchLevel(t, n);
                                    break;
                                case Di:
                                    s && (e.maxHdcpLevel = Qe[Qe.indexOf(s) - 1], i.resolved = !0), this.warn(`Restricting playback to HDCP-LEVEL of "${e.maxHdcpLevel}" or lower`)
                            }
                            i.resolved || this.switchLevel(t, n)
                        }
                        switchLevel(t, e) {
                            void 0 !== e && t.errorAction && (this.warn(`switching to level ${e} after ${t.details}`), this.hls.nextAutoLevel = e, t.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel)
                        }
                    },
                    fpsController: class {
                        constructor(t) {
                            this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = t, this.registerListeners()
                        }
                        setStreamController(t) {
                            this.streamController = t
                        }
                        registerListeners() {
                            this.hls.on(T.MEDIA_ATTACHING, this.onMediaAttaching, this)
                        }
                        unregisterListeners() {
                            this.hls.off(T.MEDIA_ATTACHING, this.onMediaAttaching, this)
                        }
                        destroy() {
                            this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null
                        }
                        onMediaAttaching(t, e) {
                            const i = this.hls.config;
                            if (i.capLevelOnFPSDrop) {
                                const t = e.media instanceof self.HTMLVideoElement ? e.media : null;
                                this.media = t, t && "function" == typeof t.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), i.fpsDroppedMonitoringPeriod)
                            }
                        }
                        checkFPS(t, e, i) {
                            const r = performance.now();
                            if (e) {
                                if (this.lastTime) {
                                    const t = r - this.lastTime,
                                        s = i - this.lastDroppedFrames,
                                        n = e - this.lastDecodedFrames,
                                        a = 1e3 * s / t,
                                        o = this.hls;
                                    if (o.trigger(T.FPS_DROP, {
                                            currentDropped: s,
                                            currentDecoded: n,
                                            totalDroppedFrames: i
                                        }), a > 0 && s > o.config.fpsDroppedMonitoringThreshold * n) {
                                        let t = o.currentLevel;
                                        R.warn("drop FPS ratio greater than max allowed value for currentLevel: " + t), t > 0 && (-1 === o.autoLevelCapping || o.autoLevelCapping >= t) && (t -= 1, o.trigger(T.FPS_DROP_LEVEL_CAPPING, {
                                            level: t,
                                            droppedLevel: o.currentLevel
                                        }), o.autoLevelCapping = t, this.streamController.nextLevelSwitch())
                                    }
                                }
                                this.lastTime = r, this.lastDroppedFrames = i, this.lastDecodedFrames = e
                            }
                        }
                        checkFPSInterval() {
                            const t = this.media;
                            if (t)
                                if (this.isVideoPlaybackQualityAvailable) {
                                    const e = t.getVideoPlaybackQuality();
                                    this.checkFPS(t, e.totalVideoFrames, e.droppedVideoFrames)
                                } else this.checkFPS(t, t.webkitDecodedFrameCount, t.webkitDroppedFrameCount)
                        }
                    },
                    stretchShortVideoTrack: !1,
                    maxAudioFramesDrift: 1,
                    forceKeyFrameOnDiscontinuity: !0,
                    abrEwmaFastLive: 3,
                    abrEwmaSlowLive: 9,
                    abrEwmaFastVoD: 3,
                    abrEwmaSlowVoD: 9,
                    abrEwmaDefaultEstimate: 5e5,
                    abrEwmaDefaultEstimateMax: 5e6,
                    abrBandWidthFactor: .95,
                    abrBandWidthUpFactor: .7,
                    abrMaxWithRealBitrate: !1,
                    maxStarvationDelay: 4,
                    maxLoadingDelay: 4,
                    minAutoBitrate: 0,
                    emeEnabled: !1,
                    widevineLicenseUrl: void 0,
                    drmSystems: {},
                    drmSystemOptions: {},
                    requestMediaKeySystemAccessFunc: rt,
                    testBandwidth: !0,
                    progressive: !1,
                    lowLatencyMode: !0,
                    cmcd: void 0,
                    enableDateRangeMetadataCues: !0,
                    enableEmsgMetadataCues: !0,
                    enableID3MetadataCues: !0,
                    useMediaCapabilities: !0,
                    certLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 8e3,
                            maxLoadTimeMs: 2e4,
                            timeoutRetry: null,
                            errorRetry: null
                        }
                    },
                    keyLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 8e3,
                            maxLoadTimeMs: 2e4,
                            timeoutRetry: {
                                maxNumRetry: 1,
                                retryDelayMs: 1e3,
                                maxRetryDelayMs: 2e4,
                                backoff: "linear"
                            },
                            errorRetry: {
                                maxNumRetry: 8,
                                retryDelayMs: 1e3,
                                maxRetryDelayMs: 2e4,
                                backoff: "linear"
                            }
                        }
                    },
                    manifestLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: Infinity,
                            maxLoadTimeMs: 2e4,
                            timeoutRetry: {
                                maxNumRetry: 2,
                                retryDelayMs: 0,
                                maxRetryDelayMs: 0
                            },
                            errorRetry: {
                                maxNumRetry: 1,
                                retryDelayMs: 1e3,
                                maxRetryDelayMs: 8e3
                            }
                        }
                    },
                    playlistLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 1e4,
                            maxLoadTimeMs: 2e4,
                            timeoutRetry: {
                                maxNumRetry: 2,
                                retryDelayMs: 0,
                                maxRetryDelayMs: 0
                            },
                            errorRetry: {
                                maxNumRetry: 2,
                                retryDelayMs: 1e3,
                                maxRetryDelayMs: 8e3
                            }
                        }
                    },
                    fragLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 1e4,
                            maxLoadTimeMs: 12e4,
                            timeoutRetry: {
                                maxNumRetry: 4,
                                retryDelayMs: 0,
                                maxRetryDelayMs: 0
                            },
                            errorRetry: {
                                maxNumRetry: 6,
                                retryDelayMs: 1e3,
                                maxRetryDelayMs: 8e3
                            }
                        }
                    },
                    steeringManifestLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 1e4,
                            maxLoadTimeMs: 2e4,
                            timeoutRetry: {
                                maxNumRetry: 2,
                                retryDelayMs: 0,
                                maxRetryDelayMs: 0
                            },
                            errorRetry: {
                                maxNumRetry: 1,
                                retryDelayMs: 1e3,
                                maxRetryDelayMs: 8e3
                            }
                        }
                    },
                    manifestLoadingTimeOut: 1e4,
                    manifestLoadingMaxRetry: 1,
                    manifestLoadingRetryDelay: 1e3,
                    manifestLoadingMaxRetryTimeout: 64e3,
                    levelLoadingTimeOut: 1e4,
                    levelLoadingMaxRetry: 4,
                    levelLoadingRetryDelay: 1e3,
                    levelLoadingMaxRetryTimeout: 64e3,
                    fragLoadingTimeOut: 2e4,
                    fragLoadingMaxRetry: 6,
                    fragLoadingRetryDelay: 1e3,
                    fragLoadingMaxRetryTimeout: 64e3
                }, {
                    cueHandler: Oa,
                    enableWebVTT: !0,
                    enableIMSC1: !0,
                    enableCEA708Captions: !0,
                    captionsTextTrack1Label: "English",
                    captionsTextTrack1LanguageCode: "en",
                    captionsTextTrack2Label: "Spanish",
                    captionsTextTrack2LanguageCode: "es",
                    captionsTextTrack3Label: "Unknown CC",
                    captionsTextTrack3LanguageCode: "",
                    captionsTextTrack4Label: "Unknown CC",
                    captionsTextTrack4LanguageCode: "",
                    renderTextTracksNatively: !0
                }), {}, {
                    subtitleStreamController: class extends wr {
                        constructor(t, e, i) {
                            super(t, e, i, "[subtitle-stream-controller]", xe), this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this._registerListeners()
                        }
                        onHandlerDestroying() {
                            this._unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null
                        }
                        _registerListeners() {
                            const {
                                hls: t
                            } = this;
                            t.on(T.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(T.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(T.MANIFEST_LOADING, this.onManifestLoading, this), t.on(T.LEVEL_LOADED, this.onLevelLoaded, this), t.on(T.ERROR, this.onError, this), t.on(T.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), t.on(T.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), t.on(T.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), t.on(T.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), t.on(T.BUFFER_FLUSHING, this.onBufferFlushing, this), t.on(T.FRAG_BUFFERED, this.onFragBuffered, this)
                        }
                        _unregisterListeners() {
                            const {
                                hls: t
                            } = this;
                            t.off(T.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(T.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(T.MANIFEST_LOADING, this.onManifestLoading, this), t.off(T.LEVEL_LOADED, this.onLevelLoaded, this), t.off(T.ERROR, this.onError, this), t.off(T.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), t.off(T.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), t.off(T.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), t.off(T.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), t.off(T.BUFFER_FLUSHING, this.onBufferFlushing, this), t.off(T.FRAG_BUFFERED, this.onFragBuffered, this)
                        }
                        startLoad(t) {
                            this.stopLoad(), this.state = pr, this.setInterval(500), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = t, this.tick()
                        }
                        onManifestLoading() {
                            this.mainDetails = null, this.fragmentTracker.removeAllFragments()
                        }
                        onMediaDetaching() {
                            this.tracksBuffered = [], super.onMediaDetaching()
                        }
                        onLevelLoaded(t, e) {
                            this.mainDetails = e.details
                        }
                        onSubtitleFragProcessed(t, e) {
                            const {
                                frag: i,
                                success: r
                            } = e;
                            if (this.fragPrevious = i, this.state = pr, !r) return;
                            const s = this.tracksBuffered[this.currentTrackId];
                            if (!s) return;
                            let n;
                            const a = i.start;
                            for (let t = 0; t < s.length; t++)
                                if (a >= s[t].start && a <= s[t].end) {
                                    n = s[t];
                                    break
                                }
                            const o = i.start + i.duration;
                            n ? n.end = o : (n = {
                                start: a,
                                end: o
                            }, s.push(n)), this.fragmentTracker.fragBuffered(i), this.fragBufferedComplete(i, null)
                        }
                        onBufferFlushing(t, e) {
                            const {
                                startOffset: i,
                                endOffset: r
                            } = e;
                            if (0 === i && r !== Number.POSITIVE_INFINITY) {
                                const t = r - 1;
                                if (t <= 0) return;
                                e.endOffsetSubtitles = Math.max(0, t), this.tracksBuffered.forEach((e => {
                                    for (let i = 0; i < e.length;)
                                        if (e[i].end <= t) e.shift();
                                        else {
                                            if (!(e[i].start < t)) break;
                                            e[i].start = t, i++
                                        }
                                })), this.fragmentTracker.removeFragmentsInRange(i, t, xe)
                            }
                        }
                        onFragBuffered(t, e) {
                            var i;
                            this.loadedmetadata || e.frag.type !== Ie || null != (i = this.media) && i.buffered.length && (this.loadedmetadata = !0)
                        }
                        onError(t, e) {
                            const i = e.frag;
                            (null == i ? void 0 : i.type) === xe && (e.details === S.FRAG_GAP && this.fragmentTracker.fragBuffered(i, !0), this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== mr && (this.state = pr))
                        }
                        onSubtitleTracksUpdated(t, {
                            subtitleTracks: e
                        }) {
                            this.levels && Fs(this.levels, e) ? this.levels = e.map((t => new si(t))) : (this.tracksBuffered = [], this.levels = e.map((t => {
                                const e = new si(t);
                                return this.tracksBuffered[e.id] = [], e
                            })), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, xe), this.fragPrevious = null, this.mediaBuffer = null)
                        }
                        onSubtitleTrackSwitch(t, e) {
                            var i;
                            if (this.currentTrackId = e.id, null == (i = this.levels) || !i.length || -1 === this.currentTrackId) return void this.clearInterval();
                            const r = this.levels[this.currentTrackId];
                            null != r && r.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, r && this.setInterval(500)
                        }
                        onSubtitleTrackLoaded(t, e) {
                            var i;
                            const {
                                currentTrackId: r,
                                levels: s
                            } = this, {
                                details: n,
                                id: a
                            } = e;
                            if (!s) return void this.warn(`Subtitle tracks were reset while loading level ${a}`);
                            const o = s[a];
                            if (a >= s.length || !o) return;
                            this.log(`Subtitle track ${a} loaded [${n.startSN},${n.endSN}]${n.lastPartSn?`[part-${n.lastPartSn}-${n.lastPartIndex}]`:""},duration:${n.totalduration}`), this.mediaBuffer = this.mediaBufferTimeRanges;
                            let l = 0;
                            if (n.live || null != (i = o.details) && i.live) {
                                const t = this.mainDetails;
                                if (n.deltaUpdateFailed || !t) return;
                                const e = t.fragments[0];
                                var u;
                                if (o.details) l = this.alignPlaylists(n, o.details, null == (u = this.levelLastLoaded) ? void 0 : u.details), 0 === l && e && (l = e.start, ci(n, l));
                                else n.hasProgramDateTime && t.hasProgramDateTime ? (sr(n, t), l = n.fragments[0].start) : e && (l = e.start, ci(n, l))
                            }
                            if (o.details = n, this.levelLastLoaded = o, a === r && (this.startFragRequested || !this.mainDetails && n.live || this.setStartPosition(this.mainDetails || n, l), this.tick(), n.live && !this.fragCurrent && this.media && this.state === pr)) {
                                Ei(null, n.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), o.details = void 0)
                            }
                        }
                        _handleFragmentLoadComplete(t) {
                            const {
                                frag: e,
                                payload: i
                            } = t, r = e.decryptdata, s = this.hls;
                            if (!this.fragContextChanged(e) && i && i.byteLength > 0 && null != r && r.key && r.iv && "AES-128" === r.method) {
                                const t = performance.now();
                                this.decrypter.decrypt(new Uint8Array(i), r.key.buffer, r.iv.buffer).catch((t => {
                                    throw s.trigger(T.ERROR, {
                                        type: E.MEDIA_ERROR,
                                        details: S.FRAG_DECRYPT_ERROR,
                                        fatal: !1,
                                        error: t,
                                        reason: t.message,
                                        frag: e
                                    }), t
                                })).then((i => {
                                    const r = performance.now();
                                    s.trigger(T.FRAG_DECRYPTED, {
                                        frag: e,
                                        payload: i,
                                        stats: {
                                            tstart: t,
                                            tdecrypt: r
                                        }
                                    })
                                })).catch((t => {
                                    this.warn(`${t.name}: ${t.message}`), this.state = pr
                                }))
                            }
                        }
                        doTick() {
                            if (this.media) {
                                if (this.state === pr) {
                                    const {
                                        currentTrackId: t,
                                        levels: e
                                    } = this, i = null == e ? void 0 : e[t];
                                    if (!i || !e.length || !i.details) return;
                                    const {
                                        config: r
                                    } = this, s = this.getLoadPosition(), n = Ji.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], s, r.maxBufferHole), {
                                        end: a,
                                        len: o
                                    } = n, l = this.getFwdBufferInfo(this.media, Ie), u = i.details;
                                    if (o > this.getMaxBufferLength(null == l ? void 0 : l.len) + u.levelTargetDuration) return;
                                    const c = u.fragments,
                                        h = c.length,
                                        d = u.edge;
                                    let f = null;
                                    const g = this.fragPrevious;
                                    if (a < d) {
                                        const t = r.maxFragLookUpTolerance,
                                            e = a > d - t ? 0 : t;
                                        f = Ei(g, c, Math.max(c[0].start, a), e), !f && g && g.start < c[0].start && (f = c[0])
                                    } else f = c[h - 1];
                                    if (!f) return;
                                    if (f = this.mapToInitFragWhenRequired(f), "initSegment" !== f.sn) {
                                        const t = c[f.sn - u.startSN - 1];
                                        t && t.cc === f.cc && this.fragmentTracker.getState(t) === Wi && (f = t)
                                    }
                                    this.fragmentTracker.getState(f) === Wi && this.loadFragment(f, i, a)
                                }
                            } else this.state = pr
                        }
                        getMaxBufferLength(t) {
                            const e = super.getMaxBufferLength();
                            return t ? Math.max(e, t) : e
                        }
                        loadFragment(t, e, i) {
                            this.fragCurrent = t, "initSegment" === t.sn ? this._loadInitSegment(t, e) : (this.startFragRequested = !0, super.loadFragment(t, e, i))
                        }
                        get mediaBufferTimeRanges() {
                            return new Us(this.tracksBuffered[this.currentTrackId] || [])
                        }
                    },
                    subtitleTrackController: class extends Ci {
                        constructor(t) {
                            super(t, "[subtitle-track-controller]"), this.media = null, this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.asyncPollTrackChange = () => this.pollTrackChange(0), this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.onTextTracksChanged = () => {
                                if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively) return;
                                let t = null;
                                const e = Ge(this.media.textTracks);
                                for (let i = 0; i < e.length; i++)
                                    if ("hidden" === e[i].mode) t = e[i];
                                    else if ("showing" === e[i].mode) {
                                    t = e[i];
                                    break
                                }
                                const i = this.findTrackForTextTrack(t);
                                this.subtitleTrack !== i && this.setSubtitleTrack(i)
                            }, this.registerListeners()
                        }
                        destroy() {
                            this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, this.onTextTracksChanged = this.asyncPollTrackChange = null, super.destroy()
                        }
                        get subtitleDisplay() {
                            return this._subtitleDisplay
                        }
                        set subtitleDisplay(t) {
                            this._subtitleDisplay = t, this.trackId > -1 && this.toggleTrackModes()
                        }
                        registerListeners() {
                            const {
                                hls: t
                            } = this;
                            t.on(T.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(T.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(T.MANIFEST_LOADING, this.onManifestLoading, this), t.on(T.MANIFEST_PARSED, this.onManifestParsed, this), t.on(T.LEVEL_LOADING, this.onLevelLoading, this), t.on(T.LEVEL_SWITCHING, this.onLevelSwitching, this), t.on(T.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), t.on(T.ERROR, this.onError, this)
                        }
                        unregisterListeners() {
                            const {
                                hls: t
                            } = this;
                            t.off(T.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(T.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(T.MANIFEST_LOADING, this.onManifestLoading, this), t.off(T.MANIFEST_PARSED, this.onManifestParsed, this), t.off(T.LEVEL_LOADING, this.onLevelLoading, this), t.off(T.LEVEL_SWITCHING, this.onLevelSwitching, this), t.off(T.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), t.off(T.ERROR, this.onError, this)
                        }
                        onMediaAttached(t, e) {
                            this.media = e.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange))
                        }
                        pollTrackChange(t) {
                            self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, t)
                        }
                        onMediaDetaching() {
                            if (!this.media) return;
                            self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId);
                            Ge(this.media.textTracks).forEach((t => {
                                Ue(t)
                            })), this.subtitleTrack = -1, this.media = null
                        }
                        onManifestLoading() {
                            this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0
                        }
                        onManifestParsed(t, e) {
                            this.tracks = e.subtitleTracks
                        }
                        onSubtitleTrackLoaded(t, e) {
                            const {
                                id: i,
                                groupId: r,
                                details: s
                            } = e, n = this.tracksInGroup[i];
                            if (!n || n.groupId !== r) return void this.warn(`Subtitle track with id:${i} and group:${r} not found in active group ${null==n?void 0:n.groupId}`);
                            const a = n.details;
                            n.details = e.details, this.log(`Subtitle track ${i} "${n.name}" lang:${n.lang} group:${r} loaded [${s.startSN}-${s.endSN}]`), i === this.trackId && this.playlistLoaded(i, e, a)
                        }
                        onLevelLoading(t, e) {
                            this.switchLevel(e.level)
                        }
                        onLevelSwitching(t, e) {
                            this.switchLevel(e.level)
                        }
                        switchLevel(t) {
                            const e = this.hls.levels[t];
                            if (!e) return;
                            const i = e.subtitleGroups || null,
                                r = this.groupIds;
                            let s = this.currentTrack;
                            if (!i || (null == r ? void 0 : r.length) !== (null == i ? void 0 : i.length) || null != i && i.some((t => -1 === (null == r ? void 0 : r.indexOf(t))))) {
                                this.groupIds = i, this.trackId = -1, this.currentTrack = null;
                                const t = this.tracks.filter((t => !i || -1 !== i.indexOf(t.groupId)));
                                if (t.length) this.selectDefaultTrack && !t.some((t => t.default)) && (this.selectDefaultTrack = !1), t.forEach(((t, e) => {
                                    t.id = e
                                }));
                                else if (!s && !this.tracksInGroup.length) return;
                                this.tracksInGroup = t;
                                const e = this.hls.config.subtitlePreference;
                                if (!s && e) {
                                    this.selectDefaultTrack = !1;
                                    const i = Ui(e, t);
                                    if (i > -1) s = t[i];
                                    else {
                                        const t = Ui(e, this.tracks);
                                        s = this.tracks[t]
                                    }
                                }
                                let r = this.findTrackId(s); - 1 === r && s && (r = this.findTrackId(null));
                                const n = {
                                    subtitleTracks: t
                                };
                                this.log(`Updating subtitle tracks, ${t.length} track(s) found in "${null==i?void 0:i.join(",")}" group-id`), this.hls.trigger(T.SUBTITLE_TRACKS_UPDATED, n), -1 !== r && -1 === this.trackId && this.setSubtitleTrack(r)
                            } else this.shouldReloadPlaylist(s) && this.setSubtitleTrack(this.trackId)
                        }
                        findTrackId(t) {
                            const e = this.tracksInGroup,
                                i = this.selectDefaultTrack;
                            for (let r = 0; r < e.length; r++) {
                                const s = e[r];
                                if ((!i || s.default) && (i || t) && (!t || $i(s, t))) return r
                            }
                            if (t) {
                                for (let i = 0; i < e.length; i++) {
                                    const r = e[i];
                                    if (Ns(t.attrs, r.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) return i
                                }
                                for (let i = 0; i < e.length; i++) {
                                    const r = e[i];
                                    if (Ns(t.attrs, r.attrs, ["LANGUAGE"])) return i
                                }
                            }
                            return -1
                        }
                        findTrackForTextTrack(t) {
                            if (t) {
                                const e = this.tracksInGroup;
                                for (let i = 0; i < e.length; i++) {
                                    if (Bs(e[i], t)) return i
                                }
                            }
                            return -1
                        }
                        onError(t, e) {
                            !e.fatal && e.context && (e.context.type !== Ce || e.context.id !== this.trackId || this.groupIds && -1 === this.groupIds.indexOf(e.context.groupId) || this.checkRetry(e))
                        }
                        get allSubtitleTracks() {
                            return this.tracks
                        }
                        get subtitleTracks() {
                            return this.tracksInGroup
                        }
                        get subtitleTrack() {
                            return this.trackId
                        }
                        set subtitleTrack(t) {
                            this.selectDefaultTrack = !1, this.setSubtitleTrack(t)
                        }
                        setSubtitleOption(t) {
                            if (this.hls.config.subtitlePreference = t, t) {
                                const e = this.allSubtitleTracks;
                                if (this.selectDefaultTrack = !1, e.length) {
                                    const i = this.currentTrack;
                                    if (i && $i(t, i)) return i;
                                    const r = Ui(t, this.tracksInGroup);
                                    if (r > -1) {
                                        const t = this.tracksInGroup[r];
                                        return this.setSubtitleTrack(r), t
                                    }
                                    if (i) return null; {
                                        const i = Ui(t, e);
                                        if (i > -1) return e[i]
                                    }
                                }
                            }
                            return null
                        }
                        loadPlaylist(t) {
                            super.loadPlaylist();
                            const e = this.currentTrack;
                            if (this.shouldLoadPlaylist(e) && e) {
                                const i = e.id,
                                    r = e.groupId;
                                let s = e.url;
                                if (t) try {
                                    s = t.addDirectives(s)
                                } catch (t) {
                                    this.warn(`Could not construct new URL with HLS Delivery Directives: ${t}`)
                                }
                                this.log(`Loading subtitle playlist for id ${i}`), this.hls.trigger(T.SUBTITLE_TRACK_LOADING, {
                                    url: s,
                                    id: i,
                                    groupId: r,
                                    deliveryDirectives: t || null
                                })
                            }
                        }
                        toggleTrackModes() {
                            const {
                                media: t
                            } = this;
                            if (!t) return;
                            const e = Ge(t.textTracks),
                                i = this.currentTrack;
                            let r;
                            if (i && (r = e.filter((t => Bs(i, t)))[0], r || this.warn(`Unable to find subtitle TextTrack with name "${i.name}" and language "${i.lang}"`)), [].slice.call(e).forEach((t => {
                                    "disabled" !== t.mode && t !== r && (t.mode = "disabled")
                                })), r) {
                                const t = this.subtitleDisplay ? "showing" : "hidden";
                                r.mode !== t && (r.mode = t)
                            }
                        }
                        setSubtitleTrack(t) {
                            const e = this.tracksInGroup;
                            if (!this.media) return void(this.queuedDefaultTrack = t);
                            if (t < -1 || t >= e.length || !p(t)) return void this.warn(`Invalid subtitle track id: ${t}`);
                            this.clearTimer(), this.selectDefaultTrack = !1;
                            const i = this.currentTrack,
                                r = e[t] || null;
                            if (this.trackId = t, this.currentTrack = r, this.toggleTrackModes(), !r) return void this.hls.trigger(T.SUBTITLE_TRACK_SWITCH, {
                                id: t
                            });
                            const s = !!r.details && !r.details.live;
                            if (t === this.trackId && r === i && s) return;
                            this.log(`Switching to subtitle-track ${t}` + (r ? ` "${r.name}" lang:${r.lang} group:${r.groupId}` : ""));
                            const {
                                id: n,
                                groupId: a = "",
                                name: o,
                                type: l,
                                url: u
                            } = r;
                            this.hls.trigger(T.SUBTITLE_TRACK_SWITCH, {
                                id: n,
                                groupId: a,
                                name: o,
                                type: l,
                                url: u
                            });
                            const c = this.switchParams(r.url, null == i ? void 0 : i.details, r.details);
                            this.loadPlaylist(c)
                        }
                    },
                    timelineController: class {
                        constructor(t) {
                            this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
                                ccOffset: 0,
                                presentationOffset: 0,
                                0: {
                                    start: 0,
                                    prevCC: -1,
                                    new: !0
                                }
                            }, this.captionsProperties = void 0, this.hls = t, this.config = t.config, this.Cues = t.config.cueHandler, this.captionsProperties = {
                                textTrack1: {
                                    label: this.config.captionsTextTrack1Label,
                                    languageCode: this.config.captionsTextTrack1LanguageCode
                                },
                                textTrack2: {
                                    label: this.config.captionsTextTrack2Label,
                                    languageCode: this.config.captionsTextTrack2LanguageCode
                                },
                                textTrack3: {
                                    label: this.config.captionsTextTrack3Label,
                                    languageCode: this.config.captionsTextTrack3LanguageCode
                                },
                                textTrack4: {
                                    label: this.config.captionsTextTrack4Label,
                                    languageCode: this.config.captionsTextTrack4LanguageCode
                                }
                            }, t.on(T.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(T.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(T.MANIFEST_LOADING, this.onManifestLoading, this), t.on(T.MANIFEST_LOADED, this.onManifestLoaded, this), t.on(T.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), t.on(T.FRAG_LOADING, this.onFragLoading, this), t.on(T.FRAG_LOADED, this.onFragLoaded, this), t.on(T.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), t.on(T.FRAG_DECRYPTED, this.onFragDecrypted, this), t.on(T.INIT_PTS_FOUND, this.onInitPtsFound, this), t.on(T.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), t.on(T.BUFFER_FLUSHING, this.onBufferFlushing, this)
                        }
                        destroy() {
                            const {
                                hls: t
                            } = this;
                            t.off(T.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(T.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(T.MANIFEST_LOADING, this.onManifestLoading, this), t.off(T.MANIFEST_LOADED, this.onManifestLoaded, this), t.off(T.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), t.off(T.FRAG_LOADING, this.onFragLoading, this), t.off(T.FRAG_LOADED, this.onFragLoaded, this), t.off(T.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), t.off(T.FRAG_DECRYPTED, this.onFragDecrypted, this), t.off(T.INIT_PTS_FOUND, this.onInitPtsFound, this), t.off(T.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), t.off(T.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = null, this.cea608Parser1 = this.cea608Parser2 = void 0
                        }
                        initCea608Parsers() {
                            if (this.config.enableCEA708Captions && (!this.cea608Parser1 || !this.cea608Parser2)) {
                                const t = new un(this, "textTrack1"),
                                    e = new un(this, "textTrack2"),
                                    i = new un(this, "textTrack3"),
                                    r = new un(this, "textTrack4");
                                this.cea608Parser1 = new an(1, t, e), this.cea608Parser2 = new an(3, i, r)
                            }
                        }
                        addCues(t, e, i, r, s) {
                            let n = !1;
                            for (let t = s.length; t--;) {
                                const r = s[t],
                                    c = (a = r[0], o = r[1], l = e, u = i, Math.min(o, u) - Math.max(a, l));
                                if (c >= 0 && (r[0] = Math.min(r[0], e), r[1] = Math.max(r[1], i), n = !0, c / (i - e) > .5)) return
                            }
                            var a, o, l, u;
                            if (n || s.push([e, i]), this.config.renderTextTracksNatively) {
                                const s = this.captionsTracks[t];
                                this.Cues.newCue(s, e, i, r)
                            } else {
                                const s = this.Cues.newCue(null, e, i, r);
                                this.hls.trigger(T.CUES_PARSED, {
                                    type: "captions",
                                    cues: s,
                                    track: t
                                })
                            }
                        }
                        onInitPtsFound(t, {
                            frag: e,
                            id: i,
                            initPTS: r,
                            timescale: s
                        }) {
                            const {
                                unparsedVttFrags: n
                            } = this;
                            "main" === i && (this.initPTS[e.cc] = {
                                baseTime: r,
                                timescale: s
                            }), n.length && (this.unparsedVttFrags = [], n.forEach((t => {
                                this.onFragLoaded(T.FRAG_LOADED, t)
                            })))
                        }
                        getExistingTrack(t, e) {
                            const {
                                media: i
                            } = this;
                            if (i)
                                for (let r = 0; r < i.textTracks.length; r++) {
                                    const s = i.textTracks[r];
                                    if (Nn(s, {
                                            name: t,
                                            lang: e,
                                            attrs: {}
                                        })) return s
                                }
                            return null
                        }
                        createCaptionsTrack(t) {
                            this.config.renderTextTracksNatively ? this.createNativeTrack(t) : this.createNonNativeTrack(t)
                        }
                        createNativeTrack(t) {
                            if (this.captionsTracks[t]) return;
                            const {
                                captionsProperties: e,
                                captionsTracks: i,
                                media: r
                            } = this, {
                                label: s,
                                languageCode: n
                            } = e[t], a = this.getExistingTrack(s, n);
                            if (a) i[t] = a, Ue(i[t]), Ne(i[t], r);
                            else {
                                const e = this.createTextTrack("captions", s, n);
                                e && (e[t] = !0, i[t] = e)
                            }
                        }
                        createNonNativeTrack(t) {
                            if (this.nonNativeCaptionsTracks[t]) return;
                            const e = this.captionsProperties[t];
                            if (!e) return;
                            const i = {
                                _id: t,
                                label: e.label,
                                kind: "captions",
                                default: !!e.media && !!e.media.default,
                                closedCaptions: e.media
                            };
                            this.nonNativeCaptionsTracks[t] = i, this.hls.trigger(T.NON_NATIVE_TEXT_TRACKS_FOUND, {
                                tracks: [i]
                            })
                        }
                        createTextTrack(t, e, i) {
                            const r = this.media;
                            if (r) return r.addTextTrack(t, e, i)
                        }
                        onMediaAttaching(t, e) {
                            this.media = e.media, this._cleanTracks()
                        }
                        onMediaDetaching() {
                            const {
                                captionsTracks: t
                            } = this;
                            Object.keys(t).forEach((e => {
                                Ue(t[e]), delete t[e]
                            })), this.nonNativeCaptionsTracks = {}
                        }
                        onManifestLoading() {
                            this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
                                ccOffset: 0,
                                presentationOffset: 0,
                                0: {
                                    start: 0,
                                    prevCC: -1,
                                    new: !0
                                }
                            }, this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset())
                        }
                        _cleanTracks() {
                            const {
                                media: t
                            } = this;
                            if (!t) return;
                            const e = t.textTracks;
                            if (e)
                                for (let t = 0; t < e.length; t++) Ue(e[t])
                        }
                        onSubtitleTracksUpdated(t, e) {
                            const i = e.subtitleTracks || [],
                                r = i.some((t => t.textCodec === kn));
                            if (this.config.enableWebVTT || r && this.config.enableIMSC1) {
                                if (Fs(this.tracks, i)) return void(this.tracks = i);
                                if (this.textTracks = [], this.tracks = i, this.config.renderTextTracksNatively) {
                                    const t = this.media,
                                        e = t ? Ge(t.textTracks) : null;
                                    if (this.tracks.forEach(((t, i) => {
                                            let r;
                                            if (e) {
                                                let i = null;
                                                for (let r = 0; r < e.length; r++)
                                                    if (e[r] && Nn(e[r], t)) {
                                                        i = e[r], e[r] = null;
                                                        break
                                                    }
                                                i && (r = i)
                                            }
                                            if (r) Ue(r);
                                            else {
                                                const e = Fn(t);
                                                r = this.createTextTrack(e, t.name, t.lang), r && (r.mode = "disabled")
                                            }
                                            r && this.textTracks.push(r)
                                        })), null != e && e.length) {
                                        const t = e.filter((t => null !== t)).map((t => t.label));
                                        t.length && R.warn(`Media element contains unused subtitle tracks: ${t.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`)
                                    }
                                } else if (this.tracks.length) {
                                    const t = this.tracks.map((t => ({
                                        label: t.name,
                                        kind: t.type.toLowerCase(),
                                        default: t.default,
                                        subtitleTrack: t
                                    })));
                                    this.hls.trigger(T.NON_NATIVE_TEXT_TRACKS_FOUND, {
                                        tracks: t
                                    })
                                }
                            }
                        }
                        onManifestLoaded(t, e) {
                            this.config.enableCEA708Captions && e.captions && e.captions.forEach((t => {
                                const e = /(?:CC|SERVICE)([1-4])/.exec(t.instreamId);
                                if (!e) return;
                                const i = `textTrack${e[1]}`,
                                    r = this.captionsProperties[i];
                                r && (r.label = t.name, t.lang && (r.languageCode = t.lang), r.media = t)
                            }))
                        }
                        closedCaptionsForLevel(t) {
                            const e = this.hls.levels[t.level];
                            return null == e ? void 0 : e.attrs["CLOSED-CAPTIONS"]
                        }
                        onFragLoading(t, e) {
                            if (this.enabled && e.frag.type === Ie) {
                                var i, r;
                                const {
                                    cea608Parser1: t,
                                    cea608Parser2: s,
                                    lastSn: n
                                } = this, {
                                    cc: a,
                                    sn: o
                                } = e.frag, l = null != (i = null == (r = e.part) ? void 0 : r.index) ? i : -1;
                                t && s && (o !== n + 1 || o === n && l !== this.lastPartIndex + 1 || a !== this.lastCc) && (t.reset(), s.reset()), this.lastCc = a, this.lastSn = o, this.lastPartIndex = l
                            }
                        }
                        onFragLoaded(t, e) {
                            const {
                                frag: i,
                                payload: r
                            } = e;
                            if (i.type === xe)
                                if (r.byteLength) {
                                    const t = i.decryptdata,
                                        s = "stats" in e;
                                    if (null == t || !t.encrypted || s) {
                                        const t = this.tracks[i.level],
                                            s = this.vttCCs;
                                        s[i.cc] || (s[i.cc] = {
                                            start: i.start,
                                            prevCC: this.prevCC,
                                            new: !0
                                        }, this.prevCC = i.cc), t && t.textCodec === kn ? this._parseIMSC1(i, r) : this._parseVTTs(e)
                                    }
                                } else this.hls.trigger(T.SUBTITLE_FRAG_PROCESSED, {
                                    success: !1,
                                    frag: i,
                                    error: new Error("Empty subtitle payload")
                                })
                        }
                        _parseIMSC1(t, e) {
                            const i = this.hls;
                            Dn(e, this.initPTS[t.cc], (e => {
                                this._appendCues(e, t.level), i.trigger(T.SUBTITLE_FRAG_PROCESSED, {
                                    success: !0,
                                    frag: t
                                })
                            }), (e => {
                                R.log(`Failed to parse IMSC1: ${e}`), i.trigger(T.SUBTITLE_FRAG_PROCESSED, {
                                    success: !1,
                                    frag: t,
                                    error: e
                                })
                            }))
                        }
                        _parseVTTs(t) {
                            var e;
                            const {
                                frag: i,
                                payload: r
                            } = t, {
                                initPTS: s,
                                unparsedVttFrags: n
                            } = this, a = s.length - 1;
                            if (!s[i.cc] && -1 === a) return void n.push(t);
                            const o = this.hls;
                            Ln(null != (e = i.initSegment) && e.data ? Ht(i.initSegment.data, new Uint8Array(r)) : r, this.initPTS[i.cc], this.vttCCs, i.cc, i.start, (t => {
                                this._appendCues(t, i.level), o.trigger(T.SUBTITLE_FRAG_PROCESSED, {
                                    success: !0,
                                    frag: i
                                })
                            }), (e => {
                                const s = "Missing initPTS for VTT MPEGTS" === e.message;
                                s ? n.push(t) : this._fallbackToIMSC1(i, r), R.log(`Failed to parse VTT cue: ${e}`), s && a > i.cc || o.trigger(T.SUBTITLE_FRAG_PROCESSED, {
                                    success: !1,
                                    frag: i,
                                    error: e
                                })
                            }))
                        }
                        _fallbackToIMSC1(t, e) {
                            const i = this.tracks[t.level];
                            i.textCodec || Dn(e, this.initPTS[t.cc], (() => {
                                i.textCodec = kn, this._parseIMSC1(t, e)
                            }), (() => {
                                i.textCodec = "wvtt"
                            }))
                        }
                        _appendCues(t, e) {
                            const i = this.hls;
                            if (this.config.renderTextTracksNatively) {
                                const i = this.textTracks[e];
                                if (!i || "disabled" === i.mode) return;
                                t.forEach((t => Be(i, t)))
                            } else {
                                const r = this.tracks[e];
                                if (!r) return;
                                const s = r.default ? "default" : "subtitles" + e;
                                i.trigger(T.CUES_PARSED, {
                                    type: "subtitles",
                                    cues: t,
                                    track: s
                                })
                            }
                        }
                        onFragDecrypted(t, e) {
                            const {
                                frag: i
                            } = e;
                            i.type === xe && this.onFragLoaded(T.FRAG_LOADED, e)
                        }
                        onSubtitleTracksCleared() {
                            this.tracks = [], this.captionsTracks = {}
                        }
                        onFragParsingUserdata(t, e) {
                            this.initCea608Parsers();
                            const {
                                cea608Parser1: i,
                                cea608Parser2: r
                            } = this;
                            if (!this.enabled || !i || !r) return;
                            const {
                                frag: s,
                                samples: n
                            } = e;
                            if (s.type !== Ie || "NONE" !== this.closedCaptionsForLevel(s))
                                for (let t = 0; t < n.length; t++) {
                                    const e = n[t].bytes;
                                    if (e) {
                                        const s = this.extractCea608Data(e);
                                        i.addData(n[t].pts, s[0]), r.addData(n[t].pts, s[1])
                                    }
                                }
                        }
                        onBufferFlushing(t, {
                            startOffset: e,
                            endOffset: i,
                            endOffsetSubtitles: r,
                            type: s
                        }) {
                            const {
                                media: n
                            } = this;
                            if (n && !(n.currentTime < i)) {
                                if (!s || "video" === s) {
                                    const {
                                        captionsTracks: t
                                    } = this;
                                    Object.keys(t).forEach((r => $e(t[r], e, i)))
                                }
                                if (this.config.renderTextTracksNatively && 0 === e && void 0 !== r) {
                                    const {
                                        textTracks: t
                                    } = this;
                                    Object.keys(t).forEach((i => $e(t[i], e, r)))
                                }
                            }
                        }
                        extractCea608Data(t) {
                            const e = [
                                    [],
                                    []
                                ],
                                i = 31 & t[0];
                            let r = 2;
                            for (let s = 0; s < i; s++) {
                                const i = t[r++],
                                    s = 127 & t[r++],
                                    n = 127 & t[r++];
                                if (0 === s && 0 === n) continue;
                                if (!!(4 & i)) {
                                    const t = 3 & i;
                                    0 !== t && 1 !== t || (e[t].push(s), e[t].push(n))
                                }
                            }
                            return e
                        }
                    },
                    audioStreamController: class extends wr {
                        constructor(t, e, i) {
                            super(t, e, i, "[audio-stream-controller]", Pe), this.videoBuffer = null, this.videoTrackCC = -1, this.waitingVideoCC = -1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.flushing = !1, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this._registerListeners()
                        }
                        onHandlerDestroying() {
                            this._unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null, this.bufferedTrack = null, this.switchingTrack = null
                        }
                        _registerListeners() {
                            const {
                                hls: t
                            } = this;
                            t.on(T.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(T.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(T.MANIFEST_LOADING, this.onManifestLoading, this), t.on(T.LEVEL_LOADED, this.onLevelLoaded, this), t.on(T.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), t.on(T.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.on(T.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), t.on(T.ERROR, this.onError, this), t.on(T.BUFFER_RESET, this.onBufferReset, this), t.on(T.BUFFER_CREATED, this.onBufferCreated, this), t.on(T.BUFFER_FLUSHING, this.onBufferFlushing, this), t.on(T.BUFFER_FLUSHED, this.onBufferFlushed, this), t.on(T.INIT_PTS_FOUND, this.onInitPtsFound, this), t.on(T.FRAG_BUFFERED, this.onFragBuffered, this)
                        }
                        _unregisterListeners() {
                            const {
                                hls: t
                            } = this;
                            t.off(T.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(T.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(T.MANIFEST_LOADING, this.onManifestLoading, this), t.off(T.LEVEL_LOADED, this.onLevelLoaded, this), t.off(T.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), t.off(T.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.off(T.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), t.off(T.ERROR, this.onError, this), t.off(T.BUFFER_RESET, this.onBufferReset, this), t.off(T.BUFFER_CREATED, this.onBufferCreated, this), t.off(T.BUFFER_FLUSHING, this.onBufferFlushing, this), t.off(T.BUFFER_FLUSHED, this.onBufferFlushed, this), t.off(T.INIT_PTS_FOUND, this.onInitPtsFound, this), t.off(T.FRAG_BUFFERED, this.onFragBuffered, this)
                        }
                        onInitPtsFound(t, {
                            frag: e,
                            id: i,
                            initPTS: r,
                            timescale: s
                        }) {
                            if ("main" === i) {
                                const t = e.cc;
                                this.initPTS[e.cc] = {
                                    baseTime: r,
                                    timescale: s
                                }, this.log(`InitPTS for cc: ${t} found from main: ${r}`), this.videoTrackCC = t, this.state === kr && this.tick()
                            }
                        }
                        startLoad(t) {
                            if (!this.levels) return this.startPosition = t, void(this.state = mr);
                            const e = this.lastCurrentTime;
                            this.stopLoad(), this.setInterval(100), e > 0 && -1 === t ? (this.log(`Override startPosition with lastCurrentTime @${e.toFixed(3)}`), t = e, this.state = pr) : (this.loadedmetadata = !1, this.state = Er), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = t, this.tick()
                        }
                        doTick() {
                            switch (this.state) {
                                case pr:
                                    this.doTickIdle();
                                    break;
                                case Er:
                                    {
                                        var t;
                                        const {
                                            levels: e,
                                            trackId: i
                                        } = this,
                                        r = null == e || null == (t = e[i]) ? void 0 : t.details;
                                        if (r) {
                                            if (this.waitForCdnTuneIn(r)) break;
                                            this.state = kr
                                        }
                                        break
                                    }
                                case Tr:
                                    {
                                        var e;
                                        const t = performance.now(),
                                            i = this.retryDate;
                                        if (!i || t >= i || null != (e = this.media) && e.seeking) {
                                            const {
                                                levels: t,
                                                trackId: e
                                            } = this;
                                            this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded((null == t ? void 0 : t[e]) || null), this.state = pr
                                        }
                                        break
                                    }
                                case kr:
                                    {
                                        const t = this.waitingData;
                                        if (t) {
                                            const {
                                                frag: e,
                                                part: i,
                                                cache: r,
                                                complete: s
                                            } = t;
                                            if (void 0 !== this.initPTS[e.cc]) {
                                                this.waitingData = null, this.waitingVideoCC = -1, this.state = yr;
                                                const t = {
                                                    frag: e,
                                                    part: i,
                                                    payload: r.flush(),
                                                    networkDetails: null
                                                };
                                                this._handleFragmentLoadProgress(t), s && super._handleFragmentLoadComplete(t)
                                            } else if (this.videoTrackCC !== this.waitingVideoCC) this.log(`Waiting fragment cc (${e.cc}) cancelled because video is at cc ${this.videoTrackCC}`), this.clearWaitingFragment();
                                            else {
                                                const t = this.getLoadPosition(),
                                                    i = Ji.bufferInfo(this.mediaBuffer, t, this.config.maxBufferHole);
                                                Si(i.end, this.config.maxFragLookUpTolerance, e) < 0 && (this.log(`Waiting fragment cc (${e.cc}) @ ${e.start} cancelled because another fragment at ${i.end} is needed`), this.clearWaitingFragment())
                                            }
                                        } else this.state = pr
                                    }
                            }
                            this.onTickEnd()
                        }
                        clearWaitingFragment() {
                            const t = this.waitingData;
                            t && (this.fragmentTracker.removeFragment(t.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = pr)
                        }
                        resetLoadingState() {
                            this.clearWaitingFragment(), super.resetLoadingState()
                        }
                        onTickEnd() {
                            const {
                                media: t
                            } = this;
                            null != t && t.readyState && (this.lastCurrentTime = t.currentTime)
                        }
                        doTickIdle() {
                            const {
                                hls: t,
                                levels: e,
                                media: i,
                                trackId: r
                            } = this, s = t.config;
                            if (!i && (this.startFragRequested || !s.startFragPrefetch) || null == e || !e[r]) return;
                            const n = e[r],
                                a = n.details;
                            if (!a || a.live && this.levelLastLoaded !== n || this.waitForCdnTuneIn(a)) return void(this.state = Er);
                            const o = this.mediaBuffer ? this.mediaBuffer : this.media;
                            this.bufferFlushed && o && (this.bufferFlushed = !1, this.afterBufferFlushed(o, x, Pe));
                            const l = this.getFwdBufferInfo(o, Pe);
                            if (null === l) return;
                            const {
                                bufferedTrack: u,
                                switchingTrack: c
                            } = this;
                            if (!c && this._streamEnded(l, a)) return t.trigger(T.BUFFER_EOS, {
                                type: "audio"
                            }), void(this.state = Ar);
                            const h = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, Ie),
                                d = l.len,
                                f = this.getMaxBufferLength(null == h ? void 0 : h.len),
                                g = a.fragments,
                                m = g[0].start;
                            let p = this.flushing ? this.getLoadPosition() : l.end;
                            if (c && i) {
                                const t = this.getLoadPosition();
                                u && !Ns(c.attrs, u.attrs) && (p = t), a.PTSKnown && t < m && (l.end > m || l.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), i.currentTime = m + .05)
                            }
                            if (d >= f && !c && p < g[g.length - 1].start) return;
                            let v = this.getNextFragment(p, a),
                                y = !1;
                            if (v && this.isLoopLoading(v, p) && (y = !!v.gap, v = this.getNextFragmentLoopLoading(v, a, l, Ie, f)), !v) return void(this.bufferFlushed = !0);
                            const E = h && v.start > h.end + a.targetduration;
                            if (E || (null == h || !h.len) && l.len) {
                                const t = this.getAppendedFrag(v.start, Ie);
                                if (null === t) return;
                                if (y || (y = !!t.gap || !!E && 0 === h.len), E && !y || y && l.nextStart && l.nextStart < t.end) return
                            }
                            this.loadFragment(v, n, p)
                        }
                        getMaxBufferLength(t) {
                            const e = super.getMaxBufferLength();
                            return t ? Math.min(Math.max(e, t), this.config.maxMaxBufferLength) : e
                        }
                        onMediaDetaching() {
                            this.videoBuffer = null, this.bufferFlushed = this.flushing = !1, super.onMediaDetaching()
                        }
                        onAudioTracksUpdated(t, {
                            audioTracks: e
                        }) {
                            this.resetTransmuxer(), this.levels = e.map((t => new si(t)))
                        }
                        onAudioTrackSwitching(t, e) {
                            const i = !!e.url;
                            this.trackId = e.id;
                            const {
                                fragCurrent: r
                            } = this;
                            r && (r.abortRequests(), this.removeUnbufferedFrags(r.start)), this.resetLoadingState(), i ? this.setInterval(100) : this.resetTransmuxer(), i ? (this.switchingTrack = e, this.state = pr, this.flushAudioIfNeeded(e)) : (this.switchingTrack = null, this.bufferedTrack = e, this.state = mr), this.tick()
                        }
                        onManifestLoading() {
                            this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = this.flushing = !1, this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null, this.startFragRequested = !1, this.trackId = this.videoTrackCC = this.waitingVideoCC = -1
                        }
                        onLevelLoaded(t, e) {
                            this.mainDetails = e.details, null !== this.cachedTrackLoadedData && (this.hls.trigger(T.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData), this.cachedTrackLoadedData = null)
                        }
                        onAudioTrackLoaded(t, e) {
                            var i;
                            if (null == this.mainDetails) return void(this.cachedTrackLoadedData = e);
                            const {
                                levels: r
                            } = this, {
                                details: s,
                                id: n
                            } = e;
                            if (!r) return void this.warn(`Audio tracks were reset while loading level ${n}`);
                            this.log(`Audio track ${n} loaded [${s.startSN},${s.endSN}]${s.lastPartSn?`[part-${s.lastPartSn}-${s.lastPartIndex}]`:""},duration:${s.totalduration}`);
                            const a = r[n];
                            let o = 0;
                            if (s.live || null != (i = a.details) && i.live) {
                                this.checkLiveUpdate(s);
                                const t = this.mainDetails;
                                if (s.deltaUpdateFailed || !t) return;
                                var l;
                                if (!a.details && s.hasProgramDateTime && t.hasProgramDateTime) sr(s, t), o = s.fragments[0].start;
                                else o = this.alignPlaylists(s, a.details, null == (l = this.levelLastLoaded) ? void 0 : l.details)
                            }
                            a.details = s, this.levelLastLoaded = a, this.startFragRequested || !this.mainDetails && s.live || this.setStartPosition(this.mainDetails || s, o), this.state !== Er || this.waitForCdnTuneIn(s) || (this.state = pr), this.tick()
                        }
                        _handleFragmentLoadProgress(t) {
                            var e;
                            const {
                                frag: i,
                                part: r,
                                payload: s
                            } = t, {
                                config: n,
                                trackId: a,
                                levels: o
                            } = this;
                            if (!o) return void this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`);
                            const l = o[a];
                            if (!l) return void this.warn("Audio track is undefined on fragment load progress");
                            const u = l.details;
                            if (!u) return this.warn("Audio track details undefined on fragment load progress"), void this.removeUnbufferedFrags(i.start);
                            const c = n.defaultAudioCodec || l.audioCodec || "mp4a.40.2";
                            let h = this.transmuxer;
                            h || (h = this.transmuxer = new Os(this.hls, Pe, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
                            const d = this.initPTS[i.cc],
                                f = null == (e = i.initSegment) ? void 0 : e.data;
                            if (void 0 !== d) {
                                const t = !1,
                                    e = r ? r.index : -1,
                                    n = -1 !== e,
                                    a = new Zi(i.level, i.sn, i.stats.chunkCount, s.byteLength, e, n);
                                h.push(s, f, c, "", i, r, u.totalduration, t, a, d)
                            } else {
                                this.log(`Unknown video PTS for cc ${i.cc}, waiting for video PTS before demuxing audio frag ${i.sn} of [${u.startSN} ,${u.endSN}],track ${a}`);
                                const {
                                    cache: t
                                } = this.waitingData = this.waitingData || {
                                    frag: i,
                                    part: r,
                                    cache: new _r,
                                    complete: !1
                                };
                                t.push(new Uint8Array(s)), this.waitingVideoCC = this.videoTrackCC, this.state = kr
                            }
                        }
                        _handleFragmentLoadComplete(t) {
                            this.waitingData ? this.waitingData.complete = !0 : super._handleFragmentLoadComplete(t)
                        }
                        onBufferReset() {
                            this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1
                        }
                        onBufferCreated(t, e) {
                            const i = e.tracks.audio;
                            i && (this.mediaBuffer = i.buffer || null), e.tracks.video && (this.videoBuffer = e.tracks.video.buffer || null)
                        }
                        onFragBuffered(t, e) {
                            const {
                                frag: i,
                                part: r
                            } = e;
                            if (i.type === Pe)
                                if (this.fragContextChanged(i)) this.warn(`Fragment ${i.sn}${r?" p: "+r.index:""} of level ${i.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack?this.switchingTrack.name:"false"}`);
                                else {
                                    if ("initSegment" !== i.sn) {
                                        this.fragPrevious = i;
                                        const t = this.switchingTrack;
                                        t && (this.bufferedTrack = t, this.switchingTrack = null, this.hls.trigger(T.AUDIO_TRACK_SWITCHED, d({}, t)))
                                    }
                                    this.fragBufferedComplete(i, r)
                                }
                            else if (!this.loadedmetadata && i.type === Ie) {
                                const t = this.videoBuffer || this.media;
                                if (t) {
                                    Ji.getBuffered(t).length && (this.loadedmetadata = !0)
                                }
                            }
                        }
                        onError(t, e) {
                            var i;
                            if (e.fatal) this.state = Lr;
                            else switch (e.details) {
                                case S.FRAG_GAP:
                                case S.FRAG_PARSING_ERROR:
                                case S.FRAG_DECRYPT_ERROR:
                                case S.FRAG_LOAD_ERROR:
                                case S.FRAG_LOAD_TIMEOUT:
                                case S.KEY_LOAD_ERROR:
                                case S.KEY_LOAD_TIMEOUT:
                                    this.onFragmentOrKeyLoadError(Pe, e);
                                    break;
                                case S.AUDIO_TRACK_LOAD_ERROR:
                                case S.AUDIO_TRACK_LOAD_TIMEOUT:
                                case S.LEVEL_PARSING_ERROR:
                                    e.levelRetry || this.state !== Er || (null == (i = e.context) ? void 0 : i.type) !== De || (this.state = pr);
                                    break;
                                case S.BUFFER_APPEND_ERROR:
                                case S.BUFFER_FULL_ERROR:
                                    if (!e.parent || "audio" !== e.parent) return;
                                    if (e.details === S.BUFFER_APPEND_ERROR) return void this.resetLoadingState();
                                    this.reduceLengthAndFlushBuffer(e) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
                                    break;
                                case S.INTERNAL_EXCEPTION:
                                    this.recoverWorkerError(e)
                            }
                        }
                        onBufferFlushing(t, {
                            type: e
                        }) {
                            e !== M && (this.flushing = !0)
                        }
                        onBufferFlushed(t, {
                            type: e
                        }) {
                            if (e !== M) {
                                this.flushing = !1, this.bufferFlushed = !0, this.state === Ar && (this.state = pr);
                                const t = this.mediaBuffer || this.media;
                                t && (this.afterBufferFlushed(t, e, Pe), this.tick())
                            }
                        }
                        _handleTransmuxComplete(t) {
                            var e;
                            const i = "audio",
                                {
                                    hls: r
                                } = this,
                                {
                                    remuxResult: s,
                                    chunkMeta: n
                                } = t,
                                a = this.getCurrentContext(n);
                            if (!a) return void this.resetWhenMissingContext(n);
                            const {
                                frag: o,
                                part: l,
                                level: u
                            } = a, {
                                details: c
                            } = u, {
                                audio: h,
                                text: d,
                                id3: f,
                                initSegment: g
                            } = s;
                            if (!this.fragContextChanged(o) && c) {
                                if (this.state = Sr, this.switchingTrack && h && this.completeAudioSwitch(this.switchingTrack), null != g && g.tracks) {
                                    const t = o.initSegment || o;
                                    this._bufferInitSegment(u, g.tracks, t, n), r.trigger(T.FRAG_PARSING_INIT_SEGMENT, {
                                        frag: t,
                                        id: i,
                                        tracks: g.tracks
                                    })
                                }
                                if (h) {
                                    const {
                                        startPTS: t,
                                        endPTS: e,
                                        startDTS: i,
                                        endDTS: r
                                    } = h;
                                    l && (l.elementaryStreams[x] = {
                                        startPTS: t,
                                        endPTS: e,
                                        startDTS: i,
                                        endDTS: r
                                    }), o.setElementaryStreamInfo(x, t, e, i, r), this.bufferFragmentData(h, o, l, n)
                                }
                                if (null != f && null != (e = f.samples) && e.length) {
                                    const t = m({
                                        id: i,
                                        frag: o,
                                        details: c
                                    }, f);
                                    r.trigger(T.FRAG_PARSING_METADATA, t)
                                }
                                if (d) {
                                    const t = m({
                                        id: i,
                                        frag: o,
                                        details: c
                                    }, d);
                                    r.trigger(T.FRAG_PARSING_USERDATA, t)
                                }
                            } else this.fragmentTracker.removeFragment(o)
                        }
                        _bufferInitSegment(t, e, i, r) {
                            if (this.state !== Sr) return;
                            e.video && delete e.video;
                            const s = e.audio;
                            if (!s) return;
                            s.id = "audio";
                            const n = t.audioCodec;
                            this.log(`Init audio buffer, container:${s.container}, codecs[level/parsed]=[${n}/${s.codec}]`), n && 1 === n.split(",").length && (s.levelCodec = n), this.hls.trigger(T.BUFFER_CODECS, e);
                            const a = s.initSegment;
                            if (null != a && a.byteLength) {
                                const t = {
                                    type: "audio",
                                    frag: i,
                                    part: null,
                                    chunkMeta: r,
                                    parent: i.type,
                                    data: a
                                };
                                this.hls.trigger(T.BUFFER_APPENDING, t)
                            }
                            this.tickImmediate()
                        }
                        loadFragment(t, e, i) {
                            const r = this.fragmentTracker.getState(t);
                            var s;
                            if (this.fragCurrent = t, this.switchingTrack || r === Wi || r === ji)
                                if ("initSegment" === t.sn) this._loadInitSegment(t, e);
                                else if (null != (s = e.details) && s.live && !this.initPTS[t.cc]) {
                                this.log(`Waiting for video PTS in continuity counter ${t.cc} of live stream before loading audio fragment ${t.sn} of level ${this.trackId}`), this.state = kr;
                                const i = this.mainDetails;
                                i && i.fragments[0].start !== e.details.fragments[0].start && sr(e.details, i)
                            } else this.startFragRequested = !0, super.loadFragment(t, e, i);
                            else this.clearTrackerIfNeeded(t)
                        }
                        flushAudioIfNeeded(t) {
                            const {
                                media: e,
                                bufferedTrack: i
                            } = this, r = null == i ? void 0 : i.attrs, s = t.attrs;
                            e && r && (r.CHANNELS !== s.CHANNELS || i.name !== t.name || i.lang !== t.lang) && (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"), this.bufferedTrack = null)
                        }
                        completeAudioSwitch(t) {
                            const {
                                hls: e
                            } = this;
                            this.flushAudioIfNeeded(t), this.bufferedTrack = t, this.switchingTrack = null, e.trigger(T.AUDIO_TRACK_SWITCHED, d({}, t))
                        }
                    },
                    audioTrackController: class extends Ci {
                        constructor(t) {
                            super(t, "[audio-track-controller]"), this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners()
                        }
                        registerListeners() {
                            const {
                                hls: t
                            } = this;
                            t.on(T.MANIFEST_LOADING, this.onManifestLoading, this), t.on(T.MANIFEST_PARSED, this.onManifestParsed, this), t.on(T.LEVEL_LOADING, this.onLevelLoading, this), t.on(T.LEVEL_SWITCHING, this.onLevelSwitching, this), t.on(T.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), t.on(T.ERROR, this.onError, this)
                        }
                        unregisterListeners() {
                            const {
                                hls: t
                            } = this;
                            t.off(T.MANIFEST_LOADING, this.onManifestLoading, this), t.off(T.MANIFEST_PARSED, this.onManifestParsed, this), t.off(T.LEVEL_LOADING, this.onLevelLoading, this), t.off(T.LEVEL_SWITCHING, this.onLevelSwitching, this), t.off(T.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), t.off(T.ERROR, this.onError, this)
                        }
                        destroy() {
                            this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy()
                        }
                        onManifestLoading() {
                            this.tracks = [], this.tracksInGroup = [], this.groupIds = null, this.currentTrack = null, this.trackId = -1, this.selectDefaultTrack = !0
                        }
                        onManifestParsed(t, e) {
                            this.tracks = e.audioTracks || []
                        }
                        onAudioTrackLoaded(t, e) {
                            const {
                                id: i,
                                groupId: r,
                                details: s
                            } = e, n = this.tracksInGroup[i];
                            if (!n || n.groupId !== r) return void this.warn(`Audio track with id:${i} and group:${r} not found in active group ${null==n?void 0:n.groupId}`);
                            const a = n.details;
                            n.details = e.details, this.log(`Audio track ${i} "${n.name}" lang:${n.lang} group:${r} loaded [${s.startSN}-${s.endSN}]`), i === this.trackId && this.playlistLoaded(i, e, a)
                        }
                        onLevelLoading(t, e) {
                            this.switchLevel(e.level)
                        }
                        onLevelSwitching(t, e) {
                            this.switchLevel(e.level)
                        }
                        switchLevel(t) {
                            const e = this.hls.levels[t];
                            if (!e) return;
                            const i = e.audioGroups || null,
                                r = this.groupIds;
                            let s = this.currentTrack;
                            if (!i || (null == r ? void 0 : r.length) !== (null == i ? void 0 : i.length) || null != i && i.some((t => -1 === (null == r ? void 0 : r.indexOf(t))))) {
                                this.groupIds = i, this.trackId = -1, this.currentTrack = null;
                                const t = this.tracks.filter((t => !i || -1 !== i.indexOf(t.groupId)));
                                if (t.length) this.selectDefaultTrack && !t.some((t => t.default)) && (this.selectDefaultTrack = !1), t.forEach(((t, e) => {
                                    t.id = e
                                }));
                                else if (!s && !this.tracksInGroup.length) return;
                                this.tracksInGroup = t;
                                const e = this.hls.config.audioPreference;
                                if (!s && e) {
                                    const i = Ui(e, t, Gi);
                                    if (i > -1) s = t[i];
                                    else {
                                        const t = Ui(e, this.tracks);
                                        s = this.tracks[t]
                                    }
                                }
                                let r = this.findTrackId(s); - 1 === r && s && (r = this.findTrackId(null));
                                const a = {
                                    audioTracks: t
                                };
                                this.log(`Updating audio tracks, ${t.length} track(s) found in group(s): ${null==i?void 0:i.join(",")}`), this.hls.trigger(T.AUDIO_TRACKS_UPDATED, a);
                                const o = this.trackId;
                                if (-1 !== r && -1 === o) this.setAudioTrack(r);
                                else if (t.length && -1 === o) {
                                    var n;
                                    const e = new Error(`No audio track selected for current audio group-ID(s): ${null==(n=this.groupIds)?void 0:n.join(",")} track count: ${t.length}`);
                                    this.warn(e.message), this.hls.trigger(T.ERROR, {
                                        type: E.MEDIA_ERROR,
                                        details: S.AUDIO_TRACK_LOAD_ERROR,
                                        fatal: !0,
                                        error: e
                                    })
                                }
                            } else this.shouldReloadPlaylist(s) && this.setAudioTrack(this.trackId)
                        }
                        onError(t, e) {
                            !e.fatal && e.context && (e.context.type !== De || e.context.id !== this.trackId || this.groupIds && -1 === this.groupIds.indexOf(e.context.groupId) || (this.requestScheduled = -1, this.checkRetry(e)))
                        }
                        get allAudioTracks() {
                            return this.tracks
                        }
                        get audioTracks() {
                            return this.tracksInGroup
                        }
                        get audioTrack() {
                            return this.trackId
                        }
                        set audioTrack(t) {
                            this.selectDefaultTrack = !1, this.setAudioTrack(t)
                        }
                        setAudioOption(t) {
                            const e = this.hls;
                            if (e.config.audioPreference = t, t) {
                                const i = this.allAudioTracks;
                                if (this.selectDefaultTrack = !1, i.length) {
                                    const r = this.currentTrack;
                                    if (r && $i(t, r, Gi)) return r;
                                    const s = Ui(t, this.tracksInGroup, Gi);
                                    if (s > -1) {
                                        const t = this.tracksInGroup[s];
                                        return this.setAudioTrack(s), t
                                    }
                                    if (r) {
                                        let r = e.loadLevel; - 1 === r && (r = e.firstAutoLevel);
                                        const s = function(t, e, i, r, s) {
                                            const n = e[r],
                                                a = e.reduce(((t, e, i) => {
                                                    const r = e.uri;
                                                    return (t[r] || (t[r] = [])).push(i), t
                                                }), {})[n.uri];
                                            a.length > 1 && (r = Math.max.apply(Math, a));
                                            const o = n.videoRange,
                                                l = n.frameRate,
                                                u = n.codecSet.substring(0, 4),
                                                c = Hi(e, r, (e => {
                                                    if (e.videoRange !== o || e.frameRate !== l || e.codecSet.substring(0, 4) !== u) return !1;
                                                    const r = e.audioGroups,
                                                        n = i.filter((t => !r || -1 !== r.indexOf(t.groupId)));
                                                    return Ui(t, n, s) > -1
                                                }));
                                            return c > -1 ? c : Hi(e, r, (e => {
                                                const r = e.audioGroups,
                                                    n = i.filter((t => !r || -1 !== r.indexOf(t.groupId)));
                                                return Ui(t, n, s) > -1
                                            }))
                                        }(t, e.levels, i, r, Gi);
                                        if (-1 === s) return null;
                                        e.nextLoadLevel = s
                                    }
                                    if (t.channels || t.audioCodec) {
                                        const e = Ui(t, i);
                                        if (e > -1) return i[e]
                                    }
                                }
                            }
                            return null
                        }
                        setAudioTrack(t) {
                            const e = this.tracksInGroup;
                            if (t < 0 || t >= e.length) return void this.warn(`Invalid audio track id: ${t}`);
                            this.clearTimer(), this.selectDefaultTrack = !1;
                            const i = this.currentTrack,
                                r = e[t],
                                s = r.details && !r.details.live;
                            if (t === this.trackId && r === i && s) return;
                            if (this.log(`Switching to audio-track ${t} "${r.name}" lang:${r.lang} group:${r.groupId} channels:${r.channels}`), this.trackId = t, this.currentTrack = r, this.hls.trigger(T.AUDIO_TRACK_SWITCHING, d({}, r)), s) return;
                            const n = this.switchParams(r.url, null == i ? void 0 : i.details, r.details);
                            this.loadPlaylist(n)
                        }
                        findTrackId(t) {
                            const e = this.tracksInGroup;
                            for (let i = 0; i < e.length; i++) {
                                const r = e[i];
                                if ((!this.selectDefaultTrack || r.default) && (!t || $i(t, r, Gi))) return i
                            }
                            if (t) {
                                const {
                                    name: i,
                                    lang: r,
                                    assocLang: s,
                                    characteristics: n,
                                    audioCodec: a,
                                    channels: o
                                } = t;
                                for (let t = 0; t < e.length; t++) {
                                    if ($i({
                                            name: i,
                                            lang: r,
                                            assocLang: s,
                                            characteristics: n,
                                            audioCodec: a,
                                            channels: o
                                        }, e[t], Gi)) return t
                                }
                                for (let i = 0; i < e.length; i++) {
                                    const r = e[i];
                                    if (Ns(t.attrs, r.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) return i
                                }
                                for (let i = 0; i < e.length; i++) {
                                    const r = e[i];
                                    if (Ns(t.attrs, r.attrs, ["LANGUAGE"])) return i
                                }
                            }
                            return -1
                        }
                        loadPlaylist(t) {
                            const e = this.currentTrack;
                            if (this.shouldLoadPlaylist(e) && e) {
                                super.loadPlaylist();
                                const i = e.id,
                                    r = e.groupId;
                                let s = e.url;
                                if (t) try {
                                    s = t.addDirectives(s)
                                } catch (t) {
                                    this.warn(`Could not construct new URL with HLS Delivery Directives: ${t}`)
                                }
                                this.log(`loading audio-track playlist ${i} "${e.name}" lang:${e.lang} group:${r}`), this.clearTimer(), this.hls.trigger(T.AUDIO_TRACK_LOADING, {
                                    url: s,
                                    id: i,
                                    groupId: r,
                                    deliveryDirectives: t || null
                                })
                            }
                        }
                    },
                    emeController: $n,
                    cmcdController: class {
                        constructor(t) {
                            this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.includeKeys = void 0, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => {
                                this.initialized && (this.starved = !0), this.buffering = !0
                            }, this.onPlaying = () => {
                                this.initialized || (this.initialized = !0), this.buffering = !1
                            }, this.applyPlaylistData = t => {
                                try {
                                    this.apply(t, {
                                        ot: Hn.MANIFEST,
                                        su: !this.initialized
                                    })
                                } catch (t) {
                                    R.warn("Could not generate manifest CMCD data.", t)
                                }
                            }, this.applyFragmentData = t => {
                                try {
                                    const e = t.frag,
                                        i = this.hls.levels[e.level],
                                        r = this.getObjectType(e),
                                        s = {
                                            d: 1e3 * e.duration,
                                            ot: r
                                        };
                                    r !== Hn.VIDEO && r !== Hn.AUDIO && r != Hn.MUXED || (s.br = i.bitrate / 1e3, s.tb = this.getTopBandwidth(r) / 1e3, s.bl = this.getBufferLength(r)), this.apply(t, s)
                                } catch (t) {
                                    R.warn("Could not generate segment CMCD data.", t)
                                }
                            }, this.hls = t;
                            const e = this.config = t.config,
                                {
                                    cmcd: i
                                } = e;
                            null != i && (e.pLoader = this.createPlaylistLoader(), e.fLoader = this.createFragmentLoader(), this.sid = i.sessionId || function() {
                                try {
                                    return crypto.randomUUID()
                                } catch (t) {
                                    try {
                                        const t = URL.createObjectURL(new Blob),
                                            e = t.toString();
                                        return URL.revokeObjectURL(t), e.slice(e.lastIndexOf("/") + 1)
                                    } catch (t) {
                                        let e = (new Date).getTime();
                                        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t => {
                                            const i = (e + 16 * Math.random()) % 16 | 0;
                                            return e = Math.floor(e / 16), ("x" == t ? i : 3 & i | 8).toString(16)
                                        }))
                                    }
                                }
                            }(), this.cid = i.contentId, this.useHeaders = !0 === i.useHeaders, this.includeKeys = i.includeKeys, this.registerListeners())
                        }
                        registerListeners() {
                            const t = this.hls;
                            t.on(T.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(T.MEDIA_DETACHED, this.onMediaDetached, this), t.on(T.BUFFER_CREATED, this.onBufferCreated, this)
                        }
                        unregisterListeners() {
                            const t = this.hls;
                            t.off(T.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(T.MEDIA_DETACHED, this.onMediaDetached, this), t.off(T.BUFFER_CREATED, this.onBufferCreated, this)
                        }
                        destroy() {
                            this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null, this.onWaiting = this.onPlaying = null
                        }
                        onMediaAttached(t, e) {
                            this.media = e.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying)
                        }
                        onMediaDetached() {
                            this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null)
                        }
                        onBufferCreated(t, e) {
                            var i, r;
                            this.audioBuffer = null == (i = e.tracks.audio) ? void 0 : i.buffer, this.videoBuffer = null == (r = e.tracks.video) ? void 0 : r.buffer
                        }
                        createData() {
                            var t;
                            return {
                                v: 1,
                                sf: Vn.HLS,
                                sid: this.sid,
                                cid: this.cid,
                                pr: null == (t = this.media) ? void 0 : t.playbackRate,
                                mtp: this.hls.bandwidthEstimate / 1e3
                            }
                        }
                        apply(t, e = {}) {
                            m(e, this.createData());
                            const i = e.ot === Hn.INIT || e.ot === Hn.VIDEO || e.ot === Hn.MUXED;
                            this.starved && i && (e.bs = !0, e.su = !0, this.starved = !1), null == e.su && (e.su = this.buffering);
                            const {
                                includeKeys: r
                            } = this;
                            r && (e = Object.keys(e).reduce(((t, i) => (r.includes(i) && (t[i] = e[i]), t)), {})), this.useHeaders ? (t.headers || (t.headers = {}), ba(t.headers, e)) : t.url = ka(t.url, e)
                        }
                        getObjectType(t) {
                            const {
                                type: e
                            } = t;
                            return "subtitle" === e ? Hn.TIMED_TEXT : "initSegment" === t.sn ? Hn.INIT : "audio" === e ? Hn.AUDIO : "main" === e ? this.hls.audioTracks.length ? Hn.VIDEO : Hn.MUXED : void 0
                        }
                        getTopBandwidth(t) {
                            let e, i = 0;
                            const r = this.hls;
                            if (t === Hn.AUDIO) e = r.audioTracks;
                            else {
                                const t = r.maxAutoLevel,
                                    i = t > -1 ? t + 1 : r.levels.length;
                                e = r.levels.slice(0, i)
                            }
                            for (const t of e) t.bitrate > i && (i = t.bitrate);
                            return i > 0 ? i : NaN
                        }
                        getBufferLength(t) {
                            const e = this.hls.media,
                                i = t === Hn.AUDIO ? this.audioBuffer : this.videoBuffer;
                            if (!i || !e) return NaN;
                            return 1e3 * Ji.bufferInfo(i, e.currentTime, this.config.maxBufferHole).len
                        }
                        createPlaylistLoader() {
                            const {
                                pLoader: t
                            } = this.config, e = this.applyPlaylistData, i = t || this.config.loader;
                            return class {
                                constructor(t) {
                                    this.loader = void 0, this.loader = new i(t)
                                }
                                get stats() {
                                    return this.loader.stats
                                }
                                get context() {
                                    return this.loader.context
                                }
                                destroy() {
                                    this.loader.destroy()
                                }
                                abort() {
                                    this.loader.abort()
                                }
                                load(t, i, r) {
                                    e(t), this.loader.load(t, i, r)
                                }
                            }
                        }
                        createFragmentLoader() {
                            const {
                                fLoader: t
                            } = this.config, e = this.applyFragmentData, i = t || this.config.loader;
                            return class {
                                constructor(t) {
                                    this.loader = void 0, this.loader = new i(t)
                                }
                                get stats() {
                                    return this.loader.stats
                                }
                                get context() {
                                    return this.loader.context
                                }
                                destroy() {
                                    this.loader.destroy()
                                }
                                abort() {
                                    this.loader.abort()
                                }
                                load(t, i, r) {
                                    e(t), this.loader.load(t, i, r)
                                }
                            }
                        }
                    },
                    contentSteeringController: class {
                        constructor(t) {
                            this.hls = void 0, this.log = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this.pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = t, this.log = R.log.bind(R, "[content-steering]:"), this.registerListeners()
                        }
                        registerListeners() {
                            const t = this.hls;
                            t.on(T.MANIFEST_LOADING, this.onManifestLoading, this), t.on(T.MANIFEST_LOADED, this.onManifestLoaded, this), t.on(T.MANIFEST_PARSED, this.onManifestParsed, this), t.on(T.ERROR, this.onError, this)
                        }
                        unregisterListeners() {
                            const t = this.hls;
                            t && (t.off(T.MANIFEST_LOADING, this.onManifestLoading, this), t.off(T.MANIFEST_LOADED, this.onManifestLoaded, this), t.off(T.MANIFEST_PARSED, this.onManifestParsed, this), t.off(T.ERROR, this.onError, this))
                        }
                        startLoad() {
                            if (this.started = !0, this.clearTimeout(), this.enabled && this.uri) {
                                if (this.updated) {
                                    const t = 1e3 * this.timeToLoad - (performance.now() - this.updated);
                                    if (t > 0) return void this.scheduleRefresh(this.uri, t)
                                }
                                this.loadSteeringManifest(this.uri)
                            }
                        }
                        stopLoad() {
                            this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), this.clearTimeout()
                        }
                        clearTimeout() {
                            -1 !== this.reloadTimer && (self.clearTimeout(this.reloadTimer), this.reloadTimer = -1)
                        }
                        destroy() {
                            this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null
                        }
                        removeLevel(t) {
                            const e = this.levels;
                            e && (this.levels = e.filter((e => e !== t)))
                        }
                        onManifestLoading() {
                            this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null
                        }
                        onManifestLoaded(t, e) {
                            const {
                                contentSteering: i
                            } = e;
                            null !== i && (this.pathwayId = i.pathwayId, this.uri = i.uri, this.started && this.startLoad())
                        }
                        onManifestParsed(t, e) {
                            this.audioTracks = e.audioTracks, this.subtitleTracks = e.subtitleTracks
                        }
                        onError(t, e) {
                            const {
                                errorAction: i
                            } = e;
                            if ((null == i ? void 0 : i.action) === Li && i.flags === _i) {
                                const t = this.levels;
                                let r = this.pathwayPriority,
                                    s = this.pathwayId;
                                if (e.context) {
                                    const {
                                        groupId: i,
                                        pathwayId: r,
                                        type: n
                                    } = e.context;
                                    i && t ? s = this.getPathwayForGroupId(i, n, s) : r && (s = r)
                                }
                                s in this.penalizedPathways || (this.penalizedPathways[s] = performance.now()), !r && t && (r = t.reduce(((t, e) => (-1 === t.indexOf(e.pathwayId) && t.push(e.pathwayId), t)), [])), r && r.length > 1 && (this.updatePathwayPriority(r), i.resolved = this.pathwayId !== s), i.resolved || R.warn(`Could not resolve ${e.details} ("${e.error.message}") with content-steering for Pathway: ${s} levels: ${t?t.length:t} priorities: ${JSON.stringify(r)} penalized: ${JSON.stringify(this.penalizedPathways)}`)
                            }
                        }
                        filterParsedLevels(t) {
                            this.levels = t;
                            let e = this.getLevelsForPathway(this.pathwayId);
                            if (0 === e.length) {
                                const i = t[0].pathwayId;
                                this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${i}"`), e = this.getLevelsForPathway(i), this.pathwayId = i
                            }
                            return e.length !== t.length ? (this.log(`Found ${e.length}/${t.length} levels in Pathway "${this.pathwayId}"`), e) : t
                        }
                        getLevelsForPathway(t) {
                            return null === this.levels ? [] : this.levels.filter((e => t === e.pathwayId))
                        }
                        updatePathwayPriority(t) {
                            let e;
                            this.pathwayPriority = t;
                            const i = this.penalizedPathways,
                                r = performance.now();
                            Object.keys(i).forEach((t => {
                                r - i[t] > 3e5 && delete i[t]
                            }));
                            for (let r = 0; r < t.length; r++) {
                                const s = t[r];
                                if (s in i) continue;
                                if (s === this.pathwayId) return;
                                const n = this.hls.nextLoadLevel,
                                    a = this.hls.levels[n];
                                if (e = this.getLevelsForPathway(s), e.length > 0) {
                                    this.log(`Setting Pathway to "${s}"`), this.pathwayId = s, fi(e), this.hls.trigger(T.LEVELS_UPDATED, {
                                        levels: e
                                    });
                                    const t = this.hls.levels[n];
                                    a && t && this.levels && (t.attrs["STABLE-VARIANT-ID"] !== a.attrs["STABLE-VARIANT-ID"] && t.bitrate !== a.bitrate && this.log(`Unstable Pathways change from bitrate ${a.bitrate} to ${t.bitrate}`), this.hls.nextLoadLevel = n);
                                    break
                                }
                            }
                        }
                        getPathwayForGroupId(t, e, i) {
                            const r = this.getLevelsForPathway(i).concat(this.levels || []);
                            for (let i = 0; i < r.length; i++)
                                if (e === De && r[i].hasAudioGroup(t) || e === Ce && r[i].hasSubtitleGroup(t)) return r[i].pathwayId;
                            return i
                        }
                        clonePathways(t) {
                            const e = this.levels;
                            if (!e) return;
                            const i = {},
                                r = {};
                            t.forEach((t => {
                                const {
                                    ID: s,
                                    "BASE-ID": n,
                                    "URI-REPLACEMENT": a
                                } = t;
                                if (e.some((t => t.pathwayId === s))) return;
                                const o = this.getLevelsForPathway(n).map((t => {
                                    const e = new D(t.attrs);
                                    e["PATHWAY-ID"] = s;
                                    const n = e.AUDIO && `${e.AUDIO}_clone_${s}`,
                                        o = e.SUBTITLES && `${e.SUBTITLES}_clone_${s}`;
                                    n && (i[e.AUDIO] = n, e.AUDIO = n), o && (r[e.SUBTITLES] = o, e.SUBTITLES = o);
                                    const l = wa(t.uri, e["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", a),
                                        u = new si({
                                            attrs: e,
                                            audioCodec: t.audioCodec,
                                            bitrate: t.bitrate,
                                            height: t.height,
                                            name: t.name,
                                            url: l,
                                            videoCodec: t.videoCodec,
                                            width: t.width
                                        });
                                    if (t.audioGroups)
                                        for (let e = 1; e < t.audioGroups.length; e++) u.addGroupId("audio", `${t.audioGroups[e]}_clone_${s}`);
                                    if (t.subtitleGroups)
                                        for (let e = 1; e < t.subtitleGroups.length; e++) u.addGroupId("text", `${t.subtitleGroups[e]}_clone_${s}`);
                                    return u
                                }));
                                e.push(...o), Ra(this.audioTracks, i, a, s), Ra(this.subtitleTracks, r, a, s)
                            }))
                        }
                        loadSteeringManifest(t) {
                            const e = this.hls.config,
                                i = e.loader;
                            let r;
                            this.loader && this.loader.destroy(), this.loader = new i(e);
                            try {
                                r = new self.URL(t)
                            } catch (e) {
                                return this.enabled = !1, void this.log(`Failed to parse Steering Manifest URI: ${t}`)
                            }
                            if ("data:" !== r.protocol) {
                                const t = 0 | (this.hls.bandwidthEstimate || e.abrEwmaDefaultEstimate);
                                r.searchParams.set("_HLS_pathway", this.pathwayId), r.searchParams.set("_HLS_throughput", "" + t)
                            }
                            const s = {
                                    responseType: "json",
                                    url: r.href
                                },
                                n = e.steeringManifestLoadPolicy.default,
                                a = n.errorRetry || n.timeoutRetry || {},
                                o = {
                                    loadPolicy: n,
                                    timeout: n.maxLoadTimeMs,
                                    maxRetry: a.maxNumRetry || 0,
                                    retryDelay: a.retryDelayMs || 0,
                                    maxRetryDelay: a.maxRetryDelayMs || 0
                                },
                                l = {
                                    onSuccess: (t, e, i, s) => {
                                        this.log(`Loaded steering manifest: "${r}"`);
                                        const n = t.data;
                                        if (1 !== n.VERSION) return void this.log(`Steering VERSION ${n.VERSION} not supported!`);
                                        this.updated = performance.now(), this.timeToLoad = n.TTL;
                                        const {
                                            "RELOAD-URI": a,
                                            "PATHWAY-CLONES": o,
                                            "PATHWAY-PRIORITY": l
                                        } = n;
                                        if (a) try {
                                            this.uri = new self.URL(a, r).href
                                        } catch (t) {
                                            return this.enabled = !1, void this.log(`Failed to parse Steering Manifest RELOAD-URI: ${a}`)
                                        }
                                        this.scheduleRefresh(this.uri || i.url), o && this.clonePathways(o);
                                        const u = {
                                            steeringManifest: n,
                                            url: r.toString()
                                        };
                                        this.hls.trigger(T.STEERING_MANIFEST_LOADED, u), l && this.updatePathwayPriority(l)
                                    },
                                    onError: (t, e, i, r) => {
                                        if (this.log(`Error loading steering manifest: ${t.code} ${t.text} (${e.url})`), this.stopLoad(), 410 === t.code) return this.enabled = !1, void this.log(`Steering manifest ${e.url} no longer available`);
                                        let s = 1e3 * this.timeToLoad;
                                        if (429 !== t.code) this.scheduleRefresh(this.uri || e.url, s);
                                        else {
                                            const t = this.loader;
                                            if ("function" == typeof(null == t ? void 0 : t.getResponseHeader)) {
                                                const e = t.getResponseHeader("Retry-After");
                                                e && (s = 1e3 * parseFloat(e))
                                            }
                                            this.log(`Steering manifest ${e.url} rate limited`)
                                        }
                                    },
                                    onTimeout: (t, e, i) => {
                                        this.log(`Timeout loading steering manifest (${e.url})`), this.scheduleRefresh(this.uri || e.url)
                                    }
                                };
                            this.log(`Requesting steering manifest: ${r}`), this.loader.load(s, o, l)
                        }
                        scheduleRefresh(t, e = 1e3 * this.timeToLoad) {
                            this.clearTimeout(), this.reloadTimer = self.setTimeout((() => {
                                var e;
                                const i = null == (e = this.hls) ? void 0 : e.media;
                                !i || i.ended ? this.scheduleRefresh(t, 1e3 * this.timeToLoad) : this.loadSteeringManifest(t)
                            }), e)
                        }
                    }
                });

            function Na(t) {
                return t && "object" == typeof t ? Array.isArray(t) ? t.map(Na) : Object.keys(t).reduce(((e, i) => (e[i] = Na(t[i]), e)), {}) : t
            }

            function Ba(t) {
                const e = t.loader;
                if (e !== Ia && e !== Da) R.log("[config]: Custom loader detected, cannot enable progressive streaming"), t.progressive = !1;
                else {
                    (function() {
                        if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try {
                            return new self.ReadableStream({}), !0
                        } catch (t) {}
                        return !1
                    })() && (t.loader = Ia, t.progressive = !0, t.enableSoftwareAES = !0, R.log("[config]: Progressive streaming enabled, using FetchLoader"))
                }
            }
            let Ua;
            class $a extends Ci {
                constructor(t, e) {
                    super(t, "[level-controller]"), this._levels = [], this._firstLevel = -1, this._maxAutoLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = e, this._registerListeners()
                }
                _registerListeners() {
                    const {
                        hls: t
                    } = this;
                    t.on(T.MANIFEST_LOADING, this.onManifestLoading, this), t.on(T.MANIFEST_LOADED, this.onManifestLoaded, this), t.on(T.LEVEL_LOADED, this.onLevelLoaded, this), t.on(T.LEVELS_UPDATED, this.onLevelsUpdated, this), t.on(T.FRAG_BUFFERED, this.onFragBuffered, this), t.on(T.ERROR, this.onError, this)
                }
                _unregisterListeners() {
                    const {
                        hls: t
                    } = this;
                    t.off(T.MANIFEST_LOADING, this.onManifestLoading, this), t.off(T.MANIFEST_LOADED, this.onManifestLoaded, this), t.off(T.LEVEL_LOADED, this.onLevelLoaded, this), t.off(T.LEVELS_UPDATED, this.onLevelsUpdated, this), t.off(T.FRAG_BUFFERED, this.onFragBuffered, this), t.off(T.ERROR, this.onError, this)
                }
                destroy() {
                    this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy()
                }
                stopLoad() {
                    this._levels.forEach((t => {
                        t.loadError = 0, t.fragmentError = 0
                    })), super.stopLoad()
                }
                resetLevels() {
                    this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [], this._maxAutoLevel = -1
                }
                onManifestLoading(t, e) {
                    this.resetLevels()
                }
                onManifestLoaded(t, e) {
                    const i = this.hls.config.preferManagedMediaSource,
                        r = [],
                        s = {},
                        n = {};
                    let a = !1,
                        o = !1,
                        l = !1;
                    e.levels.forEach((t => {
                        var e, u;
                        const c = t.attrs;
                        let {
                            audioCodec: h,
                            videoCodec: d
                        } = t; - 1 !== (null == (e = h) ? void 0 : e.indexOf("mp4a.40.34")) && (Ua || (Ua = /chrome|firefox/i.test(navigator.userAgent)), Ua && (t.audioCodec = h = void 0)), h && (t.audioCodec = h = de(h, i)), 0 === (null == (u = d) ? void 0 : u.indexOf("avc1")) && (d = t.videoCodec = function(t) {
                            const e = t.split(",");
                            for (let t = 0; t < e.length; t++) {
                                const i = e[t].split(".");
                                if (i.length > 2) {
                                    let r = i.shift() + ".";
                                    r += parseInt(i.shift()).toString(16), r += ("000" + parseInt(i.shift()).toString(16)).slice(-4), e[t] = r
                                }
                            }
                            return e.join(",")
                        }(d));
                        const {
                            width: f,
                            height: g,
                            unknownCodecs: m
                        } = t;
                        if (a || (a = !(!f || !g)), o || (o = !!d), l || (l = !!h), null != m && m.length || h && !ne(h, "audio", i) || d && !ne(d, "video", i)) return;
                        const {
                            CODECS: p,
                            "FRAME-RATE": v,
                            "HDCP-LEVEL": y,
                            "PATHWAY-ID": T,
                            RESOLUTION: E,
                            "VIDEO-RANGE": S
                        } = c, b = `${`${T||"."}-`}${t.bitrate}-${E}-${v}-${p}-${S}-${y}`;
                        if (s[b])
                            if (s[b].uri === t.url || t.attrs["PATHWAY-ID"]) s[b].addGroupId("audio", c.AUDIO), s[b].addGroupId("text", c.SUBTITLES);
                            else {
                                const e = n[b] += 1;
                                t.attrs["PATHWAY-ID"] = new Array(e + 1).join(".");
                                const i = new si(t);
                                s[b] = i, r.push(i)
                            }
                        else {
                            const e = new si(t);
                            s[b] = e, n[b] = 1, r.push(e)
                        }
                    })), this.filterAndSortMediaOptions(r, e, a, o, l)
                }
                filterAndSortMediaOptions(t, e, i, r, s) {
                    let n = [],
                        a = [],
                        o = t;
                    if ((i || r) && s && (o = o.filter((({
                            videoCodec: t,
                            videoRange: e,
                            width: i,
                            height: r
                        }) => {
                            return (!!t || !(!i || !r)) && (!!(s = e) && Je.indexOf(s) > -1);
                            var s
                        }))), 0 === o.length) return void Promise.resolve().then((() => {
                        if (this.hls) {
                            e.levels.length && this.warn(`One or more CODECS in variant not supported: ${JSON.stringify(e.levels[0].attrs)}`);
                            const t = new Error("no level with compatible codecs found in manifest");
                            this.hls.trigger(T.ERROR, {
                                type: E.MEDIA_ERROR,
                                details: S.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                                fatal: !0,
                                url: e.url,
                                error: t,
                                reason: t.message
                            })
                        }
                    }));
                    if (e.audioTracks) {
                        const {
                            preferManagedMediaSource: t
                        } = this.hls.config;
                        n = e.audioTracks.filter((e => !e.audioCodec || ne(e.audioCodec, "audio", t))), Ga(n)
                    }
                    e.subtitles && (a = e.subtitles, Ga(a));
                    const l = o.slice(0);
                    o.sort(((t, e) => {
                        if (t.attrs["HDCP-LEVEL"] !== e.attrs["HDCP-LEVEL"]) return (t.attrs["HDCP-LEVEL"] || "") > (e.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
                        if (i && t.height !== e.height) return t.height - e.height;
                        if (t.frameRate !== e.frameRate) return t.frameRate - e.frameRate;
                        if (t.videoRange !== e.videoRange) return Je.indexOf(t.videoRange) - Je.indexOf(e.videoRange);
                        if (t.videoCodec !== e.videoCodec) {
                            const i = le(t.videoCodec),
                                r = le(e.videoCodec);
                            if (i !== r) return r - i
                        }
                        if (t.uri === e.uri && t.codecSet !== e.codecSet) {
                            const i = ue(t.codecSet),
                                r = ue(e.codecSet);
                            if (i !== r) return r - i
                        }
                        return t.averageBitrate !== e.averageBitrate ? t.averageBitrate - e.averageBitrate : 0
                    }));
                    let u = l[0];
                    if (this.steering && (o = this.steering.filterParsedLevels(o), o.length !== l.length))
                        for (let t = 0; t < l.length; t++)
                            if (l[t].pathwayId === o[0].pathwayId) {
                                u = l[t];
                                break
                            }
                    this._levels = o;
                    for (let t = 0; t < o.length; t++)
                        if (o[t] === u) {
                            var c;
                            this._firstLevel = t;
                            const e = u.bitrate,
                                i = this.hls.bandwidthEstimate;
                            if (this.log(`manifest loaded, ${o.length} level(s) found, first bitrate: ${e}`), void 0 === (null == (c = this.hls.userConfig) ? void 0 : c.abrEwmaDefaultEstimate)) {
                                const t = Math.min(e, this.hls.config.abrEwmaDefaultEstimateMax);
                                t > i && i === Fa.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = t)
                            }
                            break
                        }
                    const h = s && !r,
                        d = {
                            levels: o,
                            audioTracks: n,
                            subtitleTracks: a,
                            sessionData: e.sessionData,
                            sessionKeys: e.sessionKeys,
                            firstLevel: this._firstLevel,
                            stats: e.stats,
                            audio: s,
                            video: r,
                            altAudio: !h && n.some((t => !!t.url))
                        };
                    this.hls.trigger(T.MANIFEST_PARSED, d), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition)
                }
                get levels() {
                    return 0 === this._levels.length ? null : this._levels
                }
                get level() {
                    return this.currentLevelIndex
                }
                set level(t) {
                    const e = this._levels;
                    if (0 === e.length) return;
                    if (t < 0 || t >= e.length) {
                        const i = new Error("invalid level idx"),
                            r = t < 0;
                        if (this.hls.trigger(T.ERROR, {
                                type: E.OTHER_ERROR,
                                details: S.LEVEL_SWITCH_ERROR,
                                level: t,
                                fatal: r,
                                error: i,
                                reason: i.message
                            }), r) return;
                        t = Math.min(t, e.length - 1)
                    }
                    const i = this.currentLevelIndex,
                        r = this.currentLevel,
                        s = r ? r.attrs["PATHWAY-ID"] : void 0,
                        n = e[t],
                        a = n.attrs["PATHWAY-ID"];
                    if (this.currentLevelIndex = t, this.currentLevel = n, i === t && n.details && r && s === a) return;
                    this.log(`Switching to level ${t} (${n.height?n.height+"p ":""}${n.videoRange?n.videoRange+" ":""}${n.codecSet?n.codecSet+" ":""}@${n.bitrate})${a?" with Pathway "+a:""} from level ${i}${s?" with Pathway "+s:""}`);
                    const o = {
                        level: t,
                        attrs: n.attrs,
                        details: n.details,
                        bitrate: n.bitrate,
                        averageBitrate: n.averageBitrate,
                        maxBitrate: n.maxBitrate,
                        realBitrate: n.realBitrate,
                        width: n.width,
                        height: n.height,
                        codecSet: n.codecSet,
                        audioCodec: n.audioCodec,
                        videoCodec: n.videoCodec,
                        audioGroups: n.audioGroups,
                        subtitleGroups: n.subtitleGroups,
                        loaded: n.loaded,
                        loadError: n.loadError,
                        fragmentError: n.fragmentError,
                        name: n.name,
                        id: n.id,
                        uri: n.uri,
                        url: n.url,
                        urlId: 0,
                        audioGroupIds: n.audioGroupIds,
                        textGroupIds: n.textGroupIds
                    };
                    this.hls.trigger(T.LEVEL_SWITCHING, o);
                    const l = n.details;
                    if (!l || l.live) {
                        const t = this.switchParams(n.uri, null == r ? void 0 : r.details, l);
                        this.loadPlaylist(t)
                    }
                }
                get manualLevel() {
                    return this.manualLevelIndex
                }
                set manualLevel(t) {
                    this.manualLevelIndex = t, void 0 === this._startLevel && (this._startLevel = t), -1 !== t && (this.level = t)
                }
                get firstLevel() {
                    return this._firstLevel
                }
                set firstLevel(t) {
                    this._firstLevel = t
                }
                get startLevel() {
                    if (void 0 === this._startLevel) {
                        const t = this.hls.config.startLevel;
                        return void 0 !== t ? t : this.hls.firstAutoLevel
                    }
                    return this._startLevel
                }
                set startLevel(t) {
                    this._startLevel = t
                }
                onError(t, e) {
                    !e.fatal && e.context && e.context.type === _e && e.context.level === this.level && this.checkRetry(e)
                }
                onFragBuffered(t, {
                    frag: e
                }) {
                    if (void 0 !== e && e.type === Ie) {
                        const t = e.elementaryStreams;
                        if (!Object.keys(t).some((e => !!t[e]))) return;
                        const i = this._levels[e.level];
                        null != i && i.loadError && (this.log(`Resetting level error count of ${i.loadError} on frag buffered`), i.loadError = 0)
                    }
                }
                onLevelLoaded(t, e) {
                    var i;
                    const {
                        level: r,
                        details: s
                    } = e, n = this._levels[r];
                    var a;
                    if (!n) return this.warn(`Invalid level index ${r}`), void(null != (a = e.deliveryDirectives) && a.skip && (s.deltaUpdateFailed = !0));
                    r === this.currentLevelIndex ? (0 === n.fragmentError && (n.loadError = 0), this.playlistLoaded(r, e, n.details)) : null != (i = e.deliveryDirectives) && i.skip && (s.deltaUpdateFailed = !0)
                }
                loadPlaylist(t) {
                    super.loadPlaylist();
                    const e = this.currentLevelIndex,
                        i = this.currentLevel;
                    if (i && this.shouldLoadPlaylist(i)) {
                        let r = i.uri;
                        if (t) try {
                            r = t.addDirectives(r)
                        } catch (t) {
                            this.warn(`Could not construct new URL with HLS Delivery Directives: ${t}`)
                        }
                        const s = i.attrs["PATHWAY-ID"];
                        this.log(`Loading level index ${e}${void 0!==(null==t?void 0:t.msn)?" at sn "+t.msn+" part "+t.part:""} with${s?" Pathway "+s:""} ${r}`), this.clearTimer(), this.hls.trigger(T.LEVEL_LOADING, {
                            url: r,
                            level: e,
                            pathwayId: i.attrs["PATHWAY-ID"],
                            id: 0,
                            deliveryDirectives: t || null
                        })
                    }
                }
                get nextLoadLevel() {
                    return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel
                }
                set nextLoadLevel(t) {
                    this.level = t, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = t)
                }
                removeLevel(t) {
                    var e;
                    const i = this._levels.filter(((e, i) => i !== t || (this.steering && this.steering.removeLevel(e), e === this.currentLevel && (this.currentLevel = null, this.currentLevelIndex = -1, e.details && e.details.fragments.forEach((t => t.level = -1))), !1)));
                    fi(i), this._levels = i, this.currentLevelIndex > -1 && null != (e = this.currentLevel) && e.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level), this.hls.trigger(T.LEVELS_UPDATED, {
                        levels: i
                    })
                }
                onLevelsUpdated(t, {
                    levels: e
                }) {
                    this._levels = e
                }
                checkMaxAutoUpdated() {
                    const {
                        autoLevelCapping: t,
                        maxAutoLevel: e,
                        maxHdcpLevel: i
                    } = this.hls;
                    this._maxAutoLevel !== e && (this._maxAutoLevel = e, this.hls.trigger(T.MAX_AUTO_LEVEL_UPDATED, {
                        autoLevelCapping: t,
                        levels: this.levels,
                        maxAutoLevel: e,
                        minAutoLevel: this.hls.minAutoLevel,
                        maxHdcpLevel: i
                    }))
                }
            }

            function Ga(t) {
                const e = {};
                t.forEach((t => {
                    const i = t.groupId || "";
                    t.id = e[i] = e[i] || 0, e[i]++
                }))
            }
            class Ha {
                constructor(t) {
                    this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = t
                }
                abort(t) {
                    for (const i in this.keyUriToKeyInfo) {
                        const r = this.keyUriToKeyInfo[i].loader;
                        if (r) {
                            var e;
                            if (t && t !== (null == (e = r.context) ? void 0 : e.frag.type)) return;
                            r.abort()
                        }
                    }
                }
                detach() {
                    for (const t in this.keyUriToKeyInfo) {
                        const e = this.keyUriToKeyInfo[t];
                        (e.mediaKeySessionContext || e.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[t]
                    }
                }
                destroy() {
                    this.detach();
                    for (const t in this.keyUriToKeyInfo) {
                        const e = this.keyUriToKeyInfo[t].loader;
                        e && e.destroy()
                    }
                    this.keyUriToKeyInfo = {}
                }
                createKeyLoadError(t, e = S.KEY_LOAD_ERROR, i, r, s) {
                    return new ur({
                        type: E.NETWORK_ERROR,
                        details: e,
                        fatal: !1,
                        frag: t,
                        response: s,
                        error: i,
                        networkDetails: r
                    })
                }
                loadClear(t, e) {
                    if (this.emeController && this.config.emeEnabled) {
                        const {
                            sn: i,
                            cc: r
                        } = t;
                        for (let t = 0; t < e.length; t++) {
                            const s = e[t];
                            if (r <= s.cc && ("initSegment" === i || "initSegment" === s.sn || i < s.sn)) {
                                this.emeController.selectKeySystemFormat(s).then((t => {
                                    s.setKeyFormat(t)
                                }));
                                break
                            }
                        }
                    }
                }
                load(t) {
                    return !t.decryptdata && t.encrypted && this.emeController ? this.emeController.selectKeySystemFormat(t).then((e => this.loadInternal(t, e))) : this.loadInternal(t)
                }
                loadInternal(t, e) {
                    var i, r;
                    e && t.setKeyFormat(e);
                    const s = t.decryptdata;
                    if (!s) {
                        const i = new Error(e ? `Expected frag.decryptdata to be defined after setting format ${e}` : "Missing decryption data on fragment in onKeyLoading");
                        return Promise.reject(this.createKeyLoadError(t, S.KEY_LOAD_ERROR, i))
                    }
                    const n = s.uri;
                    if (!n) return Promise.reject(this.createKeyLoadError(t, S.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${n}"`)));
                    let a = this.keyUriToKeyInfo[n];
                    if (null != (i = a) && i.decryptdata.key) return s.key = a.decryptdata.key, Promise.resolve({
                        frag: t,
                        keyInfo: a
                    });
                    var o;
                    if (null != (r = a) && r.keyLoadPromise) switch (null == (o = a.mediaKeySessionContext) ? void 0 : o.keyStatus) {
                        case void 0:
                        case "status-pending":
                        case "usable":
                        case "usable-in-future":
                            return a.keyLoadPromise.then((e => (s.key = e.keyInfo.decryptdata.key, {
                                frag: t,
                                keyInfo: a
                            })))
                    }
                    switch (a = this.keyUriToKeyInfo[n] = {
                        decryptdata: s,
                        keyLoadPromise: null,
                        loader: null,
                        mediaKeySessionContext: null
                    }, s.method) {
                        case "ISO-23001-7":
                        case "SAMPLE-AES":
                        case "SAMPLE-AES-CENC":
                        case "SAMPLE-AES-CTR":
                            return "identity" === s.keyFormat ? this.loadKeyHTTP(a, t) : this.loadKeyEME(a, t);
                        case "AES-128":
                            return this.loadKeyHTTP(a, t);
                        default:
                            return Promise.reject(this.createKeyLoadError(t, S.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${s.method}"`)))
                    }
                }
                loadKeyEME(t, e) {
                    const i = {
                        frag: e,
                        keyInfo: t
                    };
                    if (this.emeController && this.config.emeEnabled) {
                        const e = this.emeController.loadKey(i);
                        if (e) return (t.keyLoadPromise = e.then((e => (t.mediaKeySessionContext = e, i)))).catch((e => {
                            throw t.keyLoadPromise = null, e
                        }))
                    }
                    return Promise.resolve(i)
                }
                loadKeyHTTP(t, e) {
                    const i = this.config,
                        r = new(0, i.loader)(i);
                    return e.keyLoader = t.loader = r, t.keyLoadPromise = new Promise(((s, n) => {
                        const a = {
                                keyInfo: t,
                                frag: e,
                                responseType: "arraybuffer",
                                url: t.decryptdata.uri
                            },
                            o = i.keyLoadPolicy.default,
                            l = {
                                loadPolicy: o,
                                timeout: o.maxLoadTimeMs,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: 0
                            },
                            u = {
                                onSuccess: (t, e, i, r) => {
                                    const {
                                        frag: a,
                                        keyInfo: o,
                                        url: l
                                    } = i;
                                    if (!a.decryptdata || o !== this.keyUriToKeyInfo[l]) return n(this.createKeyLoadError(a, S.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), r));
                                    o.decryptdata.key = a.decryptdata.key = new Uint8Array(t.data), a.keyLoader = null, o.loader = null, s({
                                        frag: a,
                                        keyInfo: o
                                    })
                                },
                                onError: (t, i, r, s) => {
                                    this.resetLoader(i), n(this.createKeyLoadError(e, S.KEY_LOAD_ERROR, new Error(`HTTP Error ${t.code} loading key ${t.text}`), r, d({
                                        url: a.url,
                                        data: void 0
                                    }, t)))
                                },
                                onTimeout: (t, i, r) => {
                                    this.resetLoader(i), n(this.createKeyLoadError(e, S.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), r))
                                },
                                onAbort: (t, i, r) => {
                                    this.resetLoader(i), n(this.createKeyLoadError(e, S.INTERNAL_ABORTED, new Error("key loading aborted"), r))
                                }
                            };
                        r.load(a, l, u)
                    }))
                }
                resetLoader(t) {
                    const {
                        frag: e,
                        keyInfo: i,
                        url: r
                    } = t, s = i.loader;
                    e.keyLoader === s && (e.keyLoader = null, i.loader = null), delete this.keyUriToKeyInfo[r], s && s.destroy()
                }
            }

            function Va() {
                return self.SourceBuffer || self.WebKitSourceBuffer
            }

            function Wa() {
                if (!re()) return !1;
                const t = Va();
                return !t || t.prototype && "function" == typeof t.prototype.appendBuffer && "function" == typeof t.prototype.remove
            }
            class Ka {
                constructor(t, e, i, r) {
                    this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = t, this.media = e, this.fragmentTracker = i, this.hls = r
                }
                destroy() {
                    this.media = null, this.hls = this.fragmentTracker = null
                }
                poll(t, e) {
                    const {
                        config: i,
                        media: r,
                        stalled: s
                    } = this;
                    if (null === r) return;
                    const {
                        currentTime: n,
                        seeking: a
                    } = r, o = this.seeking && !a, l = !this.seeking && a;
                    if (this.seeking = a, n !== t) {
                        if (this.moved = !0, a || (this.nudgeRetry = 0), null !== s) {
                            if (this.stallReported) {
                                const t = self.performance.now() - s;
                                R.warn(`playback not stuck anymore @${n}, after ${Math.round(t)}ms`), this.stallReported = !1
                            }
                            this.stalled = null
                        }
                        return
                    }
                    if (l || o) return void(this.stalled = null);
                    if (r.paused && !a || r.ended || 0 === r.playbackRate || !Ji.getBuffered(r).length) return void(this.nudgeRetry = 0);
                    const u = Ji.bufferInfo(r, n, 0),
                        c = u.nextStart || 0;
                    if (a) {
                        const t = u.len > 2,
                            i = !c || e && e.start <= n || c - n > 2 && !this.fragmentTracker.getPartialFragment(n);
                        if (t || i) return;
                        this.moved = !1
                    }
                    if (!this.moved && null !== this.stalled) {
                        var h;
                        if (!(u.len > 0) && !c) return;
                        const t = Math.max(c, u.start || 0) - n,
                            e = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null,
                            i = (null == e || null == (h = e.details) ? void 0 : h.live) ? 2 * e.details.targetduration : 2,
                            s = this.fragmentTracker.getPartialFragment(n);
                        if (t > 0 && (t <= i || s)) return void(r.paused || this._trySkipBufferHole(s))
                    }
                    const d = self.performance.now();
                    if (null === s) return void(this.stalled = d);
                    const f = d - s;
                    if (!a && f >= 250 && (this._reportStall(u), !this.media)) return;
                    const g = Ji.bufferInfo(r, n, i.maxBufferHole);
                    this._tryFixBufferStall(g, f)
                }
                _tryFixBufferStall(t, e) {
                    const {
                        config: i,
                        fragmentTracker: r,
                        media: s
                    } = this;
                    if (null === s) return;
                    const n = s.currentTime,
                        a = r.getPartialFragment(n);
                    if (a) {
                        if (this._trySkipBufferHole(a) || !this.media) return
                    }(t.len > i.maxBufferHole || t.nextStart && t.nextStart - n < i.maxBufferHole) && e > 1e3 * i.highBufferWatchdogPeriod && (R.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer())
                }
                _reportStall(t) {
                    const {
                        hls: e,
                        media: i,
                        stallReported: r
                    } = this;
                    if (!r && i) {
                        this.stallReported = !0;
                        const r = new Error(`Playback stalling at @${i.currentTime} due to low buffer (${JSON.stringify(t)})`);
                        R.warn(r.message), e.trigger(T.ERROR, {
                            type: E.MEDIA_ERROR,
                            details: S.BUFFER_STALLED_ERROR,
                            fatal: !1,
                            error: r,
                            buffer: t.len
                        })
                    }
                }
                _trySkipBufferHole(t) {
                    const {
                        config: e,
                        hls: i,
                        media: r
                    } = this;
                    if (null === r) return 0;
                    const s = r.currentTime,
                        n = Ji.bufferInfo(r, s, 0),
                        a = s < n.start ? n.start : n.nextStart;
                    if (a) {
                        const o = n.len <= e.maxBufferHole,
                            l = n.len > 0 && n.len < 1 && r.readyState < 3,
                            u = a - s;
                        if (u > 0 && (o || l)) {
                            if (u > e.maxBufferHole) {
                                const {
                                    fragmentTracker: e
                                } = this;
                                let i = !1;
                                if (0 === s) {
                                    const t = e.getAppendedFrag(0, Ie);
                                    t && a < t.end && (i = !0)
                                }
                                if (!i) {
                                    const i = t || e.getAppendedFrag(s, Ie);
                                    if (i) {
                                        let t = !1,
                                            r = i.end;
                                        for (; r < a;) {
                                            const i = e.getPartialFragment(r);
                                            if (!i) {
                                                t = !0;
                                                break
                                            }
                                            r += i.duration
                                        }
                                        if (t) return 0
                                    }
                                }
                            }
                            const n = Math.max(a + .05, s + .1);
                            if (R.warn(`skipping hole, adjusting currentTime from ${s} to ${n}`), this.moved = !0, this.stalled = null, r.currentTime = n, t && !t.gap) {
                                const e = new Error(`fragment loaded with buffer holes, seeking from ${s} to ${n}`);
                                i.trigger(T.ERROR, {
                                    type: E.MEDIA_ERROR,
                                    details: S.BUFFER_SEEK_OVER_HOLE,
                                    fatal: !1,
                                    error: e,
                                    reason: e.message,
                                    frag: t
                                })
                            }
                            return n
                        }
                    }
                    return 0
                }
                _tryNudgeBuffer() {
                    const {
                        config: t,
                        hls: e,
                        media: i,
                        nudgeRetry: r
                    } = this;
                    if (null === i) return;
                    const s = i.currentTime;
                    if (this.nudgeRetry++, r < t.nudgeMaxRetry) {
                        const n = s + (r + 1) * t.nudgeOffset,
                            a = new Error(`Nudging 'currentTime' from ${s} to ${n}`);
                        R.warn(a.message), i.currentTime = n, e.trigger(T.ERROR, {
                            type: E.MEDIA_ERROR,
                            details: S.BUFFER_NUDGE_ON_STALL,
                            error: a,
                            fatal: !1
                        })
                    } else {
                        const i = new Error(`Playhead still not moving while enough data buffered @${s} after ${t.nudgeMaxRetry} nudges`);
                        R.error(i.message), e.trigger(T.ERROR, {
                            type: E.MEDIA_ERROR,
                            details: S.BUFFER_STALLED_ERROR,
                            error: i,
                            fatal: !0
                        })
                    }
                }
            }
            class ja extends wr {
                constructor(t, e, i) {
                    super(t, e, i, "[stream-controller]", Ie), this.audioCodecSwap = !1, this.gapController = null, this.level = -1, this._forceStartLoad = !1, this.altAudio = !1, this.audioOnly = !1, this.fragPlaying = null, this.onvplaying = null, this.onvseeked = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this._registerListeners()
                }
                _registerListeners() {
                    const {
                        hls: t
                    } = this;
                    t.on(T.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(T.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(T.MANIFEST_LOADING, this.onManifestLoading, this), t.on(T.MANIFEST_PARSED, this.onManifestParsed, this), t.on(T.LEVEL_LOADING, this.onLevelLoading, this), t.on(T.LEVEL_LOADED, this.onLevelLoaded, this), t.on(T.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), t.on(T.ERROR, this.onError, this), t.on(T.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.on(T.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.on(T.BUFFER_CREATED, this.onBufferCreated, this), t.on(T.BUFFER_FLUSHED, this.onBufferFlushed, this), t.on(T.LEVELS_UPDATED, this.onLevelsUpdated, this), t.on(T.FRAG_BUFFERED, this.onFragBuffered, this)
                }
                _unregisterListeners() {
                    const {
                        hls: t
                    } = this;
                    t.off(T.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(T.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(T.MANIFEST_LOADING, this.onManifestLoading, this), t.off(T.MANIFEST_PARSED, this.onManifestParsed, this), t.off(T.LEVEL_LOADED, this.onLevelLoaded, this), t.off(T.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), t.off(T.ERROR, this.onError, this), t.off(T.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.off(T.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.off(T.BUFFER_CREATED, this.onBufferCreated, this), t.off(T.BUFFER_FLUSHED, this.onBufferFlushed, this), t.off(T.LEVELS_UPDATED, this.onLevelsUpdated, this), t.off(T.FRAG_BUFFERED, this.onFragBuffered, this)
                }
                onHandlerDestroying() {
                    this._unregisterListeners(), super.onHandlerDestroying()
                }
                startLoad(t) {
                    if (this.levels) {
                        const {
                            lastCurrentTime: e,
                            hls: i
                        } = this;
                        if (this.stopLoad(), this.setInterval(100), this.level = -1, !this.startFragRequested) {
                            let t = i.startLevel; - 1 === t && (i.config.testBandwidth && this.levels.length > 1 ? (t = 0, this.bitrateTest = !0) : t = i.firstAutoLevel), i.nextLoadLevel = t, this.level = i.loadLevel, this.loadedmetadata = !1
                        }
                        e > 0 && -1 === t && (this.log(`Override startPosition with lastCurrentTime @${e.toFixed(3)}`), t = e), this.state = pr, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = t, this.tick()
                    } else this._forceStartLoad = !0, this.state = mr
                }
                stopLoad() {
                    this._forceStartLoad = !1, super.stopLoad()
                }
                doTick() {
                    switch (this.state) {
                        case Rr:
                            {
                                const {
                                    levels: t,
                                    level: e
                                } = this,
                                i = null == t ? void 0 : t[e],
                                r = null == i ? void 0 : i.details;
                                if (r && (!r.live || this.levelLastLoaded === i)) {
                                    if (this.waitForCdnTuneIn(r)) break;
                                    this.state = pr;
                                    break
                                }
                                if (this.hls.nextLoadLevel !== this.level) {
                                    this.state = pr;
                                    break
                                }
                                break
                            }
                        case Tr:
                            {
                                var t;
                                const e = self.performance.now(),
                                    i = this.retryDate;
                                if (!i || e >= i || null != (t = this.media) && t.seeking) {
                                    const {
                                        levels: t,
                                        level: e
                                    } = this, i = null == t ? void 0 : t[e];
                                    this.resetStartWhenNotLoaded(i || null), this.state = pr
                                }
                            }
                    }
                    this.state === pr && this.doTickIdle(), this.onTickEnd()
                }
                onTickEnd() {
                    super.onTickEnd(), this.checkBuffer(), this.checkFragmentChanged()
                }
                doTickIdle() {
                    const {
                        hls: t,
                        levelLastLoaded: e,
                        levels: i,
                        media: r
                    } = this;
                    if (null === e || !r && (this.startFragRequested || !t.config.startFragPrefetch)) return;
                    if (this.altAudio && this.audioOnly) return;
                    const s = t.nextLoadLevel;
                    if (null == i || !i[s]) return;
                    const n = i[s],
                        a = this.getMainFwdBufferInfo();
                    if (null === a) return;
                    const o = this.getLevelDetails();
                    if (o && this._streamEnded(a, o)) {
                        const t = {};
                        return this.altAudio && (t.type = "video"), this.hls.trigger(T.BUFFER_EOS, t), void(this.state = Ar)
                    }
                    t.loadLevel !== s && -1 === t.manualLevel && this.log(`Adapting to level ${s} from level ${this.level}`), this.level = t.nextLoadLevel = s;
                    const l = n.details;
                    if (!l || this.state === Rr || l.live && this.levelLastLoaded !== n) return this.level = s, void(this.state = Rr);
                    const u = a.len,
                        c = this.getMaxBufferLength(n.maxBitrate);
                    if (u >= c) return;
                    this.backtrackFragment && this.backtrackFragment.start > a.end && (this.backtrackFragment = null);
                    const h = this.backtrackFragment ? this.backtrackFragment.start : a.end;
                    let d = this.getNextFragment(h, l);
                    if (this.couldBacktrack && !this.fragPrevious && d && "initSegment" !== d.sn && this.fragmentTracker.getState(d) !== qi) {
                        var f;
                        const t = (null != (f = this.backtrackFragment) ? f : d).sn - l.startSN,
                            e = l.fragments[t - 1];
                        e && d.cc === e.cc && (d = e, this.fragmentTracker.removeFragment(e))
                    } else this.backtrackFragment && a.len && (this.backtrackFragment = null);
                    if (d && this.isLoopLoading(d, h)) {
                        if (!d.gap) {
                            const t = this.audioOnly && !this.altAudio ? x : M,
                                e = (t === M ? this.videoBuffer : this.mediaBuffer) || this.media;
                            e && this.afterBufferFlushed(e, t, Ie)
                        }
                        d = this.getNextFragmentLoopLoading(d, l, a, Ie, c)
                    }
                    d && (!d.initSegment || d.initSegment.data || this.bitrateTest || (d = d.initSegment), this.loadFragment(d, n, h))
                }
                loadFragment(t, e, i) {
                    const r = this.fragmentTracker.getState(t);
                    this.fragCurrent = t, r === Wi || r === ji ? "initSegment" === t.sn ? this._loadInitSegment(t, e) : this.bitrateTest ? (this.log(`Fragment ${t.sn} of level ${t.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(t, e)) : (this.startFragRequested = !0, super.loadFragment(t, e, i)) : this.clearTrackerIfNeeded(t)
                }
                getBufferedFrag(t) {
                    return this.fragmentTracker.getBufferedFrag(t, Ie)
                }
                followingBufferedFrag(t) {
                    return t ? this.getBufferedFrag(t.end + .5) : null
                }
                immediateLevelSwitch() {
                    this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
                }
                nextLevelSwitch() {
                    const {
                        levels: t,
                        media: e
                    } = this;
                    if (null != e && e.readyState) {
                        let i;
                        const r = this.getAppendedFrag(e.currentTime);
                        r && r.start > 1 && this.flushMainBuffer(0, r.start - 1);
                        const s = this.getLevelDetails();
                        if (null != s && s.live) {
                            const t = this.getMainFwdBufferInfo();
                            if (!t || t.len < 2 * s.targetduration) return
                        }
                        if (!e.paused && t) {
                            const e = t[this.hls.nextLoadLevel],
                                r = this.fragLastKbps;
                            i = r && this.fragCurrent ? this.fragCurrent.duration * e.maxBitrate / (1e3 * r) + 1 : 0
                        } else i = 0;
                        const n = this.getBufferedFrag(e.currentTime + i);
                        if (n) {
                            const t = this.followingBufferedFrag(n);
                            if (t) {
                                this.abortCurrentFrag();
                                const e = t.maxStartPTS ? t.maxStartPTS : t.start,
                                    i = t.duration,
                                    r = Math.max(n.end, e + Math.min(Math.max(i - this.config.maxFragLookUpTolerance, i * (this.couldBacktrack ? .5 : .125)), i * (this.couldBacktrack ? .75 : .25)));
                                this.flushMainBuffer(r, Number.POSITIVE_INFINITY)
                            }
                        }
                    }
                }
                abortCurrentFrag() {
                    const t = this.fragCurrent;
                    switch (this.fragCurrent = null, this.backtrackFragment = null, t && (t.abortRequests(), this.fragmentTracker.removeFragment(t)), this.state) {
                        case vr:
                        case yr:
                        case Tr:
                        case Sr:
                        case br:
                            this.state = pr
                    }
                    this.nextLoadPosition = this.getLoadPosition()
                }
                flushMainBuffer(t, e) {
                    super.flushMainBuffer(t, e, this.altAudio ? "video" : null)
                }
                onMediaAttached(t, e) {
                    super.onMediaAttached(t, e);
                    const i = e.media;
                    this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), i.addEventListener("playing", this.onvplaying), i.addEventListener("seeked", this.onvseeked), this.gapController = new Ka(this.config, i, this.fragmentTracker, this.hls)
                }
                onMediaDetaching() {
                    const {
                        media: t
                    } = this;
                    t && this.onvplaying && this.onvseeked && (t.removeEventListener("playing", this.onvplaying), t.removeEventListener("seeked", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), super.onMediaDetaching()
                }
                onMediaPlaying() {
                    this.tick()
                }
                onMediaSeeked() {
                    const t = this.media,
                        e = t ? t.currentTime : null;
                    p(e) && this.log(`Media seeked to ${e.toFixed(3)}`);
                    const i = this.getMainFwdBufferInfo();
                    null !== i && 0 !== i.len ? this.tick() : this.warn(`Main forward buffer length on "seeked" event ${i?i.len:"empty"})`)
                }
                onManifestLoading() {
                    this.log("Trigger BUFFER_RESET"), this.hls.trigger(T.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = !1, this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0, this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null, this.altAudio = this.audioOnly = this.startFragRequested = !1
                }
                onManifestParsed(t, e) {
                    let i = !1,
                        r = !1;
                    e.levels.forEach((t => {
                        const e = t.audioCodec;
                        e && (i = i || -1 !== e.indexOf("mp4a.40.2"), r = r || -1 !== e.indexOf("mp4a.40.5"))
                    })), this.audioCodecSwitch = i && r && ! function() {
                        var t;
                        const e = Va();
                        return "function" == typeof(null == e || null == (t = e.prototype) ? void 0 : t.changeType)
                    }(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = e.levels, this.startFragRequested = !1
                }
                onLevelLoading(t, e) {
                    const {
                        levels: i
                    } = this;
                    if (!i || this.state !== pr) return;
                    const r = i[e.level];
                    (!r.details || r.details.live && this.levelLastLoaded !== r || this.waitForCdnTuneIn(r.details)) && (this.state = Rr)
                }
                onLevelLoaded(t, e) {
                    var i;
                    const {
                        levels: r
                    } = this, s = e.level, n = e.details, a = n.totalduration;
                    if (!r) return void this.warn(`Levels were reset while loading level ${s}`);
                    this.log(`Level ${s} loaded [${n.startSN},${n.endSN}]${n.lastPartSn?`[part-${n.lastPartSn}-${n.lastPartIndex}]`:""}, cc [${n.startCC}, ${n.endCC}] duration:${a}`);
                    const o = r[s],
                        l = this.fragCurrent;
                    !l || this.state !== yr && this.state !== Tr || l.level !== e.level && l.loader && this.abortCurrentFrag();
                    let u = 0;
                    if (n.live || null != (i = o.details) && i.live) {
                        var c;
                        if (this.checkLiveUpdate(n), n.deltaUpdateFailed) return;
                        u = this.alignPlaylists(n, o.details, null == (c = this.levelLastLoaded) ? void 0 : c.details)
                    }
                    if (o.details = n, this.levelLastLoaded = o, this.hls.trigger(T.LEVEL_UPDATED, {
                            details: n,
                            level: s
                        }), this.state === Rr) {
                        if (this.waitForCdnTuneIn(n)) return;
                        this.state = pr
                    }
                    this.startFragRequested ? n.live && this.synchronizeToLiveEdge(n) : this.setStartPosition(n, u), this.tick()
                }
                _handleFragmentLoadProgress(t) {
                    var e;
                    const {
                        frag: i,
                        part: r,
                        payload: s
                    } = t, {
                        levels: n
                    } = this;
                    if (!n) return void this.warn(`Levels were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`);
                    const a = n[i.level],
                        o = a.details;
                    if (!o) return this.warn(`Dropping fragment ${i.sn} of level ${i.level} after level details were reset`), void this.fragmentTracker.removeFragment(i);
                    const l = a.videoCodec,
                        u = o.PTSKnown || !o.live,
                        c = null == (e = i.initSegment) ? void 0 : e.data,
                        h = this._getAudioCodec(a),
                        d = this.transmuxer = this.transmuxer || new Os(this.hls, Ie, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)),
                        f = r ? r.index : -1,
                        g = -1 !== f,
                        m = new Zi(i.level, i.sn, i.stats.chunkCount, s.byteLength, f, g),
                        p = this.initPTS[i.cc];
                    d.push(s, c, h, l, i, r, o.totalduration, u, m, p)
                }
                onAudioTrackSwitching(t, e) {
                    const i = this.altAudio;
                    if (!!!e.url) {
                        if (this.mediaBuffer !== this.media) {
                            this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
                            const t = this.fragCurrent;
                            t && (this.log("Switching to main audio track, cancel main fragment load"), t.abortRequests(), this.fragmentTracker.removeFragment(t)), this.resetTransmuxer(), this.resetLoadingState()
                        } else this.audioOnly && this.resetTransmuxer();
                        const t = this.hls;
                        i && (t.trigger(T.BUFFER_FLUSHING, {
                            startOffset: 0,
                            endOffset: Number.POSITIVE_INFINITY,
                            type: null
                        }), this.fragmentTracker.removeAllFragments()), t.trigger(T.AUDIO_TRACK_SWITCHED, e)
                    }
                }
                onAudioTrackSwitched(t, e) {
                    const i = e.id,
                        r = !!this.hls.audioTracks[i].url;
                    if (r) {
                        const t = this.videoBuffer;
                        t && this.mediaBuffer !== t && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = t)
                    }
                    this.altAudio = r, this.tick()
                }
                onBufferCreated(t, e) {
                    const i = e.tracks;
                    let r, s, n = !1;
                    for (const t in i) {
                        const e = i[t];
                        if ("main" === e.id) {
                            if (s = t, r = e, "video" === t) {
                                const e = i[t];
                                e && (this.videoBuffer = e.buffer)
                            }
                        } else n = !0
                    }
                    n && r ? (this.log(`Alternate track found, use ${s}.buffered to schedule main fragment loading`), this.mediaBuffer = r.buffer) : this.mediaBuffer = this.media
                }
                onFragBuffered(t, e) {
                    const {
                        frag: i,
                        part: r
                    } = e;
                    if (i && i.type !== Ie) return;
                    if (this.fragContextChanged(i)) return this.warn(`Fragment ${i.sn}${r?" p: "+r.index:""} of level ${i.level} finished buffering, but was aborted. state: ${this.state}`), void(this.state === br && (this.state = pr));
                    const s = r ? r.stats : i.stats;
                    this.fragLastKbps = Math.round(8 * s.total / (s.buffering.end - s.loading.first)), "initSegment" !== i.sn && (this.fragPrevious = i), this.fragBufferedComplete(i, r)
                }
                onError(t, e) {
                    var i;
                    if (e.fatal) this.state = Lr;
                    else switch (e.details) {
                        case S.FRAG_GAP:
                        case S.FRAG_PARSING_ERROR:
                        case S.FRAG_DECRYPT_ERROR:
                        case S.FRAG_LOAD_ERROR:
                        case S.FRAG_LOAD_TIMEOUT:
                        case S.KEY_LOAD_ERROR:
                        case S.KEY_LOAD_TIMEOUT:
                            this.onFragmentOrKeyLoadError(Ie, e);
                            break;
                        case S.LEVEL_LOAD_ERROR:
                        case S.LEVEL_LOAD_TIMEOUT:
                        case S.LEVEL_PARSING_ERROR:
                            e.levelRetry || this.state !== Rr || (null == (i = e.context) ? void 0 : i.type) !== _e || (this.state = pr);
                            break;
                        case S.BUFFER_APPEND_ERROR:
                        case S.BUFFER_FULL_ERROR:
                            if (!e.parent || "main" !== e.parent) return;
                            if (e.details === S.BUFFER_APPEND_ERROR) return void this.resetLoadingState();
                            this.reduceLengthAndFlushBuffer(e) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
                            break;
                        case S.INTERNAL_EXCEPTION:
                            this.recoverWorkerError(e)
                    }
                }
                checkBuffer() {
                    const {
                        media: t,
                        gapController: e
                    } = this;
                    if (t && e && t.readyState) {
                        if (this.loadedmetadata || !Ji.getBuffered(t).length) {
                            const t = this.state !== pr ? this.fragCurrent : null;
                            e.poll(this.lastCurrentTime, t)
                        }
                        this.lastCurrentTime = t.currentTime
                    }
                }
                onFragLoadEmergencyAborted() {
                    this.state = pr, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate()
                }
                onBufferFlushed(t, {
                    type: e
                }) {
                    if (e !== x || this.audioOnly && !this.altAudio) {
                        const t = (e === M ? this.videoBuffer : this.mediaBuffer) || this.media;
                        this.afterBufferFlushed(t, e, Ie), this.tick()
                    }
                }
                onLevelsUpdated(t, e) {
                    this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level), this.levels = e.levels
                }
                swapAudioCodec() {
                    this.audioCodecSwap = !this.audioCodecSwap
                }
                seekToStartPos() {
                    const {
                        media: t
                    } = this;
                    if (!t) return;
                    const e = t.currentTime;
                    let i = this.startPosition;
                    if (i >= 0 && e < i) {
                        if (t.seeking) return void this.log(`could not seek to ${i}, already seeking at ${e}`);
                        const r = Ji.getBuffered(t),
                            s = (r.length ? r.start(0) : 0) - i;
                        s > 0 && (s < this.config.maxBufferHole || s < this.config.maxFragLookUpTolerance) && (this.log(`adjusting start position by ${s} to match buffer start`), i += s, this.startPosition = i), this.log(`seek to target start position ${i} from current time ${e}`), t.currentTime = i
                    }
                }
                _getAudioCodec(t) {
                    let e = this.config.defaultAudioCodec || t.audioCodec;
                    return this.audioCodecSwap && e && (this.log("Swapping audio codec"), e = -1 !== e.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), e
                }
                _loadBitrateTestFrag(t, e) {
                    t.bitrateTest = !0, this._doFragLoad(t, e).then((i => {
                        const {
                            hls: r
                        } = this;
                        if (!i || this.fragContextChanged(t)) return;
                        e.fragmentError = 0, this.state = pr, this.startFragRequested = !1, this.bitrateTest = !1;
                        const s = t.stats;
                        s.parsing.start = s.parsing.end = s.buffering.start = s.buffering.end = self.performance.now(), r.trigger(T.FRAG_LOADED, i), t.bitrateTest = !1
                    }))
                }
                _handleTransmuxComplete(t) {
                    var e;
                    const i = "main",
                        {
                            hls: r
                        } = this,
                        {
                            remuxResult: s,
                            chunkMeta: n
                        } = t,
                        a = this.getCurrentContext(n);
                    if (!a) return void this.resetWhenMissingContext(n);
                    const {
                        frag: o,
                        part: l,
                        level: u
                    } = a, {
                        video: c,
                        text: h,
                        id3: d,
                        initSegment: f
                    } = s, {
                        details: g
                    } = u, m = this.altAudio ? void 0 : s.audio;
                    if (this.fragContextChanged(o)) this.fragmentTracker.removeFragment(o);
                    else {
                        if (this.state = Sr, f) {
                            if (null != f && f.tracks) {
                                const t = o.initSegment || o;
                                this._bufferInitSegment(u, f.tracks, t, n), r.trigger(T.FRAG_PARSING_INIT_SEGMENT, {
                                    frag: t,
                                    id: i,
                                    tracks: f.tracks
                                })
                            }
                            const t = f.initPTS,
                                e = f.timescale;
                            p(t) && (this.initPTS[o.cc] = {
                                baseTime: t,
                                timescale: e
                            }, r.trigger(T.INIT_PTS_FOUND, {
                                frag: o,
                                id: i,
                                initPTS: t,
                                timescale: e
                            }))
                        }
                        if (c && g && "initSegment" !== o.sn) {
                            const t = g.fragments[o.sn - 1 - g.startSN],
                                e = o.sn === g.startSN,
                                i = !t || o.cc > t.cc;
                            if (!1 !== s.independent) {
                                const {
                                    startPTS: t,
                                    endPTS: r,
                                    startDTS: s,
                                    endDTS: a
                                } = c;
                                if (l) l.elementaryStreams[c.type] = {
                                    startPTS: t,
                                    endPTS: r,
                                    startDTS: s,
                                    endDTS: a
                                };
                                else if (c.firstKeyFrame && c.independent && 1 === n.id && !i && (this.couldBacktrack = !0), c.dropped && c.independent) {
                                    const s = this.getMainFwdBufferInfo(),
                                        n = (s ? s.end : this.getLoadPosition()) + this.config.maxBufferHole,
                                        l = c.firstKeyFramePTS ? c.firstKeyFramePTS : t;
                                    if (!e && n < l - this.config.maxBufferHole && !i) return void this.backtrack(o);
                                    i && (o.gap = !0), o.setElementaryStreamInfo(c.type, o.start, r, o.start, a, !0)
                                } else e && t > 2 && (o.gap = !0);
                                o.setElementaryStreamInfo(c.type, t, r, s, a), this.backtrackFragment && (this.backtrackFragment = o), this.bufferFragmentData(c, o, l, n, e || i)
                            } else {
                                if (!e && !i) return void this.backtrack(o);
                                o.gap = !0
                            }
                        }
                        if (m) {
                            const {
                                startPTS: t,
                                endPTS: e,
                                startDTS: i,
                                endDTS: r
                            } = m;
                            l && (l.elementaryStreams[x] = {
                                startPTS: t,
                                endPTS: e,
                                startDTS: i,
                                endDTS: r
                            }), o.setElementaryStreamInfo(x, t, e, i, r), this.bufferFragmentData(m, o, l, n)
                        }
                        if (g && null != d && null != (e = d.samples) && e.length) {
                            const t = {
                                id: i,
                                frag: o,
                                details: g,
                                samples: d.samples
                            };
                            r.trigger(T.FRAG_PARSING_METADATA, t)
                        }
                        if (g && h) {
                            const t = {
                                id: i,
                                frag: o,
                                details: g,
                                samples: h.samples
                            };
                            r.trigger(T.FRAG_PARSING_USERDATA, t)
                        }
                    }
                }
                _bufferInitSegment(t, e, i, r) {
                    if (this.state !== Sr) return;
                    this.audioOnly = !!e.audio && !e.video, this.altAudio && !this.audioOnly && delete e.audio;
                    const {
                        audio: s,
                        video: n,
                        audiovideo: a
                    } = e;
                    if (s) {
                        let e = t.audioCodec;
                        const i = navigator.userAgent.toLowerCase();
                        if (this.audioCodecSwitch) {
                            e && (e = -1 !== e.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5");
                            const t = s.metadata;
                            t && "channelCount" in t && 1 !== (t.channelCount || 1) && -1 === i.indexOf("firefox") && (e = "mp4a.40.5")
                        }
                        e && -1 !== e.indexOf("mp4a.40.5") && -1 !== i.indexOf("android") && "audio/mpeg" !== s.container && (e = "mp4a.40.2", this.log(`Android: force audio codec to ${e}`)), t.audioCodec && t.audioCodec !== e && this.log(`Swapping manifest audio codec "${t.audioCodec}" for "${e}"`), s.levelCodec = e, s.id = "main", this.log(`Init audio buffer, container:${s.container}, codecs[selected/level/parsed]=[${e||""}/${t.audioCodec||""}/${s.codec}]`)
                    }
                    n && (n.levelCodec = t.videoCodec, n.id = "main", this.log(`Init video buffer, container:${n.container}, codecs[level/parsed]=[${t.videoCodec||""}/${n.codec}]`)), a && this.log(`Init audiovideo buffer, container:${a.container}, codecs[level/parsed]=[${t.codecs}/${a.codec}]`), this.hls.trigger(T.BUFFER_CODECS, e), Object.keys(e).forEach((t => {
                        const s = e[t].initSegment;
                        null != s && s.byteLength && this.hls.trigger(T.BUFFER_APPENDING, {
                            type: t,
                            data: s,
                            frag: i,
                            part: null,
                            chunkMeta: r,
                            parent: i.type
                        })
                    })), this.tickImmediate()
                }
                getMainFwdBufferInfo() {
                    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, Ie)
                }
                backtrack(t) {
                    this.couldBacktrack = !0, this.backtrackFragment = t, this.resetTransmuxer(), this.flushBufferGap(t), this.fragmentTracker.removeFragment(t), this.fragPrevious = null, this.nextLoadPosition = t.start, this.state = pr
                }
                checkFragmentChanged() {
                    const t = this.media;
                    let e = null;
                    if (t && t.readyState > 1 && !1 === t.seeking) {
                        const i = t.currentTime;
                        if (Ji.isBuffered(t, i) ? e = this.getAppendedFrag(i) : Ji.isBuffered(t, i + .1) && (e = this.getAppendedFrag(i + .1)), e) {
                            this.backtrackFragment = null;
                            const t = this.fragPlaying,
                                i = e.level;
                            t && e.sn === t.sn && t.level === i || (this.fragPlaying = e, this.hls.trigger(T.FRAG_CHANGED, {
                                frag: e
                            }), t && t.level === i || this.hls.trigger(T.LEVEL_SWITCHED, {
                                level: i
                            }))
                        }
                    }
                }
                get nextLevel() {
                    const t = this.nextBufferedFrag;
                    return t ? t.level : -1
                }
                get currentFrag() {
                    const t = this.media;
                    return t ? this.fragPlaying || this.getAppendedFrag(t.currentTime) : null
                }
                get currentProgramDateTime() {
                    const t = this.media;
                    if (t) {
                        const e = t.currentTime,
                            i = this.currentFrag;
                        if (i && p(e) && p(i.programDateTime)) {
                            const t = i.programDateTime + 1e3 * (e - i.start);
                            return new Date(t)
                        }
                    }
                    return null
                }
                get currentLevel() {
                    const t = this.currentFrag;
                    return t ? t.level : -1
                }
                get nextBufferedFrag() {
                    const t = this.currentFrag;
                    return t ? this.followingBufferedFrag(t) : null
                }
                get forceStartLoad() {
                    return this._forceStartLoad
                }
            }
            class qa {
                static get version() {
                    return "1.5.15"
                }
                static isMSESupported() {
                    return Wa()
                }
                static isSupported() {
                    return function() {
                        if (!Wa()) return !1;
                        const t = re();
                        return "function" == typeof(null == t ? void 0 : t.isTypeSupported) && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some((e => t.isTypeSupported(oe(e, "video")))) || ["mp4a.40.2", "fLaC"].some((e => t.isTypeSupported(oe(e, "audio")))))
                    }()
                }
                static getMediaSource() {
                    return re()
                }
                static get Events() {
                    return T
                }
                static get ErrorTypes() {
                    return E
                }
                static get ErrorDetails() {
                    return S
                }
                static get DefaultConfig() {
                    return qa.defaultConfig ? qa.defaultConfig : Fa
                }
                static set DefaultConfig(t) {
                    qa.defaultConfig = t
                }
                constructor(t = {}) {
                    this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this.started = !1, this._emitter = new Ms, this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null, this.triggeringException = void 0,
                        function(t, e) {
                            if ("object" == typeof console && !0 === t || "object" == typeof t) {
                                k(t, "debug", "log", "info", "warn", "error");
                                try {
                                    L.log(`Debug logs enabled for "${e}" in hls.js version 1.5.15`)
                                } catch (t) {
                                    L = A
                                }
                            } else L = A
                        }(t.debug || !1, "Hls instance");
                    const e = this.config = function(t, e) {
                        if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
                        if (void 0 !== e.liveMaxLatencyDurationCount && (void 0 === e.liveSyncDurationCount || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount)) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
                        if (void 0 !== e.liveMaxLatencyDuration && (void 0 === e.liveSyncDuration || e.liveMaxLatencyDuration <= e.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
                        const i = Na(t),
                            r = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
                        return ["manifest", "level", "frag"].forEach((t => {
                            const s = `${"level"===t?"playlist":t}LoadPolicy`,
                                n = void 0 === e[s],
                                a = [];
                            r.forEach((r => {
                                const o = `${t}Loading${r}`,
                                    l = e[o];
                                if (void 0 !== l && n) {
                                    a.push(o);
                                    const t = i[s].default;
                                    switch (e[s] = {
                                        default: t
                                    }, r) {
                                        case "TimeOut":
                                            t.maxLoadTimeMs = l, t.maxTimeToFirstByteMs = l;
                                            break;
                                        case "MaxRetry":
                                            t.errorRetry.maxNumRetry = l, t.timeoutRetry.maxNumRetry = l;
                                            break;
                                        case "RetryDelay":
                                            t.errorRetry.retryDelayMs = l, t.timeoutRetry.retryDelayMs = l;
                                            break;
                                        case "MaxRetryTimeout":
                                            t.errorRetry.maxRetryDelayMs = l, t.timeoutRetry.maxRetryDelayMs = l
                                    }
                                }
                            })), a.length && R.warn(`hls.js config: "${a.join('", "')}" setting(s) are deprecated, use "${s}": ${JSON.stringify(e[s])}`)
                        })), d(d({}, i), e)
                    }(qa.DefaultConfig, t);
                    this.userConfig = t, e.progressive && Ba(e);
                    const {
                        abrController: i,
                        bufferController: r,
                        capLevelController: s,
                        errorController: n,
                        fpsController: a
                    } = e, o = new n(this), l = this.abrController = new i(this), u = this.bufferController = new r(this), c = this.capLevelController = new s(this), h = new a(this), f = new Fe(this), g = new ze(this), m = e.contentSteeringController, p = m ? new m(this) : null, v = this.levelController = new $a(this, p), y = new Yi(this), E = new Ha(this.config), S = this.streamController = new ja(this, y, E);
                    c.setStreamController(S), h.setStreamController(S);
                    const b = [f, v, S];
                    p && b.splice(1, 0, p), this.networkControllers = b;
                    const w = [l, u, c, h, g, y];
                    this.audioTrackController = this.createController(e.audioTrackController, b);
                    const _ = e.audioStreamController;
                    _ && b.push(new _(this, y, E)), this.subtitleTrackController = this.createController(e.subtitleTrackController, b);
                    const D = e.subtitleStreamController;
                    D && b.push(new D(this, y, E)), this.createController(e.timelineController, w), E.emeController = this.emeController = this.createController(e.emeController, w), this.cmcdController = this.createController(e.cmcdController, w), this.latencyController = this.createController(Xe, w), this.coreComponents = w, b.push(o);
                    const C = o.onErrorOut;
                    "function" == typeof C && this.on(T.ERROR, C, o)
                }
                createController(t, e) {
                    if (t) {
                        const i = new t(this);
                        return e && e.push(i), i
                    }
                    return null
                }
                on(t, e, i = this) {
                    this._emitter.on(t, e, i)
                }
                once(t, e, i = this) {
                    this._emitter.once(t, e, i)
                }
                removeAllListeners(t) {
                    this._emitter.removeAllListeners(t)
                }
                off(t, e, i = this, r) {
                    this._emitter.off(t, e, i, r)
                }
                listeners(t) {
                    return this._emitter.listeners(t)
                }
                emit(t, e, i) {
                    return this._emitter.emit(t, e, i)
                }
                trigger(t, e) {
                    if (this.config.debug) return this.emit(t, t, e);
                    try {
                        return this.emit(t, t, e)
                    } catch (e) {
                        if (R.error("An internal error happened while handling event " + t + '. Error message: "' + e.message + '". Here is a stacktrace:', e), !this.triggeringException) {
                            this.triggeringException = !0;
                            const i = t === T.ERROR;
                            this.trigger(T.ERROR, {
                                type: E.OTHER_ERROR,
                                details: S.INTERNAL_EXCEPTION,
                                fatal: i,
                                event: t,
                                error: e
                            }), this.triggeringException = !1
                        }
                    }
                    return !1
                }
                listenerCount(t) {
                    return this._emitter.listenerCount(t)
                }
                destroy() {
                    R.log("destroy"), this.trigger(T.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach((t => t.destroy())), this.networkControllers.length = 0, this.coreComponents.forEach((t => t.destroy())), this.coreComponents.length = 0;
                    const t = this.config;
                    t.xhrSetup = t.fetchSetup = void 0, this.userConfig = null
                }
                attachMedia(t) {
                    R.log("attachMedia"), this._media = t, this.trigger(T.MEDIA_ATTACHING, {
                        media: t
                    })
                }
                detachMedia() {
                    R.log("detachMedia"), this.trigger(T.MEDIA_DETACHING, void 0), this._media = null
                }
                loadSource(t) {
                    this.stopLoad();
                    const e = this.media,
                        i = this.url,
                        r = this.url = c.buildAbsoluteURL(self.location.href, t, {
                            alwaysNormalize: !0
                        });
                    this._autoLevelCapping = -1, this._maxHdcpLevel = null, R.log(`loadSource:${r}`), e && i && (i !== r || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(e)), this.trigger(T.MANIFEST_LOADING, {
                        url: t
                    })
                }
                startLoad(t = -1) {
                    R.log(`startLoad(${t})`), this.started = !0, this.networkControllers.forEach((e => {
                        e.startLoad(t)
                    }))
                }
                stopLoad() {
                    R.log("stopLoad"), this.started = !1, this.networkControllers.forEach((t => {
                        t.stopLoad()
                    }))
                }
                resumeBuffering() {
                    this.started && this.networkControllers.forEach((t => {
                        "fragmentLoader" in t && t.startLoad(-1)
                    }))
                }
                pauseBuffering() {
                    this.networkControllers.forEach((t => {
                        "fragmentLoader" in t && t.stopLoad()
                    }))
                }
                swapAudioCodec() {
                    R.log("swapAudioCodec"), this.streamController.swapAudioCodec()
                }
                recoverMediaError() {
                    R.log("recoverMediaError");
                    const t = this._media;
                    this.detachMedia(), t && this.attachMedia(t)
                }
                removeLevel(t) {
                    this.levelController.removeLevel(t)
                }
                get levels() {
                    const t = this.levelController.levels;
                    return t || []
                }
                get currentLevel() {
                    return this.streamController.currentLevel
                }
                set currentLevel(t) {
                    R.log(`set currentLevel:${t}`), this.levelController.manualLevel = t, this.streamController.immediateLevelSwitch()
                }
                get nextLevel() {
                    return this.streamController.nextLevel
                }
                set nextLevel(t) {
                    R.log(`set nextLevel:${t}`), this.levelController.manualLevel = t, this.streamController.nextLevelSwitch()
                }
                get loadLevel() {
                    return this.levelController.level
                }
                set loadLevel(t) {
                    R.log(`set loadLevel:${t}`), this.levelController.manualLevel = t
                }
                get nextLoadLevel() {
                    return this.levelController.nextLoadLevel
                }
                set nextLoadLevel(t) {
                    this.levelController.nextLoadLevel = t
                }
                get firstLevel() {
                    return Math.max(this.levelController.firstLevel, this.minAutoLevel)
                }
                set firstLevel(t) {
                    R.log(`set firstLevel:${t}`), this.levelController.firstLevel = t
                }
                get startLevel() {
                    const t = this.levelController.startLevel;
                    return -1 === t && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : t
                }
                set startLevel(t) {
                    R.log(`set startLevel:${t}`), -1 !== t && (t = Math.max(t, this.minAutoLevel)), this.levelController.startLevel = t
                }
                get capLevelToPlayerSize() {
                    return this.config.capLevelToPlayerSize
                }
                set capLevelToPlayerSize(t) {
                    const e = !!t;
                    e !== this.config.capLevelToPlayerSize && (e ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = e)
                }
                get autoLevelCapping() {
                    return this._autoLevelCapping
                }
                get bandwidthEstimate() {
                    const {
                        bwEstimator: t
                    } = this.abrController;
                    return t ? t.getEstimate() : NaN
                }
                set bandwidthEstimate(t) {
                    this.abrController.resetEstimator(t)
                }
                get ttfbEstimate() {
                    const {
                        bwEstimator: t
                    } = this.abrController;
                    return t ? t.getEstimateTTFB() : NaN
                }
                set autoLevelCapping(t) {
                    this._autoLevelCapping !== t && (R.log(`set autoLevelCapping:${t}`), this._autoLevelCapping = t, this.levelController.checkMaxAutoUpdated())
                }
                get maxHdcpLevel() {
                    return this._maxHdcpLevel
                }
                set maxHdcpLevel(t) {
                    (function(t) {
                        return Qe.indexOf(t) > -1
                    })(t) && this._maxHdcpLevel !== t && (this._maxHdcpLevel = t, this.levelController.checkMaxAutoUpdated())
                }
                get autoLevelEnabled() {
                    return -1 === this.levelController.manualLevel
                }
                get manualLevel() {
                    return this.levelController.manualLevel
                }
                get minAutoLevel() {
                    const {
                        levels: t,
                        config: {
                            minAutoBitrate: e
                        }
                    } = this;
                    if (!t) return 0;
                    const i = t.length;
                    for (let r = 0; r < i; r++)
                        if (t[r].maxBitrate >= e) return r;
                    return 0
                }
                get maxAutoLevel() {
                    const {
                        levels: t,
                        autoLevelCapping: e,
                        maxHdcpLevel: i
                    } = this;
                    let r;
                    if (r = -1 === e && null != t && t.length ? t.length - 1 : e, i)
                        for (let e = r; e--;) {
                            const r = t[e].attrs["HDCP-LEVEL"];
                            if (r && r <= i) return e
                        }
                    return r
                }
                get firstAutoLevel() {
                    return this.abrController.firstAutoLevel
                }
                get nextAutoLevel() {
                    return this.abrController.nextAutoLevel
                }
                set nextAutoLevel(t) {
                    this.abrController.nextAutoLevel = t
                }
                get playingDate() {
                    return this.streamController.currentProgramDateTime
                }
                get mainForwardBufferInfo() {
                    return this.streamController.getMainFwdBufferInfo()
                }
                setAudioOption(t) {
                    var e;
                    return null == (e = this.audioTrackController) ? void 0 : e.setAudioOption(t)
                }
                setSubtitleOption(t) {
                    var e;
                    return null == (e = this.subtitleTrackController) || e.setSubtitleOption(t), null
                }
                get allAudioTracks() {
                    const t = this.audioTrackController;
                    return t ? t.allAudioTracks : []
                }
                get audioTracks() {
                    const t = this.audioTrackController;
                    return t ? t.audioTracks : []
                }
                get audioTrack() {
                    const t = this.audioTrackController;
                    return t ? t.audioTrack : -1
                }
                set audioTrack(t) {
                    const e = this.audioTrackController;
                    e && (e.audioTrack = t)
                }
                get allSubtitleTracks() {
                    const t = this.subtitleTrackController;
                    return t ? t.allSubtitleTracks : []
                }
                get subtitleTracks() {
                    const t = this.subtitleTrackController;
                    return t ? t.subtitleTracks : []
                }
                get subtitleTrack() {
                    const t = this.subtitleTrackController;
                    return t ? t.subtitleTrack : -1
                }
                get media() {
                    return this._media
                }
                set subtitleTrack(t) {
                    const e = this.subtitleTrackController;
                    e && (e.subtitleTrack = t)
                }
                get subtitleDisplay() {
                    const t = this.subtitleTrackController;
                    return !!t && t.subtitleDisplay
                }
                set subtitleDisplay(t) {
                    const e = this.subtitleTrackController;
                    e && (e.subtitleDisplay = t)
                }
                get lowLatencyMode() {
                    return this.config.lowLatencyMode
                }
                set lowLatencyMode(t) {
                    this.config.lowLatencyMode = t
                }
                get liveSyncPosition() {
                    return this.latencyController.liveSyncPosition
                }
                get latency() {
                    return this.latencyController.latency
                }
                get maxLatency() {
                    return this.latencyController.maxLatency
                }
                get targetLatency() {
                    return this.latencyController.targetLatency
                }
                get drift() {
                    return this.latencyController.drift
                }
                get forceStartLoad() {
                    return this.streamController.forceStartLoad
                }
            }
            qa.defaultConfig = void 0
        }
    },
    __webpack_module_cache__ = {};

function __webpack_require__(t) {
    var e = __webpack_module_cache__[t];
    if (void 0 !== e) return e.exports;
    var i = __webpack_module_cache__[t] = {
        exports: {}
    };
    return __webpack_modules__[t](i, i.exports, __webpack_require__), i.exports
}
__webpack_require__.d = (t, e) => {
    for (var i in e) __webpack_require__.o(e, i) && !__webpack_require__.o(t, i) && Object.defineProperty(t, i, {
        enumerable: !0,
        get: e[i]
    })
}, __webpack_require__.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), __webpack_require__.r = t => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
    }), Object.defineProperty(t, "__esModule", {
        value: !0
    })
};
var __webpack_exports__ = {};
__webpack_require__.d(__webpack_exports__, {
    default: () => __WEBPACK_DEFAULT_EXPORT__
});
var wistia_namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3),
    _embeds_media_players_vulcanV2Player_engines_hls_video_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(555);
const __WEBPACK_DEFAULT_EXPORT__ = _embeds_media_players_vulcanV2Player_engines_hls_video_index_js__WEBPACK_IMPORTED_MODULE_1__.default;
var __webpack_exports__default = __webpack_exports__.default;
export {
    __webpack_exports__default as
    default
};
//# sourceMappingURL=hls_video.js.map